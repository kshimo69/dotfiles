Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja, Node: Pop Up Window, Next: Force Same Window, Prev: Other Window, Up: Windows

別のウィンドウに表示する
========================

`C-x 4'は, （ウィンドウが1つだけならば分割して）別のウィンドウを選択し
て, そのウィンドウでバッファを選択するコマンドのプレフィックスキーです. 
異なる`C-x 4'コマンドは, 異なる方法で選択するバッファを探します.

`C-x 4 b BUFNAME RET'
     別のウィンドウでバッファBUFNAMEを選択する.  このコマンドは,
     `switch-to-buffer-other-window'を実行する.
`C-x 4 C-o BUFNAME RET'
     別のウィンドウでバッファBUFNAMEを表示するが, そのウィンドウもその
     バッファも選択しない.  このコマンドは, `display-buffer'を実行する.
`C-x 4 f FILENAME RET'
     ファイルFILENAMEを訪問して, 別のウィンドウでそのバッファを選択す
     る.  このコマンドは, `find-file-other-window'を実行する.  *Note
     Visiting::.
`C-x 4 d DIRECTORY RET'
     別のウィンドウでディレクトリDIRECTORYに対するdiredバッファを選択
     する.  このコマンドは, `dired-other-window'を実行する.  *Note
     Dired::.
`C-x 4 m'
     別のウィンドウでメイルメッセージを作成し始める.  このコマンドは,
     `mail-other-window'を実行する.  これは, 同じウィンドウを使う`C-x
     m'に類似したもの.  （*Note Sending Mail::）.
`C-x 4 .'
     別のウィンドウで現在のタグテーブルのタグを探す.  このコマンドは,
     `find-tag-other-window'を実行するが, `M-.'の複数ウィンドウ向けの
     変種（*Note Tags::）.
`C-x 4 r FILENAME RET'
     ファイルFILENAMEを読み出し専用で訪問し, 別のウィンドウでそのバッ
     ファを選択する.  このコマンドは 
     `find-file-read-only-other-window'を実行する.  *Note Visiting::.



File: emacs-ja, Node: Force Same Window, Next: Change Window, Prev: Pop Up Window, Up: Windows

同じウィンドウへの強制表示
==========================

ある種のEmacsコマンドは, 特別な内容を持つ特有のバッファに切り替えます. 
たとえば, `M-x shell'は, `*Shell*'という名前のバッファに切り替えます. 
慣習では, これらのすべてのコマンドは, 別のウィンドウにバッファを立ち上
げるようにプログラムされています.  しかし, これらのバッファのいくつか
を選択されているウィンドウに表示するように指定できます.

バッファ名をリスト`same-window-buffer-names'に追加すると, そういったコ
マンドは, 選択されているウィンドウで特定のバッファに切り替えます.  た
とえば, そのリストに要素`"*grep*"'を追加すれば, `grep'コマンドは, 選択
されているウィンドウにその出力バッファを表示します.

`same-window-buffer-names'のデフォルト値は`nil'ではありません.  （古い
Emacsパッケージが使うものも含めて）バッファ名, `*info*', `*mail*',
`*shell*'を指定してあります.  このため, `M-x shell'が通常は選択されて
いるウィンドウで`*shell*'バッファに切り替えるのです.  もしこの要素を
`same-window-buffer-names'から削除すると, `M-x shell'のふるまいは変わ
ります.  かわりに別のウィンドウでバッファを立ち上げます.

これらのバッファを, より一般的に変数`same-window-regexps'で指定できま
す.  この変数には, 正規表現のリストを設定します.  そうすると, 正規表現
の1つに一致するバッファはどれも, 選択されているウィンドウでバッファを
切り替えて表示します.  （繰り返すが, これは, 普通は別のウィンドウに表
示されるバッファのみにあてはまる. ）この変数のデフォルト値には, telnet
バッファとrloginバッファが指定されています.

類似の機能で, 独立したフレームに表示させるバッファを指定することができ
ます.  *Note Special Buffer Frames::.



File: emacs-ja, Node: Change Window, Next: Frames, Prev: Force Same Window, Up: Windows

ウィンドウの削除と再配置
========================

`C-x 0'
     選択されているウィンドウを削除する（`delete-window'）.  このキー
     列の最後の文字はゼロ.
`C-x 1'
     選択されているウィンドウを除いて, 選択されているフレームのウィン
     ドウすべてを削除する（`delete-other-windows'）.
`C-x 4 0'
     選択されているウィンドウを削除し, その中に表示されているバッファ
     を削除する（`kill-buffer-and-window'）.  このキー列の最後の文字は
     ゼロ.
`C-x ^'
     選択されているウィンドウの高さを大きくする（`enlarge-window'）.
`C-x }'
     選択されているウィンドウの幅を広くする
     （`enlarge-window-horizontally'）.
`C-x {'
     選択されているウィンドウの幅を狭くする
     （`shrink-window-horizontally'）.
`C-x -'
     バッファがそんなに多くの行を必要としないならウィンドウを縮める
     （`shrink-window-if-larger-than-buffer'）.
`C-x +'
     すべてのウィンドウを同じ高さにする（`balance-windows'）.
`Drag-Mouse-1'
     ウィンドウのモード行を`Mouse-1'で上下にドラッグして, ウィンドウの
     高さを変更する.
`Mouse-2'
     ウィンドウのモード行で`Mouse-2'をクリックすると, フレーム内のその
     ウィンドウ以外のすべてのウィンドウを削除する
     （`mouse-delete-other-windows'）.
`Mouse-3'
     ウィンドウのモード行で`Mouse-3'をクリックすると, そのウィンドウを
     削除する（`mouse-delete-window'）.

ウィンドウを削除するには, `C-x 0'（`delete-window'）と打ちます（これは
ゼロ）.  削除されたウィンドウが占めていた場所は, 隣接のウィンドウに与
えられます.  （ただし, ミニバッファのウィンドウを使っている場合でも, 
ミニバッファのウィンドウには与えない. ）ウィンドウを一度削除すると, そ
の属性は失われます.  ウィンドウの構成情報を回復する以外にウィンドウを
もとに戻す方法はありません.  ウィンドウを削除しても, そこに表示してい
たバッファには何の影響もありません.  バッファは存在し続け, どのウィン
ドウへでも`C-x b'で選択できます.

`C-x 4 0'（`kill-buffer-and-window'）は, `C-x 0'よりも強いコマンドです. 
これは, カレントバッファを削除し, そこで選択されていたウィンドウを削除
します.

`C-x 1'（`delete-other-windows'）は, 別の意味でさらに強力です.  選択さ
れているウィンドウ（とミニバッファ）を除いて, すべてのウィンドウを削除
します.  選択されているウィンドウは, エコー領域を除いたフレーム全体を
使うように広がります.

モード行で`Mouse-2'をクリックしても, そのウィンドウを削除できます.  モー
ド行で`Mouse-3'をクリックすると, そのウィンドウを除いて, フレーム内の
すべてのウィンドウを削除します.

ウィンドウの高さを調節するもっとも簡単な方法は, マウスを使うことです. 
モード行で`Mouse-1'を押し下げてモード行を上下にドラッグすると, ウィン
ドウの高さを変更できます.

上下に接しているウィンドウの分割を再調整するには, `C-x ^'
（`enlarge-window'）を使います.  このコマンドは, 現在選択されているウィ
ンドウを1行だけ, あるいは, 数引数分の行数だけ大きくします.  負の引数を
指定すると, 選択されているウィンドウは小さくなります.  `C-x }'
（`enlarge-window-horizontally'）は, 選択されているウィンドウを指定さ
れた桁数分だけ広くします.  `C-x {'（`shrink-window-horizontally'）は, 
選択されているウィンドウを指定された桁数分だけ狭くします.

ウィンドウを大きくするとき, その場所は隣のウィンドウから取ります.  そ
の結果, ウィンドウが小さくなりすぎるとそのウィンドウは削除され, その場
所を隣接するウィンドウに与えます.  最小の大きさは変数
`window-min-height'と`window-min-width'で指定します.

コマンド`C-x -'（`shrink-window-if-larger-than-buffer'）は, 選択されて
いるウィンドウの高さが, 表示しているバッファのテキスト全体を表示するた
めに必要な高さよりも大きい場合には, その高さを縮めます.  余った行はフ
レーム内の他のウィンドウに与えられます.

選択されているフレーム内のすべてのウィンドウの高さをすべて同じにするに
は, `C-x +'（`balance-windows'）を使えます.

ミニバッファのテキストにちょうど合うようにミニバッファウィンドウの大き
さを自動的に変更するミニバッファリサイズ（resize-minibuffer）モードに
ついては, *Note Minibuffer Edit::.


File: emacs-ja, Node: Frames, Next: International, Prev: Windows, Up: Top

フレームとXウィンドウシステム
*****************************

Xウィンドウシステムで使っているときには, 1つのEmacsセッションでXのレベ
ルで複数のウィンドウを作ることができます.  Emacsに属するXの各ウィンド
ウは, Emacsのウィンドウを1つ以上含めことができる"フレーム"（frame）を
表示します.  フレームは, 最初は汎用のEmacsのウィンドウを1つ含みますが, 
上下左右に小さなウィンドウに分割できます.  フレームは通常, 専用のエコー
領域とミニバッファを含みますが, それらを含まないものを作ることもできま
す.  その場合は, 別のフレームのエコー領域やミニバッファを使います.

あるフレームでの編集は, 別のフレームにも影響します.  たとえば, あるフ
レームでキルリングにテキストを入れると, 別のフレームでヤンクできます. 
あるフレームで`C-x C-c'でEmacsを終ると, すべてのフレームを終了します.
1つのフレームだけを削除するなら, `C-x 5 0'を使います.

混乱を避けるために, Emacsが実装している細分化できるものを『ウィンドウ』
と呼び, フレームを意味するときにはこの単語を使いません.

MS-DOS用にコンパイルしたEmacsは, ウィンドウシステムのある種の特徴をエ
ミュレートするので, 本章で説明する機能の多くを使うことができます.  詳
しくは, *Note MS-DOS Input::.

* Menu:

* Mouse Commands::      Moving, cutting, and pasting, with the mouse.
* Secondary Selection:: Cutting without altering point and mark.
* Mouse References::    Using the mouse to select an item from a list.
* Menu Mouse Clicks::   Mouse clicks that bring up menus.
* Mode Line Mouse::     Mouse clicks on the mode line.
* Speedbar::            How to make and use a speedbar frame.
* Creating Frames::     Creating additional Emacs frames with various contents.
* Multiple Displays::   How one Emacs job can talk to several displays.
* Special Buffer Frames::  You can make certain buffers have their own frames.
* Frame Parameters::    Changing the colors and other modes of frames.
* Scroll Bars::	        How to enable and disable scroll bars; how to use them.
* Menu Bars::	        Enabling and disabling the menu bar.
* Faces::	        How to change the display style using faces.
* Font Lock::           Minor mode for syntactic highlighting using faces.
* Support Modes::       Font Lock support modes make Font Lock faster.
* Highlight Changes::   Using colors to show where you changed the buffer.
* Misc X::	        Iconifying and deleting frames. Region highlighting.
* Non-Window Terminals::  Multiple frames on terminals that show only one.



File: emacs-ja, Node: Mouse Commands, Next: Secondary Selection, Prev: Frames, Up: Frames

編集用マウスコマンド
====================

リージョンを選択したりコピーしたりするマウスコマンドは, `xterm'プログ
ラムとほぼ互換です.  Emacsと他のXクライアントプログラムとのあいだでコ
ピーするには, Xのマウスコマンドと同じものを使えます.

これらのマウスコマンドでリージョンを選択して, そのあとすぐにファンクショ
ンキーDELETEを打つと, 選択したリージョンを削除します.  ファンクション
キーBACKSPACEやASCII文字DELは, これを行いません.  マウスコマンドと
DELETEのあいだに別のキーを打ったときも, これを行いません.

`Mouse-1'
     クリックした位置にポイントを移動する（`mouse-set-point'）.  通常, 
     左ボタン.

`Drag-Mouse-1'
     ドラッグにより選択したテキストにリージョンを設定し, キルリングに
     それをコピーする（`mouse-set-region'）.  リージョンの始めと終りの
     両方をこのコマンド1つで指定できる.

     ドラッグ中に, ウィンドウの上下からマウスが出ると, マウスがウィン
     ドウ内に戻ってくるまで, ウィンドウを一定の割合でスクロールする. 
     こうして, 画面全体に入りきらないリージョンでも選択できる.  一度に
     スクロールする行数は, マウスがウィンドウの縁からどの程度離れてい
     るかに依存する.  変数`mouse-scroll-min-lines'には最小の行数を指定
     する.

`Mouse-2'
     クリックした場所に, もっとも最近にキルしたテキストをヤンクする
     （`mouse-yank-at-click'）.  通常, 中ボタン.

`Mouse-3'
     このコマンド`mouse-save-then-kill'は, クリックした場所とリージョ
     ンの状態に依存して, いくつかの機能がある.

     もっとも基本的な場合は, ある場所で`Mouse-1'をクリックしてから, 別
     の場所で`Mouse-3'をクリックしたとき.  こうすると, これらの2点のあ
     いだにあるテキストをリージョンとして選択する.  さらに, 新しいリー
     ジョンをキルリングへもコピーするので, 別の場所へそれをコピーでき
     る.

     テキスト上で`Mouse-1'をクリックしてから, スクロールバーでスクロー
     ルしたあとで`Mouse-3'をクリックすると, スクロールする以前の
     （`Mouse-1'でクリックした）場所を覚えていて, そこをリージョンの片
     方の端点として使う.  こうすると, 画面に入りきらないリージョンでも
     選択できる.

     より一般的には, 強調表示されたリージョンがないならば, `Mouse-3'は, 
     ポイントとクリックした位置のあいだのテキストをリージョンとして選
     択する.  これは, ポイントがあった位置にマークを設定し, クリックし
     た位置にポイントを移動することで行う.

     強調表示されたリージョンがある場合, あるいは, ボタン1をドラッグし
     てリージョンを設定してある場合, `Mouse-3'はクリックした場所に近い
     側のリージョンの端をクリック位置に移動して調整する.  また, 調整し
     たリージョンのテキストは, キルリング内の古いリージョンのテキスト
     を置き換える.

     もともと`Mouse-1'をダブルクリックあるいはトリプルクリックして, リー
     ジョンを単語や行単位で設定した場合には, `Mouse-3'によるリージョン
     の調整も単語や行単位で行われる.

     連続して2度同じ場所で`Mouse-3'を使うと, すでに選択してあるリージョ
     ンをキルする.

`Double-Mouse-1'
     このキーは, クリックした単語全体にリージョンを設定する.  『シンボ
     ル』の構文（Cの下線のような）の文字をクリックすると, その文字を囲
     むシンボル全体にリージョンを設定する.

     開き括弧や閉じ括弧の構文の文字をクリックすると, その文字で始まり／
     終る括弧で囲まれた塊（sexp）にリージョンを設定する.  文字列区切り
     の構文（Cのシングルクォートやダブルクォート）の文字をクリックする
     と, （その文字が文字列の始まりか終りかを発見的方法を使って決めて）
     文字列定数を囲むリージョンを設定する.

`Double-Drag-Mouse-1'
     このキーは, ドラッグした範囲内にある単語を囲むリージョンを設定す
     る.

`Triple-Mouse-1'
     このキーは, クリックした行全体を囲むリージョンを設定する.

`Triple-Drag-Mouse-1'
     このキーは, ドラッグした範囲内にある行すべてを囲むリージョンを設
     定する.

マウスを使ったもっとも単純なテキストのキル方法は, 片方の端で`Mouse-1'
を押し, もう一方の端で`Mouse-3'を2回押すことです.  *Note Killing::. 
バッファから削除しないでキルリングにテキストをコピーするには,
`Mouse-3'を一度だけ押します.  あるいは, `Mouse-1'でテキストを横断して
ドラッグするだけです.  そうすると, どこででも, それをヤンクすることで
コピーできます.

キルしたりコピーしたりしたテキストをどこか別の場所にヤンクするには, マ
ウスをその場所に移動して`Mouse-2'を押します.  *Note Yanking::.  しかし,
`mouse-yank-at-point'が`nil'以外ならば, `Mouse-2'はポイント位置にヤン
クします.  つまり, ウィンドウのどこをクリックしたのか, あるいは, フレー
ムのどのウィンドウをクリックしたのかは問題ではありません.  デフォルト
の値は`nil'です.  この変数は二次セレクションのヤンクにも影響します.

別のXのウィンドウへテキストをコピーするには, その部分をキルするかキル
リングに保存します.  Xの管理下では, "一次セレクション"も設定します. 
そのあとで, 別のXのウィンドウで動いているプログラムの『ペースト』や
『ヤンク』コマンドを使って, セレクションからテキストを挿入します.

別のXのウィンドウからテキストをコピーするには, そのウィンドウで動いて
いるプログラムの『カット』や『コピー』コマンドを使って目的のテキストを
セレクションにします.  そのあとで, `C-y'や`Mouse-2'を使ってEmacsにヤン
クします.

これらのカット／ペーストコマンドはMS-Windows上でも動作します.

Emacsがテキストをキルリングに入れたり, キルリングのテキストを先頭へ巡
回するとき, EmacsはXサーバーの一次セレクションに設定します.  このため
に, 別のXクライアントがテキストを参照できるのです.  テキストが十分に短
い場合にのみ（`x-cut-buffer-max'は最大文字数を指定する）, Emacsはカッ
トバッファにもテキストを収めます.  長い文字列をカットバッファへ置くに
は時間がかかります.

キルリングの始めのテキストをヤンクするコマンドは, 実際には, 別のプログ
ラムの一次セレクションをまず調べ, そのあとで, カットバッファのテキスト
を調べます.  どちらにもヤンクするテキストがなれば, キルリングの内容を
使います.



File: emacs-ja, Node: Secondary Selection, Next: Mouse References, Prev: Mouse Commands, Up: Frames

二次セレクション
================

"二次セレクション"は, Xにおいてテキストを選択する別の方法です.  これは, 
ポイントやマークを使わないので, ポイントやマークを設定せずにテキストを
削除するのに使えます.

`M-Drag-Mouse-1'
     ボタンを押した場所を片方の端, ボタンを離した場所をもう一方の端と
     して, 二次セレクションを設定する（`mouse-set-secondary'）.  強調
     表示されドラッグするにつれて変化する.

     ドラッグ中にウィンドウの上下からマウスが出ると, ウィンドウへマウ
     スが戻ってくるまで, ウィンドウを一定の割合でスクロールする.  こう
     して, 画面全体に入りきらないリージョンも選択できる.

`M-Mouse-1'
     "二次セレクション"の一方の端を設定する（`mouse-start-secondary'）.

`M-Mouse-3'
     `M-Mouse-1'で指定した場所を一方の端として使い, 二次セレクションを
     設定する.  （`mouse-secondary-save-then-kill'）.  同じ位置での2回
     目のクリックは, ちょうど作成した二次セレクションをキルする.

`M-Mouse-2'
     クリックした位置に二次セレクションを挿入する
     （`mouse-yank-secondary'）.  ヤンクしたテキストの最後にポイントを
     置く.

`M-Mouse-1'のダブルクリックやトリプルクリックは, `Mouse-1'のように単語
や行単位に作用します.

`mouse-yank-at-point'が`nil'以外ならば, `M-Mouse-2'はポイント位置にヤ
ンクします.  そのときには, どこをクリックしたかは関係なく, どのウィン
ドウをクリックしたかだけが関係します.  *Note Mouse Commands::.



File: emacs-ja, Node: Mouse References, Next: Menu Mouse Clicks, Prev: Secondary Selection, Up: Frames

マウスで参照を辿る
==================

いくつかのEmacsバッファでは, いろいろなものの一覧を表示します.  ファイ
ル一覧, バッファ一覧, 補完候補一覧, パターンに一致したものの一覧などで
す.

これらのバッファにテキストをヤンクできても便利ということはないので, こ
れらの多くは`Mouse-2'を特別に定義して, クリックした項目を使ったり眺め
たりするコマンドとしています.

たとえば, diredバッファのファイル名を`Mouse-2'でクリックすると, そのファ
イルを訪問します.  `*Compilation*'バッファのエラーメッセージを
`Mouse-2'でクリックすると, そのエラーメッセージに対応するソースコード
へ行きます.  `*Completions*'バッファの補完候補を`Mouse-2'でクリックす
ると, その補完候補を選択します.

反応するテキストの上にマウスが移動するとテキストが強調表示されるので,
`Mouse-2'がいつ特別な意味を持つか普通はわかります.



File: emacs-ja, Node: Menu Mouse Clicks, Next: Mode Line Mouse, Prev: Mouse References, Up: Frames

メニューを出すマウスクリック
============================

CTRLやSHIFTキーで修飾されたマウスクリックは, メニューを立ち上げます.

`C-Mouse-1'
     バッファを選択するためのメニュー.

`C-Mouse-2'
     整形済みのテキストに使うフェイスやテキスト属性を指定するためのメ
     ニュー.  *Note Formatted Text::.

`C-Mouse-3'
     モードに特有のメニュー.  ほとんどのモードでは, このメニューは, す
     べてのモード特有のメニューバーメニューを一緒にしたのと同じ項目を
     持つ.  いくつかのモードでは, このボタン (1) (*Note Menu Mouse
     Clicks-Footnotes::) に異なるメニューを指定しているかもしれない.


`S-mouse-1'
     フレームの主要フォントの指定に関するメニュー.


File: emacs-ja  Node: Menu Mouse Clicks-Footnotes, Up: Menu Mouse Clicks

(1) いくつかのシステムでは, `Mouse-3'をモード特有のメニューに
使う.  ユーザーを調査した結果, `Mouse-3'をリージョンの選択と
キルに使い続けることが好まれていることが判明した.  ゆえに, このメ
ニューに対して`C-Mouse-3'を使うことにした.



File: emacs-ja, Node: Mode Line Mouse, Next: Speedbar, Prev: Menu Mouse Clicks, Up: Frames

モード行のマウスコマンド
========================

ウィンドウを選択したり操作するために, ウィンドウのモード行でマウスクリッ
クを使えます.

`Mouse-1'
     モード行で`Mouse-1'をクリックするとその上のウィンドウを選択する. 
     モード行を`Mouse-1'でドラッグするとモード行を移動することができ, 
     そのウィンドウの高さを変更できる.

`Mouse-2'
     モード行で`Mouse-2'をクリックすると, そのフレーム一杯にウィンドウ
     を広げる.

`Mouse-3'
     モード行で`Mouse-3'をクリックすると, その上のウィンドウを削除する.

`C-Mouse-2'
     モード行で`C-Mouse-2'をクリックすると, モード行をクリックした場所
     でその上のウィンドウを左右に分割する.

スクロールバーで`C-Mouse-2'をクリックすると, 対応するウィンドウを上下
に分割します.  *Note Split Window::.



File: emacs-ja, Node: Creating Frames, Next: Multiple Displays, Prev: Speedbar, Up: Frames

フレームの作成
==============

プレフィックスキー`C-x 5'は, `C-x 4'と同じようなサブコマンドがあるとい
う点で似ています.  違いは, `C-x 5'コマンドは, 選択されているフレームで
新たにウィンドウを作るのではなく, 新しいフレームを作ることです（*Note
Pop Up Window::）.  既存の見えているフレームやアイコン化されたフレーム
が, 要求された内容を表示しているなら, これらのコマンドは, 必要ならフレー
ムをいちばん手前にもってきたりアイコンを開いてから, 既存のフレームを使
います.

さまざまな`C-x 5'コマンドは, 選択するバッファの探し方や作成方法が異な
ります.

`C-x 5 2'
     新しいフレームを作る（`make-frame-command'）.
`C-x 5 b BUFNAME RET'
     別のフレームでバッファBUFNAMEを選択する.  これは,
     `switch-to-buffer-other-frame'を実行する.
`C-x 5 f FILENAME RET'
     ファイルFILENAMEを訪問して, 別のフレームでそのバッファを選択する. 
     これは, `find-file-other-frame'を実行する.  *Note Visiting::.
`C-x 5 d DIRECTORY RET'
     別のフレームでディレクトリDIRECTORYに対するdiredバッファを選択す
     る.  これは, `dired-other-frame'を実行する.  *Note Dired::.
`C-x 5 m'
     別のフレームでメイルメッセージの作成を始める.  これは,
     `mail-other-frame'を実行する.  これは, `C-x m'の他のフレームを使
     う変形版.  *Note Sending Mail::.
`C-x 5 .'
     別のフレームで現在のタグテーブルからタグを探す.  これは,
     `find-tag-other-frame'を実行し, `M-.'の複数フレーム向けの変形版.
     *Note Tags::.
`C-x 5 r FILENAME RET'
     ファイルFILENAMEを読み出し専用で訪問し, 別のフレームでそのバッファ
     を選択する.  これは, `find-file-read-only-other-frame'を実行する.
     *Note Visiting::.

`default-frame-alist'にフレームパラメータを設定することで, 新たに作成
するフレームの見た目を制御できます.  初期フレームだけに影響するパラメー
タを指定するには, 変数`initial-frame-alist'を使います.  詳しくは,
*Note 初期フレームのパラメータ: (elisp-ja)Initial Parameters.。

すべてのEmacsフレームに主要フォントを指定するもっとも簡単な方法は, Xの
リソース（*Note Font X::）を使うことですが, つぎに示すように, `font'パ
ラメータを指定するように`default-frame-alist'を変更してもできます.

     (add-to-list 'default-frame-alist '(font . "10x20"))



File: emacs-ja, Node: Speedbar, Next: Creating Frames, Prev: Mode Line Mouse, Up: Frames

スピードバーフレームの作成と使い方
==================================

Emacsのフレームは, "スピードバー"を持つことができます.  スピードバーは, 
縦長のウィンドウで, 訪問したりタグを探したりするためのスクロール可能な
ファイルメニューとして働きます.  スピードバーを作るには, `M-x
speedbar'と打ちます.  これは, 選択されたフレームに対するスピードバーウィ
ンドウを作ります.  そうすると, スピードバーのファイル名をクリックする
と, 対応するEmacsフレームでそのファイルを訪問できます.  あるいは, タグ
の名前をクリックすると, Emacsフレームでそのタグの箇所へ飛んで行きます.

最初, スピードバーには, カレントディレクトリの直下の内容を1行につき1つ
のファイルで表示します.  各行には, `[+]'か`<+>'の箱があって, それを
`Mouse-2'でクリックするとその項目の内容を『開け』ます.  その行の名前が
ディレクトリならば, それを開くと, そのディレクトリの内容をその行の下に
追加してスピードバーに表示します.  その行が普通のファイルならば, それ
を開くと, そのファイル内のタグ一覧をスピードバーに追加して表示します. 
ファイルが開かれていると, `[+]'は`[-]'に変わります.  ファイルを『閉じ
る』（内容を隠す）ためにその箱をクリックできます.

rmailモード, infoモード, GUDモードを含むいくつかのメジャーモードには, 
選択可能な有用な項目をスピードバーに追加する特別な方法があります.  た
とえば, rmailモードでは, スピードバーにはrmailファイル一覧を表示します. 
カレントメッセージを別のrmailファイルに移すには, 目的のrmailファイルの
`<M>'の箱をクリックするだけです.

スピードバーは1つのEmacsフレームに属し, つねにそのフレームに作用します. 
複数のフレームを使うときには, 一部のフレームやすべてのフレームにスピー
ドバーを作れます.  フレームのスピードバーを作るには, そのフレームで
`M-x speedbar'と打ちます.



File: emacs-ja, Node: Multiple Displays, Next: Special Buffer Frames, Prev: Creating Frames, Up: Frames

複数ディスプレイ
================

1つのEmacsは, 複数のXディスプレイと通信できます.  最初は, Emacsは1つの
ディスプレイだけを使います.  環境変数`DISPLAY'や`--display'オプション
に指定されたものです（*Note Initial Options::）.  他のディスプレイに接
続するには, コマンド`make-frame-on-display'を使います.

`M-x make-frame-on-display RET DISPLAY RET'
     ディスプレイDISPLAY上に新しいフレームを作成する.

1つのXサーバーは複数のスクリーンを扱えます.  1つのサーバーに属する2つ
のスクリーンにフレームを開くとき, Emacsは1つのキーボードを共有している
ことを知っていて, これらのスクリーンから到着するすべてのコマンドを1つ
の入力ストリームとして扱います.

異なるXサーバー上にフレームを開くとき, Emacsはそれぞれのサーバーに対し
て別々の入力ストリームを作ります.  こうすることで, 2つのディスプレイ上
で2人のユーザーが同時に打鍵でき, Emacsはそれらの入力をごっちゃにするこ
とはありません.  各サーバーにはそれ自身が選択しているフレームがありま
す.  特定のXサーバーで入力したコマンドは, そのサーバーが選択しているフ
レームに適用されます.

これらの機能にも関わらず, 異なるディスプレイで同じEmacsジョブを使って
いる人達は, 注意を怠ると, 互いに干渉し合ってしまいます.  たとえば, 誰
かが`C-x C-c'と打つと, その人達が共有している（1つの）Emacsジョブは終
了してしまいます！



File: emacs-ja, Node: Special Buffer Frames, Next: Frame Parameters, Prev: Multiple Displays, Up: Frames

特別なバッファフレーム
======================

ウィンドウが1つのときにはEmacsが普通2つめのウィンドウを作るような特定
のバッファでは, それ専用の特別なフレームに表示することができます.  こ
うするには, 変数`special-display-buffer-names'にバッファ名のリストを設
定します.  そのリストに名前があるどのバッファも, Emacsコマンドが『別の
ウィンドウに』表示したいときには, 特別なフレームを自動的に取得します.

たとえば, つぎのように変数を設定したとすると, 補完一覧, `grep'の出力,
TeXモードのシェルバッファは, それぞれ個別のフレームを取得します.

     (setq special-display-buffer-names
           '("*Completions*" "*grep*" "*tex-shell*"))

これらのフレームとその中のウィンドウは, 別のバッファのために自動的に分
割されたり再利用されることはありません.  手動で変更するまで, そのため
に作成されたバッファを表示し続けます.  特別なバッファを消去すると, そ
のフレームも自動的に削除されます.

より一般的には, 正規表現のリストを`special-display-regexps'に設定でき
ます.  すると, バッファの名前がそれらの正規表現に一致すると, バッファ
は専用のフレームを取得します.  （繰り返すが, これは通常, 別のウィンド
ウに表示するバッファにのみ適用する. ）

変数`special-display-frame-alist'は, このようなフレームに対するフレー
ムパラメータを指定します.  これにはデフォルト値があるので, 特に設定す
る必要はありません.

Lispがわかる人のためにですが, `special-display-buffer-names'や
`special-display-regexps'の要素は, リストでもかまいません.  その場合, 
最初の要素はバッファ名か正規表現です.  リストの残りは, フレームの作成
方法を指定します.  これは, フレームパラメータの値を指定する連想リスト
にすることもできます.  これらの値は, `special-display-frame-alist'に指
定されたパラメータの値より優先されます.  あるいは, リストはつぎのよう
な形式にすることもできます.

     (FUNCTION ARGS...)

ここで, FUNCTIONはシンボルです.  こうすると, FUNCTIONを呼んでフレーム
を作ります.  関数呼び出しの最初の引数はバッファで, 残りの引数はARGSで
す.

似たような機能で, バッファをどの選択されているウィンドウに表示するか指
定できます.  *Note Force Same Window::.  同じウィンドウに表示する機能
は, 特別なフレームに表示する機能に優ります.  したがって, バッファ名を
`special-display-buffer-names'に追加しても何の効果もなかったら, その機
能が同じバッファ名に対しても使われていないか調べてください.



File: emacs-ja, Node: Frame Parameters, Next: Scroll Bars, Prev: Special Buffer Frames, Up: Frames

フレームパラメータの設定
========================

本節では, 選択しているフレームの表示スタイルやウィンドウ管理のふるまい
を変更するコマンドを説明します.

`M-x set-foreground-color RET COLOR RET'
     選択しているフレームの前景色をCOLORと指定する.

`M-x set-background-color RET COLOR RET'
     選択しているフレームの背景色をCOLORと指定する.  これは`modeline'
     フェイスの前景色も変更するので, デフォルトと比較しても反転表示の
     ままになる.

`M-x set-cursor-color RET COLOR RET'
     選択しているフレームのカーソルの表示色をCOLORと指定する.

`M-x set-mouse-color RET COLOR RET'
     マウスカーソルが選択しているフレーム内にあるときのマウスカーソル
     の表示色をCOLORと指定する.

`M-x set-border-color RET COLOR RET'
     選択しているフレームの境界色をCOLORと指定する.

`M-x list-colors-display'
     定義されている表示色の名称とそれがどう見えるか表示する.  このコマ
     ンドは少し遅い.

`M-x auto-raise-mode'
     選択されているフレームをオートレイズするべきかどうか切り替える. 
     オートレイズとは, マウスカーソルがフレームに入るたびに, そのフレー
     ムを手前にもってくること.

     このオートレイズ機能はEmacs自身が実装していることに注意.  ウィン
     ドウマネージャの中にも, オートレイズを実装しているものがある.  X
     のウィンドウマネージャでEmacsフレームのオートレイズを指定している
     ときには, それが動作するはず.  しかし, それはEmacsの制御を超えて
     いるので, それに関しては`auto-raise-mode'は何の影響もない.

`M-x auto-lower-mode'
     選択されているフレームをオートローワするべきかどうか切り替える. 
     オートローワとは, マウスカーソルがフレームから出るたびに, そのフ
     レームをXのウィンドウスタックの底に移すこと.

     コマンド`auto-lower-mode'は, Xのウィンドウマネージャが実装するオー
     トローワには何の影響もない.  それを制御するには, 適切なウィンドウ
     マネージャの機能を使う必要がある.

`M-x set-frame-font RET FONT RET'
     選択されたフレームに対する主要フォントとしてFONTを指定する.  フェ
     イス（*Note Faces::）が別のフォントを使うことを指定しているときを
     除いて, 主要フォントは, フレームに表示するすべてのテキストに対し
     て使われる.  あなたのシステムで使えるフォント一覧を表示する方法に
     ついては, *Note Font X::.

     ポップアップメニューから, フレームの主要フォントを設定することも
     できる.  このメニューを立ち上げるには`S-Mouse-1'を押す.

Xツールキットを使うEmacsの版では, 表示色とフォントを設定する関数はメ
ニューやメニューバーには影響しません.  というのは, メニューやメニュー
バーは, それら自身のウィジェットクラスを使って表示されているからです. 
メニューとメニューバーの見た目を変更するには, Xのリソースを使う必要が
あります（*Note Resources X::）.  表示色に関しては, *Note Colors X::. 
フォントの選択については, *Note Font X::.

フレームパラメータとそのカスタマイズについては, *Note フレームパラメー
タ: (elisp-ja)Frame Parameters.。



File: emacs-ja, Node: Scroll Bars, Next: Menu Bars, Prev: Frame Parameters, Up: Frames

スクロールバー
==============

Xを使っているときには, Emacsは通常, 各Emacsウィンドウの左側に"スクロー
ルバー"（scroll bar）を作ります.  スクロールバーは, ウィンドウの高さに
延びていて, 内側に動く矩形の箱を表示します.  この箱は, 現在表示されて
いるバッファ内の部分を表しています.  スクロールバーの全体の高さは, バッ
ファの全体の長さを表します.

`Mouse-2'（通常, 中ボタン）を使って, スクロールバーの内側の箱を上下に
移動したりドラッグできます.  内側の箱をスクロールバーのいちばん上へ移
動すると, バッファの先頭を見ることができます.  スクロールバーのいちば
ん下に内側の箱を移動すると, バッファの末尾が見えます.

スクロールバーで左や右ボタンを使うと, 制御された増分でスクロールできま
す.  `Mouse-1'（通常, 左ボタン）は, クリックした場所の高さの行をウィン
ドウの最上端の行へ移動します.  `Mouse-3'（通常, 右ボタン）は, ウィンド
ウの最上端の行をクリックした場所の高さの行へ移動します.  同じ位置で繰
り返しクリックすると, 同じ分量のスクロールを繰り返します.

スクロール以外では, スクロールバーで`C-Mouse-2'をクリックすると, ウィ
ンドウを上下に分割できます.  クリックした場所の行で分割されます.

コマンド`M-x scroll-bar-mode'で, スクロールバー（scroll-bar）モードを
オン／オフできます.  引数を指定しなければ, スクロールバーの使用をトグ
ルします.  引数を指定した場合, 引数が正のときだけスクロールバーを使う
ようにします.  このコマンドは, これから作成されるフレームを含めてすべ
てのフレームに作用します.  Xのリソース`verticalScrollBars'を使って, ス
クロールバー（scroll-bar）モードの初期設定を制御できます.  *Note
Resources X::.

選択されているフレームに対してのみスクロールバーをオン／オフするには,
`M-x toggle-scroll-bar'コマンドを使います.



File: emacs-ja, Node: Menu Bars, Next: Faces, Prev: Scroll Bars, Up: Frames

メニューバー
============

`M-x menu-bar-mode'でメニューバーの表示をオン／オフできます.  引数を指
定しないと, このコマンドはマイナモードであるメニューバー（menu-bar）モー
ドをトグルします.  引数を指定した場合, 引数が正ならメニューバー
（menu-bar）モードをオンにし, 引数が正でないならオフにします.  Xのリソー
ス`menuBarLines'を使って, メニューバー（menu-bar）モードの初期設定を制
御できます.  *Note Resources X::.  熟練したユーザーは, メニューバーを
しばしばオフにし, 特に文字端末上ではそうします.  というのは, テキスト
表示に1行余分に使えるからです.

メニューバーでコマンドを起動する方法については, *Note Menu Bar::.



File: emacs-ja, Node: Faces, Next: Font Lock, Prev: Menu Bars, Up: Frames

複数タイプフェイスの利用
========================

XでEmacsを使っているとき, 文字表示に複数のスタイルを設定できます.  制
御できるスタイルは, フォントの種類, 前景色, 背景色, 下線を引くかどうか
です.  MS-DOS用Emacsは, 各フェイスの前景色と背景色を制御して, フェイス
の一部だけを扱えます（*Note MS-DOS::）.

表示スタイルを制御する方法は, 名前付き"フェイス"を定義することです. 
各フェイスでは, フォントの種類, 前景色, 背景色, 下線フラグを指定できま
す.  しかし, これらすべてを指定する必要はありません.  バッファ内のテキ
ストの一部分に対して使用するフェイスを指定することで, そのテキストの見
た目を制御できます.

テキスト中のある文字に対して使う表示スタイルは, いくつかのフェイスを組
み合わせて決定されます.  重ね合わせやテキスト属性で指定されていない表
示スタイルは, フレームそのものから得ます.

整形済みテキストを編集するモードであるエンリッチ（enriched）モードには, 
フェイスを指定するためのコマンドやメニューがあります.  バッファ内のテ
キストに対するフォントの指定方法については, *Note Format Faces::.  前
景色と背景色の指定方法については, *Note Format Colors::.

フェイスの見た目を変更するには, カスタマイズバッファを使います*Note
Face Customization::.  Xのリソースを使って, 特定のフェイスの属性を指定
できます（*Note Resources X::）.

現在定義されているフェイスとその見た目を調べるには, `M-x
list-faces-display'と打ちます.  あるフェイスを違うフレームでは違って見
えるようにできます.  このコマンドは, コマンドを打ったフレーム上での見
た目を表示します.  つぎは, 標準的に定義されているフェイス一覧です.

`default'
     このフェイスは, 他のフェイスを指定していない普通のテキストに使わ
     れる.
`modeline'
     このフェイスはモード行に対して使われる.  デフォルトでは,
     `default'フェイスの反転表示を設定.  *Note Display Vars::.
`highlight'
     このフェイスは, さまざまモードでのテキストの強調表示部分に対して
     使われる.
`region'
     このフェイスは, 選択されているリージョン（暫定マーク
     （transient-mark）モードがオンのとき. 下記参照）の表示に使われる.
`secondary-selection'
     このフェイスは, 二次セレクションの表示に使われる（*Note Secondary
     Selection::）.
`bold'
     このフェイスは, ボールド体（太字体）があるならば, ボールド体を用
     いたデフォルトフォントの変種.
`italic'
     このフェイスは, イタリック体（斜体）があるならば, イタリック体を
     用いたデフォルトフォントの変種.
`bold-italic'
     このフェイスは, ボールドイタリック体（太字斜体）があるならば, ボー
     ルドイタリック体を用いたデフォルトフォントの変種.
`underline'
     このフェイスは, テキストに下線を引く.

暫定マーク（transient-mark）モードがオンのときは, マークが活性ならば, 
リージョンのテキストは強調表示されます.  これには`region'という名前の
フェイスを使います.  このフェイスのスタイルを変更することで, 強調表示
のスタイルを制御できます（*Note Face Customization::）.  暫定マーク
（transient-mark）とマークの活性／不活性について詳しくは, *Note
Transient Mark::.

フェイスを使う簡単な方法の1つは, フォントロック（font-lock）モードを使
うことです.  特定のバッファにつねにローカルであるこのマイナモードは, 
編集するテキストの構文に従ってフェイスを選択します.  このモードは, ほ
とんどの言語のコメントと文字列を認識できます.  いくつかの言語では, そ
れ以外のさまざまな重要な構造も認識して, 適切に強調表示します.  フォン
トロック（font-lock）モードと構文の強調表示について詳しくは, *Note
Font Lock::.

画面上で強調表示されたバッファは, コマンド`ps-print-buffer-with-faces'
を使って印刷できます.  *Note Postscript::.



File: emacs-ja, Node: Font Lock, Next: Support Modes, Prev: Faces, Up: Frames

フォントロックモード
====================

フォントロック（font-lock）モードはマイナモードです.  特定のバッファに
つねにローカルであり, 編集しているテキストの構文に従ってさまざまなフェ
イスを使って強調表示（または『フォント表示化』）します.  このモードは, 
ほとんどの言語のコメントや文字列を認識できます.  いくつかの言語では, 
他のさまざまな重要な構成要素も認識し, 正しく強調表示します.  たとえば, 
定義されている関数名や予約語です.

コマンド`M-x font-lock-mode'は, 引数に従ってフォントロック（font-lock）
モードをオン／オフし, 引数がなければモードをトグルします.  関数
`turn-on-font-lock'は, フォントロック（font-lock）モードを無条件でオン
にします.  このコマンドは, モードフック関数で使うと便利です.  たとえば,
Cのファイルを編集しているときにはいつでもフォントロック（font-lock）モー
ドをオンにするには, つぎのようにします.

     (add-hook 'c-mode-hook 'turn-on-font-lock)

フォントロック（font-lock）モードを扱えるすべての（メジャー）モードで
自動的にフォントロック（font-lock）モードをオンにするには, 関数
`global-font-lock-mode'をつぎのように使います.

     (global-font-lock-mode 1)

フォントロック（font-lock）モードでは, テキストを編集していると, 自動
的に変更した行の強調表示を更新します.  ほとんどの変更は, 後続行の強調
表示には影響しませんが, 時折, 影響することもあります.  ある範囲の行を
強調表示し直すには, コマンド`M-g M-g'を使います
（`font-lock-fontify-block'）.

ある種のメジャーモードでは, `M-g M-g'は, 現在の関数定義全体をフォント
表示化し直します.  （変数`font-lock-mark-block-function'は, 現在の関数
定義の探し方を制御する. ）別のメジャーモードでは, `M-g M-g'は, ポイン
トのまえとあとの16行をフォント表示化し直します.

数引数Nを指定すると, `M-g M-g'は, モードに関係なく, ポイントのまえとあ
とのN行をフォント表示化し直します.

フォントロック（font-lock）モードの利点を十分に活用するには, ボールド
体, イタリック体, ボールドイタリック体のデフォルトフォントを選ぶ必要が
あります.  あるいは, カラーやグレースケールの画面が必要です.

変数`font-lock-maximum-decoration'は, 複数のレベルを提供するモードでの
フォント表示化の好ましいレベルを指定します.  レベル1は最低限のフォント
表示化です.  いくつかのモードでは, もっとも高い3のレベルまであります. 
通常デフォルトは『可能な限り大きい数』です.  すべてのモードに適用する
整数を指定できます.  あるいは, 特定のメジャーモードに対して異なる数を
指定できます.  たとえば, C/C++モードではレベル1を, それ以外ではデフォ
ルトのレベルを指定するには, つぎのようにします.

     (setq font-lock-maximum-decoration
           '((c-mode . 1) (c++-mode . 1)))

フォント表示化は, 大きなバッファに対してはとても遅くなりえますから, 抑
制することもできます.  変数`font-lock-maximum-size'にバッファサイズを
指定すると, その値を越えるバッファについてはフォント表示化を抑制します.

コメントと文字列のフォント表示化（あるいは, 『構文の』フォント表示化）は, 
バッファのテキストの構文解析に頼っています. 
速度向上のために, CモードやLispモードを含むいくつかのモードでは, 
特別な習慣に頼っています. 
最左桁にある開き括弧は, つねに関数定義の開始を表し, 
そのため, つねに文字列やコメントの外側だということです. 
（*Note Defuns::. ）
この習慣に従わないと, フォントロック（font-lock）モードは, 
文字列やコメントの内側にある最左桁の開き括弧のうしろでは, 
違ったフォント表示化をすることもありえます. 

変数`font-lock-beginning-of-syntax-function' （つねにバッファにローカ
ル）は, フォントロック（font-lock）モードが, コメントや文字列の外側で
あることが保証される位置をどのように探すかを指定します.  最左桁の括弧
の習慣を使うモードでは, 変数のデフォルト値は, `beginning-of-defun'です. 
つまり, フォントロック（font-lock）モードは習慣を使うようにということ
です.  この変数に`nil'を設定すると, フォントロック（font-lock）モード
は, もはや習慣に頼りません.  これでまちがった結果を避けられますが, そ
の代償は, 変更したテキストをフォント表示化するには, バッファのテキスト
をバッファの先頭から再走査する必要がある場合もあります.

多くのモードに対するフォントロックの強調表示パターンはすでにありますが, 
フォント表示化するパターンを追加したいこともあるでしょう.  関数
`font-lock-add-keywords'を使って, 特定のモードに対する個人用の強調表示
パターンを追加できます.  たとえば, Cのコメントで単語`FIXME:'を強調表示
するには, つぎのように使います.

     (font-lock-add-keywords
      'c-mode
      '(("\\<\\(FIXME\\):" 1 font-lock-warning-face t)))



File: emacs-ja, Node: Support Modes, Next: Highlight Changes, Prev: Font Lock, Up: Frames

フォントロックのモード
======================

フォントロックには, 大きなバッファに対してフォントロック（font-lock）
モードを高速に動作させるモードがあります.  高速ロック（fast-lock）モー
ドと遅延ロック（lazy-lock）モードです.  これらは, フォントロック
（font-lock）モードの速度を向上するために2つの異なる方法を使います.

* Menu:

* Fast Lock Mode::      Saving font information in files.
* Lazy Lock Mode::      Fontifying only text that is actually displayed.
* Fast or Lazy::        Which support mode is best for you?



File: emacs-ja, Node: Fast Lock Mode, Next: Lazy Lock Mode, Prev: Support Modes, Up: Support Modes

高速ロックモード
----------------

大きなファイルを訪問したバッファに対してフォントロック（font-lock）モー
ドを速くするには, 高速ロック（fast-lock）モードを使えます.  高速ロック
（fast-lock）モードは, 各ファイルに対するフォント情報を別のキャッシュ
ファイル（cache file）に保存します.  ファイルを訪問するたびに, 最初か
らテキストをフォント表示化し直すかわりに, キャッシュファイルからフォン
ト情報を読み直します.

コマンド`M-x fast-lock-mode'は, 引数に従って高速ロック（fast-lock）モー
ドをオン／オフします（引数がないければトグル）.  フォントロック
（font-lock）モードを使うときに, いつでも高速ロック（fast-lock）モード
をオンにするには, つぎのようにします.

     (setq font-lock-support-mode 'fast-lock-mode)

小さなバッファに対しては, キャッシュファイルを書く価値がありません. 
それゆえ, 変数`fast-lock-minimum-size'は, フォント情報をキャッシュする
最小のファイルサイズを指定します.

変数`fast-lock-cache-directories'は, 
キャッシュファイルをどこに置くかを指定します. 
その値は, ディレクトリ群のリストです. 
`"."'は, 編集しているファイルと同じディレクトリを表します. 
デフォルト値は, `("." "~/.emacs-flc")'で, 
可能ならば同じディレクトリを使い, 
さもなければディレクトリ`~/.emacs-flc'を使うという意味です.  

変数`fast-lock-save-others'は, あなたが所持していないファイルに対する
キャッシュファイルを高速ロック（fast-lock）モードが保存すべきかどうか
を指定します.  値が`nil'以外ならば保存します（これがデフォルト）.



File: emacs-ja, Node: Lazy Lock Mode, Next: Fast or Lazy, Prev: Fast Lock Mode, Up: Support Modes

遅延ロックモード
----------------

大きなバッファに対してフォントロック（font-lock）モードを速くするには, 
フォント表示化するテキストの量を減らす遅延ロック（lazy-lock）モードを
使えます.  遅延ロック（lazy-lock）モードでは, バッファのフォント表示化
は要求駆動型です.  表示されようとしているバッファの部分だけをフォント
表示化します.  また, 変更部分のフォント表示化は延期され, Emacsがある短
い時間アイドルであったときにのみフォント表示化します.

コマンド`M-x lazy-lock-mode'は, 遅延ロック（lazy-lock）モードを引数に
従ってオン／オフします（引数がなければトグル）.  フォントロック
（font-lock）モードを使うときに, いつでも遅延ロック（lazy-lock）モード
をオンにするには, つぎのようにします.

     (setq font-lock-support-mode 'lazy-lock-mode)

小さなバッファに対してバッファのフォント表示化を避ける価値はありません. 
ですから, 変数`lazy-lock-minimum-size'は, 要求駆動型でバッファのフォン
ト表示化を行う最小のバッファサイズを指定します.  これより小さなバッファ
は, 普通のフォントロック（font-lock）モードのように一度にフォント表示
化します.

バッファを変更したとき, 遅延ロック（lazy-lock）モードは変更したテキス
トのフォント表示化を延期します.  変数`lazy-lock-defer-time'は, 変更部
分のフォント表示化を始めるまでにEmacsがアイドルであるべき秒数です.  こ
の値が0ならは, 普通のフォントロック（font-lock）モードと同じように, 変
更はすぐにフォント表示化されます.

遅延ロック（lazy-lock）モードは, 通常, 新たに見えてくるバッファ部分が
初めて表示されるまえにその部分をフォント表示化します.  しかし,
`lazy-lock-defer-on-scrolling'の値が`nil'以外ならば, 新たに見えてくる
テキストは, Emacsが`lazy-lock-defer-time'秒だけアイドルしたときにのみ
フォント表示化されます.

CやEmacs Lispモードを含むいくつかのモードでは, ある1行の内容を変更する
と後続行の文脈が変わり, そのため, 後続行をどうフォント表示化するかも変
わります.  通常は, 後続行を再フォント表示化するために`M-g M-g'を打つ必
要があります.  しかし, 変数`lazy-lock-defer-contextually'に`nil'以外を
設定していると, 遅延ロック（lazy-lock）モードでは,
`lazy-lock-defer-time'秒後にこれを自動的に行います.

Emacsが長時間アイドルだと, 遅延ロックは, バッファのまだ表示されていな
い部分を, のちの表示に備えてフォント表示化します.  これを"内密のフォン
ト表示化"（stealth fontification）と呼びます.

変数`lazy-lock-stealth-time'は, 内密のフォント表示化を開始するまでに,
Emacsが何秒間アイドルであるべきかを指定します.  値が`nil'だと, 内密の
フォント表示化をしません.  変数`lazy-lock-stealth-lines'と
`lazy-lock-stealth-verbose'は, 内密のフォント表示化の粒度と冗長性を指
定します.



File: emacs-ja, Node: Fast or Lazy, Next: Highlight Changes, Prev: Lazy Lock Mode, Up: Support Modes

高速ロックか遅延ロックか？
--------------------------

フォントロックで使えるモードの1つを選択する目安となる簡単な指針をあげ
ます.

   * 高速ロック（fast-lock）モードは, ファイルの訪問とバッファの削除
     （と関連する事象）の最中に作業する.  それゆえ, バッファの編集やウィ
     ンドウのスクロールは, 普通のフォントロック（font-lock）モードより
     速くも遅くもない.

   * 高速ロック（fast-lock）モードのキャッシュファイルの読み込みは, 遅
     延ロック（lazy-lock）モードがウィンドウをフォント表示化するより遅
     い.  よって, 高速ロック（fast-lock）モードは, 遅延ロック
     （lazy-lock）モードよりファイルの訪問が遅い.

   * 遅延ロック（lazy-lock）モードは, ウィンドウをスクロールする最中に, 
     画面上に現れるテキストをフォント表示化する.  よって, スクロールは, 
     通常のフォントロック（font-lock）モードより遅い.

   * 遅延ロック（lazy-lock）モードは, バッファを編集中はフォント表示化
     しない（変更部分のフォント表示化を延期する）.  よって, 編集は, 通
     常のフォントロック（font-lock）モードより速い.

   * 高速ロック（fast-lock）モードは, 版管理の下に置かれたファイルでは
     だまされることがある.  よって, そのファイルに対するキャッシュファ
     イルが存在していても, バッファのフォント表示化が起こりえる.

   * 高速ロック（fast-lock）モードは, ファイルを訪問しているバッファで
     のみ動作する.  遅延ロック（lazy-lock）モードは, どのバッファでも
     動作する.

   * 高速ロック（fast-lock）モードは, キャッシュファイルを生成する. 
     遅延ロック（lazy-lock）モードは, 生成しない.

変数`font-lock-support-mode'は, これらのどちらのモードを使うかを指定し
ます.  たとえば, C/C++モードでは高速ロック（fast-lock）モードを使い, 
それ以外のモードでは遅延ロック（lazy-lock）モードを使うように指定する
には, 変数をつぎのように設定します.

     (setq font-lock-support-mode
           '((c-mode . fast-lock-mode) (c++-mode . fast-lock-mode)
             (t . lazy-lock-mode)))



File: emacs-ja, Node: Highlight Changes, Next: Misc X, Prev: Support Modes, Up: Frames

変更部分強調表示モード
======================

バッファ内の最近に変更された部分を示すためにフェイス（典型的には表示色）
を用いるマイナモードをオンにするには, `M-x highlight-changes-mode'を使
います.



File: emacs-ja, Node: Misc X, Next: Non-Window Terminals, Prev: Highlight Changes, Up: Frames

その他のXウィンドウシステムでの機能
===================================

つぎのコマンドは, フレームを作成したり削除したり操作したりします.

`C-z'
     選択されているEmacsフレームをアイコン化する
     （`iconify-or-deiconify-frame'）.  Emacsを休止するという`C-z'の通
     常の意味は, ウィンドウシステムでは有用ではない.  そのため, 別のバ
     インドになっている.

     Emacsフレームのアイコンでこのコマンドを打つと, アイコンをフレーム
     に開く.

`C-x 5 0'
     選択されているフレームを削除する（`delete-frame'）.  フレームがたっ
     た1つの場合には, このコマンドは許されない.

`C-x 5 o'
     別のフレームを選択し, それをいちばん手前にもってきて, そのフレー
     ムが選択されるようにマウスを飛び込ませる.  このコマンドを繰り返す
     と, 端末上のすべてのフレームを巡回する.



File: emacs-ja, Node: Non-Window Terminals, Next: International, Prev: Misc X, Up: Frames

非ウィンドウ端末
================

Emacsが扱えるウィンドウシステムを使えない端末では, 一度に1つのフレーム
しか表示できません.  しかし, 複数のEmacsフレームを作って, それらのフレー
ム間を切り替えられます.  このような端末でのフレームの切り替えは, 異な
るウィンドウ構成の端末での切り替えとたいへんよく似ています.

新しいフレームを作りそれに切り替えるには, `C-x 5 2'を使います.  既存の
フレーム間を巡回するには, `C-x 5 o'を使います.  カレントフレームを削除
するには, `C-x 5 0'を使います.

各フレームにはそれを区別する番号があります.  一度には1つのフレームだけ
しか表示できない端末では, 選択されているフレームの番号Nが, モード行の
先頭近くに`FN'という形式で現れます.

`FN'は, 実際にはフレームの名前です.  望むなら別の名前を指定でき, その
名前でフレームを選択できます.  選択されたフレームに新しい名前を指定す
るには, コマンド`M-x set-frame-name RET NAME RET'を使います.  その名前
でフレームを選択するには, `M-x select-frame-by-name RET NAME RET'を使
います.  指定した名前は, フレームを選択するとモード行に表示されます.



File: emacs-ja, Node: International, Next: Major Modes, Prev: Frames, Up: Top

国際化文字集合の使い方
**********************

Emacsでは広範囲の国際化文字集合を使えます.  ラテンアルファベットの変種
であるヨーロッパの言語はもちろん, 中国語, デバナーガリー（ヒンディー語
とマラッタ語）, エチオピア語, ギリシア語, IPA（International Phonetic
Alphabet, 万国表音文字）, 日本語, 韓国語, ラオ語, ロシア語, タイ語, チ
ベット語, ベトナム語の文字を含んでいます.  これらの機能は, MULE
（『MULti-lingual Enhancement to GNU Emacs』）として知られるEmacsの修
正版から併合しました.

* Menu:

* International Intro::     Basic concepts of multibyte characters.
* Enabling Multibyte::      Controlling whether to use multibyte characters.
* Language Environments::   Setting things up for the language you use.
* Input Methods::           Entering text characters not on your keyboard.
* Select Input Method::     Specifying your choice of input methods.
* Multibyte Conversion::    How single-byte characters convert to multibyte.
* Coding Systems::          Character set conversion when you read and
                              write files, and so on.
* Recognize Coding::        How Emacs figures out which conversion to use.
* Specify Coding::          Various ways to choose which conversion to use.
* Fontsets::                Fontsets are collections of fonts
                              that cover the whole spectrum of characters.
* Defining Fontsets::       Defining a new fontset.
* Single-Byte European Support::
                            You can pick one European character set
                            to use without multibyte characters.



File: emacs-ja, Node: International Intro, Next: Enabling Multibyte, Prev: International, Up: International

国際化文字集合の紹介
====================

これらの文字のユーザーは, ファイルに格納するために, たくさんの標準的な
コーディングシステムを確立してきました.  Emacsは内部的には単一のマルチ
バイト文字符号化を使用しているので, 1つのバッファや1つの文字列の中に, 
これらのすべての文字を混ぜ合わせることができます.  この符号化では, 非
ASCII文字を0200から0377の範囲のバイトの並びとして表現します.  Emacsは, 
ファイルを読み書きするとき, サブプロセスとデータを交換するとき, （場合
によっては）`C-q'コマンドを使うときに, マルチバイト文字符号化と他のさ
まざまなコーディングシステムのあいだで変換します（*Note Multibyte
Conversion::）.

コマンド`C-h h'（`view-hello-file'）は, 多くの言語で『hello』と書いた
ファイル`etc/HELLO'を表示します.  これは, さまざまな字体を例示します.

これらの文字集合を使っている国々であっても, 一般にキーボードには, それ
らすべての文字に対するキーはありません.  ですから, Emacsではさまざまな
"入力方式"（input methods） (1) (*Note International
Intro-Footnotes::)を使って, 便利に文字を打ち込めるようにします.  典型
的には, 1つの字体や1つの言語について1つの入力方式があります.

プレフィックスキー`C-x RET'は, マルチバイト文字, コーディングシステム, 
入力方式に関係するコマンドに使います.


File: emacs-ja  Node: International Intro-Footnotes, Up: International Intro

(1) 【訳注】GNU Emacsをインストールする時点で, 対応する版のLEIM
（Library of Emacs Input Method）のソースをGNU Emacsのソースディレクト
リに展開しておくと, 自動的にインストールされる.



File: emacs-ja, Node: Enabling Multibyte, Next: Language Environments, Prev: International Intro, Up: International

マルチバイト文字を使用可能にする
================================

Emacs全体やバッファごとにマルチバイト文字の使用可／使用不可を設定でき
ます.  バッファでマルチバイト文字を使用不可にすると, そのバッファ内の
各バイトは1つの文字を表します.  たとえコードが0200から0377のあいだであっ
てもそうです.  ヨーロッパの文字集合であるISO Latin-1とISO Latin-2を扱
う古い機能は, Emacs 19で動作していたように動き, 他のISO 8859文字集合に
対しても動作します.

しかし, ISO Latinを使うために, マルチバイト文字を使用不可にする必要は
ありません.  Emacsのマルチバイト文字集合にはこれらの文字集合のすべての
文字が含まれ, EmacsはこれらのISOコードと相互に自動的に変換できます.

特定のファイルをユニバイト表現で編集するには, `find-file-literally'を
使ってファイルを訪問します.  *Note Visiting::.  マルチバイト表現のバッ
ファを同じ文字の1バイト表現に変換するには, もっとも簡単な方法は, 内容
をファイルに保存してから, バッファを削除し, `find-file-literally'でそ
のファイルを訪問し直します.  `C-x RET c'
（`universal-coding-system-argument'）を使って, ファイルを探したり保存
するときのコーディングシステムとして`raw-text'を指定することもできます.
*Note Specify Coding::.  `raw-text'としてファイルを探しても,
`find-file-literally'のようには, 書式変換, 圧縮の展開, モードの自動選
択を禁止しません.

デフォルトでマルチバイト文字を使用不可にするには, `--unibyte'オプショ
ン（*Note Initial Options::）を指定してEmacsを始めるか, あるいは, 環境
変数`EMACS_UNIBYTE'を設定します.  `--unibyte'と同等な効果を得るには,
`enable-multibyte-characters'をカスタマイズするか, これと等価に, 初期
化ファイル内で, 変数`default-enable-multibyte-characters'を直接設定し
ます.

環境変数の値, `/etc/passwd'の内容などの非ASCII 8ビット文字からの初期化
中にはマルチバイト文字列は作られません.  しかし, `--unibyte'を指定した
としても, 一般のLispファイルのように, 初期化ファイルは, 通常, マルチバ
イトとして読み込みます.  それらに含まれる非ASCII文字からマルチバイト文
字列が生成されるのを防ぐには, 1行目の注釈に`-*-unibyte: t;-*-'を入れて
おきます.  gnusなどのパッケージの初期化ファイルでも同じことをします.

モード行には, カレントバッファでマルチバイト文字が使用可かどうか表示さ
れます.  使用可ならば, モード行の先頭付近のコロンのまえに2文字か数文字
（ほとんどの場合ダッシュ2個）があります.  マルチバイト文字が使用不可な
らば, コロンのまえにはダッシュが1個だけです.



File: emacs-ja, Node: Language Environments, Next: Input Methods, Prev: Enabling Multibyte, Up: International

言語環境
========

マルチバイト文字が使用可のときはいつでも, すべての扱える文字集合を
Emacsバッファの中で使えます.  ある言語の文字を表示するために, Emacsバッ
ファでその言語を選択する必要はありません.  しかし, さまざまなデフォル
トを設定するために"言語環境"を選択しておくことは重要です.  言語環境は, 
言語の選択というより, （多かれ少なかれ）実際には好みの文字を表します.

言語環境は, テキストを読み込むときにどのコーディングシステムを認識する
かを制御します（*Note Recognize Coding::）.  言語環境は, ファイル, 到
着メイル, ニュース, Emacsへ読み込むその他のテキストに適用されます.  言
語環境は, ファイルを作成したときに使うデフォルトのコーディングシステム
を指定することもあります.  各言語環境は, デフォルトの入力方式も指定し
ます.

言語環境を選択するには, コマンド`M-x set-language-environment'を使いま
す.  このコマンドを使ったときにどのバッファがカレントバッファであるか
は関係ありません.  というのは, その効力は, そのEmacsセッションに全体に
適用されるからです.  以下の言語環境を使えます.

     Chinese-BIG5, Chinese-CNS, Chinese-GB, Cyrillic-Alternativnyj,
     Cyrillic-ISO, Cyrillic-KOI8, Devanagari, English, Ethiopic,
     Greek, Hebrew, Japanese, Korean, Lao, Latin-1, Latin-2, Latin-3,
     Latin-4, Latin-5, Thai, Tibetan, Vietnamese.

いくつかのオペレーティングシステムでは, ローケル（locale）環境変数を設
定することで言語を指定できます.  Emacsは, このよくある特別な場面を扱い
ます.  文字種を表すローケル名が文字列`8859-N'を含むなら, Emacsは自動的
に対応する言語環境を選択します.

ある言語環境LANG-ENVの効果についての情報を表示するには, コマンド`C-h L
LANG-ENV RET' （`describe-language-environment'）を使います.  このコマ
ンドは, その言語環境がどの言語に役立つのか, その言語で使われる文字集合, 
コーディングシステム, 入力方式の一覧を表示します.  また, その言語環境
で使われる文字を例示する例文も表示します.  デフォルトでは, このコマン
ドは選択されている言語環境を記述します.

どの言語環境もノーマルフック`set-language-environment-hook'でカスタマ
イズできます.  コマンド`set-language-environment'は, 新しい言語環境を
設定したあとでこのフックを実行します.  フック関数では, 変数
`current-language-environment'を検査すれば, 言語環境を知ることができま
す.

`set-language-environment'は, 新しい言語環境を設定し始めるまえに, まず
フック`exit-language-environment-hook'を実行します.  このフックは, 
（直前の言語環境を設定した）`set-language-environment'で施したカスタマ
イズをもとに戻すのに便利です.  たとえば,
`set-language-environment-hook'を使って設定した特定の言語環境で特別な
キーバインディングを定義したときには, それをそのキーのもとのバインディ
ングに戻すために`exit-language-environment-hook'を設定するべきです.



File: emacs-ja, Node: Input Methods, Next: Select Input Method, Prev: Language Environments, Up: International

入力方式
========

"入力方式"（input method）は, 対話的に入力するために特別に設計された文
字変換の一種です.  Emacsでは, 典型的には, 各言語向けに専用の入力方式が
あります.  ときには, 同じ文字を使ういくつかの言語で入力方式を共有しま
す.  複数の入力方式を使う言語も少しはあります.

入力方式のもっとも単純なものは, ASCII文字を別のアルファベットに対応さ
せることで動作します.  ギリシア語とロシア語の入力方式はこのように動作
します.

より強力な方法は合成で, 文字の列を1つの文字に変換します.  多くのヨーロッ
パの入力方式は, 文字のうしろにアクセント文字が続く列（あるいはその逆順）
から, 1つの非ASCII文字を生成する合成を使います.  たとえば, いくつかの
入力方式では, 文字の列`a''を1つのアクセント付き文字に変換します.  これ
らの入力方式には, その方式に固有の特別なコマンドはありません.  印字文
字の列を合成するだけです.

音節文字用の入力方式では, 典型的には, 対応付けたあとで合成します.  タ
イ語と韓国語の入力方式は, この方法で動作します.  まず, 文字を音声記号
に対応付けます.  そして, 1つの音節全体を構成するそれらの列を1つの音節
記号に対応付けます.

中国語や日本語では, より複雑な方法が必要です.  中国語の入力方式では, 
まず, 中国語の単語の発音表記を入力する（とりわけ入力方式`chinese-py'）
か, 1文字の各部分部分の列（とりわけ入力方式`chinese-4corner'や
`chinese-sw'）を入力します.  1つの発音表記は, 普通, 多くの異なる中国語
の文字に対応しているので, 特別なEmacsコマンドを使って候補群から1つを選
ぶ必要があります.  `C-f', `C-b', `C-n', `C-p'と数字キーは, この状況で
候補を選ぶために使われる特別な定義になっています.  TABは, すべての候補
をバッファに表示します.

日本語の入力方式 (1) (*Note Input Methods-Footnotes::) では, まず, 発
音表記を使って1つの単語全体を入力します.  そして, 単語がバッファに入っ
たあとで, Emacsは大きな辞書を使って1つ以上の文字へ変換します.  1つの発
音表記は, たくさんの異なる日本語の単語に対応しているので, その中から選
ぶ必要があります.  候補を巡回するには, `C-n'や`C-p'を使います.


ときには, 入力方式での処理を切り離したほうが便利なことがあります.  そ
うすれば, 入力した文字は後続の入力文字と結合されません.  たとえば, 入
力方式`latin-1-postfix'では, キー列`e ''は結合されてアクセント付き`e'
になります.  これらを別々の文字として入力したいときはどうするのでしょ
う？

1つの方法は, アクセントを2回打つことです.  これは, アルファベットとア
クセントを別々に入力する特別な機能です.  たとえば, `e ' ''は, 2つの文
字`e''になります.  別の方法は, `e'のあとに結合されない別の文字を打って
から, すぐにそれを消すことです.  たとえば, `e'と`''を入力するには, `e
e DEL''と打ちます.

別の方法はより一般的ですが, 打つのは簡単ではありません.  2つの文字のあ
いだで`C-\ C-\'を打って, 結合を止めます.  これは, コマンド`C-\' 
（`toggle-input-method'）を2回使っています.  *Note Select Input
Method::.

`C-\ C-\'は, インクリメンタルサーチの中では特に便利です.  というのは, 
結合する文字を待つことを止めて, すでに入力したものを探索し始めるからで
す.

 変数`input-method-highlight-flag'と`input-method-verbose-flag'は, 入
力方式に何が進行中かをどのように表示させるかを制御します.
`input-method-highlight-flag'が`nil'以外ならば, バッファでは（入力途中
の）部分列を強調表示します.  `input-method-verbose-flag'が`nil'以外な
らば, （ミニバッファの中でなければ）つぎに打鍵できる文字の一覧をエコー
領域に表示します.


File: emacs-ja  Node: Input Methods-Footnotes, Up: Input Methods

(1) 【訳注】言語環境が`Japanese'のときにデフォルトで使用される
LEIMに含まれているもの.  「ローマ字→ひらがな→漢字」と変換するが, あ
まい使いやすくはない.  WNN, かんな, SKKなどを使うには, Emacsの配布とは
別の非公式パッチを自前で当てる必要がある.  ただし, これらを用いた場合, 
日本語を入力できない場面もあることを承知しておく必要がある.



File: emacs-ja, Node: Select Input Method, Next: Multibyte Conversion, Prev: Input Methods, Up: International

入力方式の選択
==============

`C-\'
     選択されている入力方式をオン／オフする.

`C-x RET C-\ METHOD RET'
     カレントバッファに対して新しい入力方式を選択する.

`C-h I METHOD RET'
`C-h C-\ METHOD RET'
     入力方式METHODについて説明する（`describe-input-method'）.  デフォ
     ルトでは, （あれば）現在の入力方式を説明する.  この説明で, ある入
     力方式の使い方の詳細がわかるはず.

`M-x list-input-methods'
     使用可能なすべての入力方式の一覧を表示する.

カレントバッファに対する入力方式を選ぶには, `C-x RET C-\'
（`set-input-method'）を使います.  このコマンドは, ミニバッファで入力
方式名を読みます.  その名前は, 通常, 一緒に使うことを意図された言語環
境で始まります.  変数`current-input-method'は, どの入力方式を選択した
かを記録します.
  
入力方式は, 非ASCII文字を入力するために, さまざまなASCII文字の列を使い
ます.  ときには, 一時的に入力方式をオフにできると便利なこともあります. 
そうするには, `C-\'（`toggle-input-method'）と打ちます.  入力方式をふ
たたびオンにするには, `C-\'をもう一度打ちます.

`C-\'を打ったときに, 入力方式をまだ選択していないと, 入力方式を指定す
るように聞いてきます.  これは, 入力方式を指定するために`C-x RET C-\'を
使うのと同じ効果があります.

言語環境を選択すると, さまざまなバッファで使うデフォルトの入力方式を指
定します.  デフォルトの入力方式を指定してあれば, `C-\'と打てばカレント
バッファでそれを選択できます.  変数`default-input-method'は, デフォル
トの入力方式を指定します（`nil'は入力方式なしの意味）.

アルファベット文字に対するいくつかの入力方式は, その文字向けに一般的に
使用されるさまざまなキーボード配列をエミュレートするようにキーボードを
（実質的に）マッピングし直すことで動作します.  マッピングし直す方法は, 
あなたの実際のキーボード配列に依存します.  使っているキーボード配列を
指定するには, コマンド`M-x quail-set-keyboard-layout'を使います.

使用可能なすべての入力方式の一覧を表示するには, `M-x
list-input-methods'と打ちます.  この一覧には, モード行に表示される入力
方式を表す文字列を含めて, 各入力方式についての情報が示されます.



File: emacs-ja, Node: Multibyte Conversion, Next: Coding Systems, Prev: Select Input Method, Up: International

ユニバイトとマルチバイトの非ASCII文字
=====================================

マルチバイト文字が使用可のときには, 文字コード0240（8進数）から0377（8
進数）の文字は, 実際にそのままではバッファ内に存在しません.  正しい非
ASCII印字文字は, 0400から始まるコードになります.

0240から0377の不正な範囲の自己挿入文字を打った場合, Emacsは, ISO
Latin-N文字集合の1つを使おうとしていると仮定して, Latin-Nの文字を表す
Emacsのコードに変換します.  言語環境の選択を介して, *どの*ISO Latin文
字集合を使うのか指定できます（*Note Language Environments::）.  何も選
んでないと, デフォルトはLatin-1です.

`C-q'でこの範囲の8進コードを入力すると, 同じことが起こります.



File: emacs-ja, Node: Coding Systems, Next: Recognize Coding, Prev: Multibyte Conversion, Up: International

コーディングシステム
====================

さまざまな言語を使うユーザーは, それらを表現するための標準的なコーディ
ングシステムを数多く確立してきました.  Emacsはこれらのコーディングシス
テムを内部的には使用しません.  そのかわり, データを読むときには, さま
ざまなコーディングシステムからEmacs独自のコーディングシステムに変換し, 
データを書くときには, 内部コーディングシステムから他のコーディングシス
テムに変換します.  ファイルの読み書き, 端末とのやりとり, サブプロセス
とのデータ交換において, 変換できます.

Emacsは各コーディングシステムに名前を付けています.  多くのコーディング
システムは, 1つの言語で使用されるので, コーディングシステムの名前は, 
言語の名前で始まります.  いくつかのコーディングシステムは, いくつもの
言語で使用されます.  その場合, コーディングシステムの名前は, 通常,
`iso'で始まります.  印字文字をまったく変換しない特別なコーディングシス
テム, `no-conversion', `raw-text', `emacs-mule'もあります.

非ASCII文字のさまざまな表現形の変換に加えて, コーディングシステムは行
末変換も行います.  Emacsは, ファイル内の行の区切り方として, 3つの異な
る変換を扱えます.  つまり, 改行, 復帰改行, 復帰です.

`C-h C CODING RET'
     コーディングシステムCODINGを説明する.

`C-h C RET'
     現在使用しているコーディングシステムを説明する.

`M-x list-coding-systems'
     使用可能なすべてのコーディングシステムの一覧を表示する.

コマンド`C-h C'（`describe-coding-system'）は, 特定のコーディングシス
テムについての情報を表示します.  引数にコーディングシステム名を指定で
きます.  あるいは, 引数が空のときには, カレントバッファに対するものと
デフォルトの両方について, さまざまな目的のために選択されている現在のコー
ディングシステムと, コーディングシステムを認識するための優先順位表を説
明します.  （*Note Recognize Coding::）.

利用可能なすべてのコーディングシステムの一覧を表示するには, `M-x
list-coding-systems'と打ちます.  モード行に表示される文字を含めて, 各
コーディングシステムについての情報の一覧を表示します（*Note Mode
Line::）.

いかなる種類の変換も行わない`no-conversion'を除いて, この一覧に現れる
各コーディングシステムは印字文字をどのように変換する／しないを指定しま
す.  しかし, 行末変換は, 各ファイルの内容に基づいて決定されます.  たと
えば, ファイルが行区切りに復帰改行を使用しているように思われるときには, 
その行末変換を使います.

一覧の各コーディングシステムには, どのように行末変換するかを正確に指定
する3つの変種があります.

`...-unix'
     行末変換を行わない.  ファイルでは, 行区切りに改行を使用していると
     仮定する.  （これは, UNIXとGNUシステムで普通に使用される変換. ）

`...-dos'
     ファイルでは, 行区切りに復帰改行を使用していると仮定し, 適当な変
     換を行う.  （これは, Microsoftシステムで普通に使用される変換. (1)
     (*Note Coding Systems-Footnotes::)）

`...-mac'
     ファイルでは, 行区切りに復帰を使用していると仮定し, 適当な変換を
     行う.  （これは, Machintoshシステムで普通に使用される変換. ）

これらのコーディングシステムの変種は, 完全に予想できるので
`list-coding-systems'の表示からは簡潔にするために除かれています.  たと
えば, コーディングシステム`iso-latin-1'には, `iso-latin-1-unix',
`iso-latin-1-dos', `iso-latin-1-mac' の変種があります.

コーディングシステム`raw-text'は, 主にASCIIテキストのファイルに適して
いますが, ファイルには, 非ASCII文字の符号を意味しない127を越えるバイト
値が含まれるかもしれません.  `raw-text'では, Emacsは, それらのバイトが
適切に解釈されるように値を変更しないでコピーし, カレントバッファの
`enable-multibyte-characters'に`nil'を設定します.  `raw-text'は, 出会っ
たデータに基づく普通の方法で行末変換を処理し, 使用する行末変換を指定す
る3つの変種を持ちます.

対照的に, コーディングシステム`no-conversion'は, 非ASCIIバイト値と行末
に対して, いかなる文字コード変換も指定しません.  これは, バイナリファ
イル, tarファイル, そのまま処理する必要があるその他のファイルを読み書
きするのに便利です.  これも, `enable-multibyte-characters'に`nil'を設
定します.

いかなる種類の変換もしないでファイルを編集するもっとも簡単な方法は,
`M-x find-file-literally'コマンドを使うことです.  このコマンドは,
`no-conversion'を使い, あなたがファイルを見るまえにファイルの内容を変
換するかもしれないEmacsのその他の機能を抑制します.  *Note Visiting::.

コーディングシステム`emacs-mule'は, Emacs内部の符号化のままで格納され
た非ASCII文字を含むファイルであることを意味します.  これは, 出会ったデー
タに基づいて行末変換を扱い, 行末変換の種類を指定する通常の3つの変種を
持ちます.


File: emacs-ja  Node: Coding Systems-Footnotes, Up: Coding Systems

(1) MIMEの「text/*」の本体や, 他のネットワーク転送の場面でも指定
される.  Emacsが直接には扱えないSGMLの参照構文である
record-start/record-end書式とは異なる.



File: emacs-ja, Node: Recognize Coding, Next: Specify Coding, Prev: Coding Systems, Up: International

コーディングシステムの認識
==========================

一度自分の好みを指定しておけば, ほとんどの場合, Emacsは, 与えられたファ
イルに対してどのコーディングシステムを使うか認識できます.

いくつかのコーディングシステムは, データ内にどのようなバイト列が現れた
かで, 認識したり区別できます.  しかし, 区別できないコーディングシステ
ムやその可能性もないコーディングシステムもあります.  たとえば, Latin-1
とLatin-2を区別する方法はありません.  これらは同じバイト値を異なる意味
で使用しています.

Emacsは, コーディングシステムの優先順位表を用いてこの事態を処理します. 
使用するコーディングシステムを指定しなければ, Emacsはファイルを読むと
きはいつでも, 優先順位のもっとも高いものから始めて順に下りながら, デー
タに合うコーディングシステムをみつけるまで各コーディングシステムに対し
てデータを検査します.  そして, ファイルはそのコーディングシステムで表
現されていると仮定して, ファイルの内容を変換します.

コーディングシステムの優先順位表は, 選択されている言語環境に依存します
（*Note Language Environments::）.  たとえば, フランス語を使うのなら, 
たぶん, EmacsにはLatin-2よりLatin-1を選んでほしいでしょう.  チェコ語を
使うなら, たぶん, Latin-2のほうがよいでしょう.  これが, 言語環境を指定
する理由の1つです.

しかし, コマンド`M-x prefer-coding-system'を使って, 優先順位表の詳細を
変更できます.  このコマンドはミニバッファからコーディングシステムの名
前を読み, それを優先順位表の先頭に追加して, 他のすべてのものより優先す
るようにします.  このコマンドを数回使うと, 使用するごとに優先順位表の
先頭に1つの要素が追加されます.

`iso-8859-1-dos'のような行末変換を指定したコーディングシステムを使うと,
`iso-8859-1'を優先して認識し, その場合にはDOSの行末変換を使うことを
Emacsに指示することになります.

ときには, ファイルに対して使用するコーディングシステムをファイル名が示
していることがあります.  変数`file-coding-system-alist'は, この対応関
係を指定します.  このリストに要素を追加する特別な関数
`modify-coding-system-alist'があります.  たとえば, すべての`.txt'の読
み書きに, コーディングシステム`china-iso-8bit'を使用したいなら, つぎの
Lisp式を実行します.

     (modify-coding-system-alist 'file "\\.txt\\'" 'china-iso-8bit)

始めの引数は`file', 第2引数はこれを適用するファイルを決定する正規表現, 
第3引数はこれらのファイルに対して使用するコーディングシステムです.

Emacsは, ファイルの内容に基づいて, 使用する行末変換の種類を認識します. 
復帰のみ, あるいは, 復帰改行の列のみであれば, 対応する行末変換を選択し
ます.  変数`inhibit-eol-conversion'に`nil'以外を設定すると, 行末変換の
自動的な使用を禁止できます.

ファイルの先頭の`-*-...-*-'や, ファイルの最後のローカル変数リストを使っ
て, 個々のファイルに対してコーディングシステムを指定できます（*Note
File Variables::）.  これを行うには, `coding'という名前の『変数』に値
を定義します.  Emacsには, 変数`coding'は実際にはありません.  変数を設
定するかわりに, ファイルに対して指定されたコーディングシステムを使いま
す.  たとえば, `-*-mode: C; coding: latin-1;-*-'は, Cモードを指定する
とともに, Latin-1のコーディングシステムの使用を指定します.  ファイルで
コーディングシステムを明示的に指定した場合, それは
`file-coding-system-alist'に優先します.

変数`auto-coding-alist'は, 特定のパターンのファイル名に対してコーディ
ングシステムを指定するもっとも強い方法です.  この変数は, ファイル自身
の`-*-coding:-*-'にさえも優先します.  Emacsはtarファイルやアーカイブファ
イルに対してこの機能を使います.  アーカイブ内のファイルの中にある
`-*-coding:-*-'で混乱して, ファイル全体にコーディングシステムを適用し
てしまうことを防ぐのです.

Emacsがバッファに対するコーディングシステムを一度選択すると, そのコー
ディングシステムを`buffer-file-coding-system'に入れておき, このバッファ
からファイルに書く操作では, デフォルトでこのコーディングシステムを使い
ます.  これには, コマンド`save-buffer'や`write-region'も含まれます. 
異なるコーディングシステムを用いてこのバッファからファイルに書きたいと
きには, `set-buffer-file-coding-system'を使って, そのバッファに対して
異なるコーディングシステムを指定します（*Note Specify Coding::）.

メイル（mail）モード（*Note Sending Mail::）でメッセージを送るとき,
Emacsには, メッセージテキストの符号化に使うコーディングシステムを決定
する異なる方法が4つあります.  バッファの`buffer-file-coding-system'が
`nil'以外ならば, その値を試します.  さもなければ,
`sendmail-coding-system'の値が`nil'以外ならば, その値を使います.  3つ
めの方法は, 新しいファイルに対するデフォルトのコーディングシステムが
`nil'以外ならば, それを使います.  この値は, 言語環境の選択で制御されま
す.  これらの3つの値がすべて`nil'ならば, Emacsは, Latin-1のコーディン
グシステムを使用して送出メイルを符号化します.

rmailで新しいメイルを受けとったとき, 各メッセージが別々のファイルであ
るかのように, 各メッセージは自動的にそのメイルが書かれたコーディングシ
ステムで変換されます.  これには, 指定したコーディングシステムの優先順
位表を使います.  MIMEメッセージが文字集合を指定するときには,
`rmail-decode-mime-charset'が`nil'でない限り, rmailはその指定に従いま
す.

rmailファイル自身を読んだり保存したりするときには, Emacsは, 変数
`rmail-file-coding-system'で指定されたコーディングシステムを使います. 
そのデフォルト値は, `nil'です.  rmailファイルは変換しないという意味で
す（rmailファイルは, Emacsの内部文字コードで読み書きされる. ）



File: emacs-ja, Node: Specify Coding, Next: Fontsets, Prev: Recognize Coding, Up: International

コーディングシステムの指定
==========================

Emacsが自動的に正しいコーディングシステムを選択しない場合には, コーディ
ングシステムを指定するつぎのコマンドを使用できます.

`C-x RET f CODING RET'
     カレントバッファに訪問したファイルにコーディングシステムCODINGを
     使う.

`C-x RET c CODING RET'
     このコマンドの直後に続くコマンドに対してコーディングシステム
     CODINGを指定する.

`C-x RET k CODING RET'
     キーボード入力に対してコーディングシステムCODINGを使用する.

`C-x RET t CODING RET'
     端末出力に対してコーディングシステムCODINGを使用する.

`C-x RET p INPUT-CODING RET OUTPUT-CODING RET'
     カレントバッファでのサブプロセスの入力と出力にコーディングシステ
     ムINPUT-CODINGとOUTPUT-CODINGを使用する.

`C-x RET x CODING RET'
     ウィンドウシステムを介した他のプログラムとのセレクションの交換に
     は, コーディングシステムCODINGを使用する.

`C-x RET X CODING RET'
     ウィンドウシステムで*1つ*のセレクションの交換には, コーディングシ
     ステムCODINGを使用する.

コマンド`C-x RET f'（`set-buffer-file-coding-system'）はカレントバッファ
に対してファイルコーディングシステムを指定します.  いいかえれば, 訪問
したファイルを保存したりふたたび読む込むときに使うコーディングシステム
です.  コーディングシステムはミニバッファを使って指定します.  このコマ
ンドは, すでに訪問したファイルに作用するので, ファイルを保存するときに
しか影響しません.

ファイルに対するコーディングシステムを指定する別の方法は, ファイルを訪
問するときです.  まずコマンド`C-x RET c' 
（`universal-coding-system-argument'）を使います.  このコマンドは, ミ
ニバッファを使ってコーディングシステム名を読みます.  ミニバッファを出
たあと, *直後のコマンド*に対して指定したコーディングシステムが使用され
ます.

ですから, たとえば, その直後のコマンドが`C-x C-f'ならば, そのコーディ
ングシステムを使ってファイルを読みます（そして, ファイルを保存するとき
のためにそのコーディングシステムを記録します）.  あるいは, その直後の
コマンドが`C-x C-w'ならば, そのコーディングシステムを使ってファイルに
書きます.  コーディングシステムを指定することで, 影響される他のファイ
ルコマンドは, `C-x C-i'と`C-x C-v', および, 別のウィンドウを使う`C-x
C-f'の変形です.

`C-x RET c'は, `M-x shell'（*Note Shell::）を含むサブプロセスを開始す
るコマンドにも影響します.

しかしながら, その直後のコマンドがコーディングシステムを使用しないなら,
`C-x RET c'は最終的には何の効果もありません.

ファイルを変換しないで訪問するもっとも簡単な方法は, `M-x
find-file-literally'コマンドです.  *Note Visiting::.

 変数`default-buffer-file-coding-system'は, 新しいファイルを作成すると
きのコーディングシステムの選択を指定します.  この変数は, 新規作成のファ
イルを訪問するとき, あるいは, バッファを作成してそれをファイルに保存す
るときに適用されます.  言語環境を選択すると, 典型的には, 言語環境に対
して最適のデフォルトのコーディングシステムをこの変数に設定します.

コマンド`C-x RET t'（`set-terminal-coding-system'）は端末出力に対する
コーディングシステムを指定します.  端末出力のコーディングシステムを指
定すると, 端末へのすべての文字出力はそのコーディングシステムに翻訳され
ます.

この機能は, 特定の言語や文字集合向けに作られたある種の文字端末には便利
です.  たとえば, ISO Latin 文字集合の1つを扱えるヨーロッパの端末です. 
マルチバイトテキストを使っているときには, Emacsが端末で実際に扱える文
字を知るために, 端末コーディングシステムを指定する必要があります.

Emacsがあなたの端末の正しいコーディングシステムを推測できない限り, デ
フォルトでは, 端末出力はまったく変換しません.

コマンド`C-x RET k'（`set-keyboard-coding-system'）はキーボード入力に
対するコーディングシステムを指定します.  キーボードから入力した文字コー
ドの変換は, 非ASCII図形文字を送出するキーを有する端末には便利です.  た
とえば, いくつかの端末は, ISO Latin-1やその部分集合向けに設計されてい
ます.

デフォルトでは, キーボード入力はまったく変換しません.

コーディングシステムを使用してキーボード入力を変換することと, 入力方式
の使用には似たところがあります.  どちらも, 1つの文字に変換するキーボー
ド入力列を定義しています.  しかしながら, 入力方式は人が対話的に使用す
るのに便利なように設計されていて, 変換される列は典型的にはASCII印字文
字の列です.  コーディングシステムは, 典型的には非図形文字の列を変換し
ます.

コマンド`C-x RET x'（`set-selection-coding-system'）は, 選択されたテキ
ストをウィンドウシステムへ送るとき, および, 他のアプリケーションで作ら
れたセレクションのテキストを受け取るときのコーディングシステムを指定し
ます.  このコマンドは, 再設定しない限り, 以降のすべてのセレクションに
作用します.  コマンド`C-x RET X'（`set-next-selection-coding-system'）
は, Emacsが作る／読むつぎのセレクションのコーディングシステムを指定し
ます.

コマンド`C-x RET p'（`set-buffer-process-coding-system'）は, サブプロ
セスの入出力に対するコーディングシステムを指定します.  このコマンドは
カレントバッファに作用します.  通常, 各サブプロセスはそれ自身のバッファ
を持ちます.  ですから, 各サブプロセスの入出力の変換を指定するには, 対
応するバッファでこのコマンドを使用します.

デフォルトでは, プロセスの入出力はまったく変換しません.

変数`file-name-coding-system'は, ファイル名を符号化するためのコーディ
ングシステムを指定します.  この変数に（Lispシンボルや文字列で）コーディ
ングシステム名を設定すると, Emacsは, すべてのファイル操作に対してその
コーディングシステムを使ってファイル名を符号化します.  これは, ファイ
ル名に非ASCII文字を使うことを可能にしています.  あるいは, 少なくとも, 
指定したコーディングシステムで符号化できる非ASCII文字を使えるはずです.

`file-name-coding-system'が`nil'ならば, Emacsは, 選択されている言語環
境で決まるデフォルトのコーディングシステムを使います.  デフォルトの言
語環境では, ファイル名の中の非ASCII文字は特別に符号化しません.  Emacs
の内部表現でファイルシステム上に現れます.

*警告：*` 'Emacsセッションの途中で`file-name-coding-system' （や言語環
境）を変更すると, 問題となる場合があります.  つまり, それまでのコーディ
ングシステムで符号化された名前のファイルをすでに訪問していて, 新しいコー
ディングシステムではその名前を符号化できない（あるいは異なって符号化さ
れる）ときです.  そのようなバッファを訪問先ファイル名で保存しようとす
ると, まちがった名前のファイルに保存されるか, エラーになります.  その
ような問題が発生した場合には, `C-x C-w'を使って, そのバッファに新しい
ファイル名を指定します.



