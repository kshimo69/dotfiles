Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja, Node: Key Help, Next: Name Help, Prev: Help Summary, Up: Help

キーに関する説明
================

`C-h'のもっとも基本的なオプションは, 
`C-h c'（`describe-key-briefly'）と
`C-h k'（`describe-key'）です. 
`C-h c KEY'は, 
KEYにバインドしてあるコマンド名をエコー領域に表示します. 
たとえば, `C-h c C-f'と打てば`forward-char'と表示されます. 
コマンド名はそのコマンドが何をするかを表すように選んでありますから, 
キーKEYが何をするかをちょっと調べたい場合に, よい方法です. 

`C-h k KEY'も同様ですが, より多くの情報を表示します.  つまり, コマンド
の名前だけでなく, 説明文も表示します.  その内容はエコー領域に表示する
には多すぎるため, ウィンドウに表示します.

`C-h c'や`C-h k'は, ファンクションキーやマウスイベントも含めた, あらゆ
るキー列に適用できます.



File: emacs-ja, Node: Name Help, Next: Apropos, Prev: Key Help, Up: Help

コマンド名や変数名によるヘルプ表示
==================================

`C-h f'（`describe-function'）は, ミニバッファでLisp関数の名前を読み取
り, その関数の説明文字列をウィンドウに表示します.  コマンドはLisp関数
ですから, 名前を知っているコマンドであれば, その説明文を得ることができ
ます.  たとえば,

     C-h f auto-fill-mode RET

とすると, `auto-fill-mode'の説明文字列を表示できます.  どのキーにもバ
インドしていない（つまり, 通常`M-x'で起動する）コマンドの説明文字列を
見るには, この方法しかありません.

`C-h f'はまた, Lispプログラムの中で使おうと考えているLisp関数に対して
も有益です.  たとえば, 式`(make-vector len)'を書いたとしましょう.
`make-vector'を正しく使っているかどうか調べたいときには, `C-h f
make-vector RET'と打ちます.  `C-h f'は, コマンド名だけでなく, すべての
関数名に適用できるので, 普段`M-x'で使えている省略形が`C-h f'では使えな
いかもしれません.  ある省略形がコマンド名としては一意であったとしても, 
他の関数名を含めてみると一意ではない場合もあります.

ミニバッファでRETだけを打ってミニバッファが空の場合, `C-h f'に与えられ
る関数名にはデフォルト値があります.  デフォルト値は, バッファ内のポイ
ント周辺でもっとも内側のLisp式で呼び出される関数ですが, それが定義され
た正しいLisp関数の名前である場合に*限ります*.  たとえば, `(make-vector
(car x)'というテキストの直後にポイントがあると, ポイントを含むもっとも
内側のリストは`(make-vector'から始まる部分なので, デフォルトは関数
`make-vector'です.

`C-h f'は, 関数名の綴りが正しことを単に確認するためだけにも役立ちます.
`C-h f'がバッファ内の名前をデフォルトとして表示すれば, その名前はLisp
関数として定義されているはずです.  これだけを確認したいのであれば,
`C-g'を打って`C-h f'コマンドを取り消して, 編集を続けます.

`C-h w COMMAND RET'は, どのキーをCOMMANDにバインドしてあるかを表示しま
す.  キーの一覧をエコー領域に表示します.  どのキーにも割り当てられてい
ないと表示された場合は, そのコマンドは`M-x'で起動する必要があります.
`C-h w'はコマンド`where-is'を実行します.

`C-h v'（`describe-variable'）は`C-h f'に似ていますが, Lisp関数ではな
くLisp変数を説明する点が異なります.  デフォルトはポイント周辺またはポ
イントの直前のLispシンボルですが, 既知のLisp変数に限ります.  *Note
Variables::.



File: emacs-ja, Node: Apropos, Next: Library Keywords, Prev: Name Help, Up: Help

アプロポス
==========

より洗練された質問方法としては, 『ファイルを扱うコマンドは？』というの
があります.  このように質問するには, `C-h a file RET'と打ちます.  する
と, `copy-file'や`find-file'といった, `file'を名前に含むすべてのコマン
ドの一覧が表示されます.  各コマンドには, 使い方の簡単な説明やそのコマ
ンドを起動するキーが表示されます.  たとえば, `find-file'を起動するには
`C-x C-f'と打つ, といった具合です.  `C-h a'の`a'は「Apropos」（「適切
な」の意味）を表していて, `C-h a'はコマンド`apropos-command'を実行しま
す.  このコマンドは, 通常, コマンド（対話的な関数）のみを調べます.  前
置引数を指定すれば, 非対話的な関数も調べます.

`C-h a'は指定した文字列を名前に含む関数しか調べませんので, 文字列の指
定には工夫が必要です.  後向きに文字をキルするコマンドを探そうとして,
`C-h a kill-backwards RET'で何も表示されなくてもあきらめないでください.
`kill'のみ, あるいは`backwards'のみ, もしくは`back'のみを試して, 続け
てください.  柔軟性を増すために, 引数として正規表現も使えます（*Note
Regexps::）.

以下に, `C-h a'に指定する引数のうち, Emacsコマンドの多くの種類を網羅す
るものをあげておきます.  というのは, Emacsコマンドの標準の命名法には強
い慣行があるからです.  命名法の慣行を理解してもらえば, 適切な
（`apropos'）文字列を拾い出す技法の向上の手助けにもなるでしょう.

     char, line, word, sentence, paragraph, region, page, sexp, list,
     defun, rect, buffer, frame, window, face, file, dir, register,
     mode, beginning, end, forward, backward, next, previous, up,
     down, search, goto, kill, delete, mark, insert, yank, fill,
     indent, case, change, set, what, list, find, view, describe,
     default.

正規表現に一致するすべてのユーザー変数を表示するには, コマンド`M-x
apropos-variable'を使います.  このコマンドは, デフォルトでは, ユーザー
変数とカスタマイズオプションだけを表示します.  すべての変数を調べるに
は, 前置引数を指定します.

コマンドとして定義されているものだけでなく, 正規表現に一致するすべての
Lispシンボルを表示するには, `C-h a'のかわりに`M-x apropos'を使います. 
このコマンドは, デフォルトでは, キーバインドを調べません.  キーバイン
ドを調べるには, 前置引数を指定します.

`apropos-documentation'コマンドは`apropos'に似ていますが, 指定した正規
表現に一致するシンボル名だけでなく, 説明文字列も探索する点が異なります.

`apropos-value'コマンドは`apropos'に似ていますが, 指定した正規表現に一
致するシンボルの値を探す点が異なります.  このコマンドは, デフォルトで
は, 関数定義や属性リストを調べません.  それらも調べるには, 前置引数を
指定します.

変数`apropos-do-all'が`nil'以外ならば, 上に述べたコマンドはすべて, 前
置引数を指定したものとして動作します.

アプロポス（apropos）バッファに表示された関数定義, 変数, 属性リストに
ついて詳しく知りたいときには, `Mouse-2'ボタンでクリックするか, その箇
所へ移動してRETを打ちます.



File: emacs-ja, Node: Library Keywords, Next: Language Help, Prev: Apropos, Up: Help

Lispライブラリに対するキーワード探索
====================================

`C-h p'コマンドで, 標準Emacs Lispライブラリをトピックのキーワードで検
索できます.  利用可能なキーワードの一部を以下に示します.

     abbrev -- 略語操作, 短縮入力, マクロ. 
     bib -- 参考, 参照プロセッサ支援`bib'. 
     c -- C言語あるいはC++支援. 
     calendar -- 日付および時間管理支援. 
     comm -- 通信, ネットワーク, ファイルのリモートアクセス. 
     data -- データファイルの編集支援. 
     docs -- Emacsドキュメントに関する支援. 
     emulations -- 他のエディタのエミュレーション. 
     extensions -- Emacs Lisp言語の拡張. 
     faces -- フェイス（フォントや表示色, *Note Faces::）に関する支援. 
     frames -- Emacsフレームやウィンドウシステムに対する支援. 
     games -- ゲーム, ジョーク, 娯楽. 
     hardware -- 外部ハードウェアとのインターフェイス支援. 
     help -- オンラインヘルプシステム支援. 
     hypermedia -- テキストあるいは他メディア内でのリンク支援. 
     i18n -- 国際化, 代替文字集合支援. 
     internal -- Emacs内部コード, 構築手順, デフォルト. 
     languages -- プログラム言語編集用の特殊モード. 
     lisp -- Lisp利用支援（Emacs Lispも含む）. 
     local -- サイトにローカルなライブラリ. 
     maint -- Emacs開発グループ向けの管理用. 
     mail -- 電子メイル操作用のモード. 
     matching -- 探索, 一致. 
     news -- ネットニュースの購読, 投稿支援. 
     non-text -- 非テキストファイル編集支援. 
     oop -- オブジェクト指向プログラミング支援. 
     outlines -- 階層アウトライン. 
     processes -- プロセス, サブシェル, コンパイル, ジョブ制御支援. 
     terminals -- 端末タイプ支援. 
     tex -- TeXによる文書整形支援. 
     tools -- プログラミングツール. 
     unix -- UNIX機能のフロントエンド／アシスタントあるいはエミュレーション. 
     vms -- VMS支援コード. 
     wp -- ワープロ. 



File: emacs-ja, Node: Language Help, Next: Help Mode, Prev: Library Keywords, Up: Help

多言語支援に関するヘルプ
========================

コマンド`C-h L'（`describe-language-environment'）を使うと, 特定の言語
環境向けに, どのような支援があるかを把握できます.  *Note Language
Environments::.  このコマンドは, 今の言語環境がどの言語向けなのかを示
し, 一緒に使われる文字集合, コーディングシステム, 入力方式も表示します. 
また, 字体を例示するためのサンプルテキストもいくつか表示します.

コマンド`C-h h'（`view-hello-file'）は, ファイル`etc/HELLO'を表示しま
す.  このファイルには, いろいろな国の言葉で書いた『hello』を収めてあり
ます.

コマンド`C-h I'（`describe-input-method'）は, 指定した入力方式, あるい
は, デフォルトとして今使っている入力方式についての情報を表示します.
*Note Input Methods::.

コマンド`C-h C'（`describe-coding-system'）は, 指定したコーディングシ
ステム, あるいは, デフォルトとして今使っているコーディングシステムにつ
いての情報を表示します.  *Note Coding Systems::.



File: emacs-ja, Node: Help Mode, Next: Misc Help, Prev: Language Help, Up: Help

ヘルプモードのコマンド
======================

ヘルプバッファには, 閲覧（view）モード（*Note Misc File Ops::）のコマ
ンドに加えて, 独自の特別なコマンドもいくつかあります.

`SPC'
     前向きにスクロールする.
`DEL'
     後向きにスクロールする.
`RET'
     ポイント位置の相互参照を辿る.
`TAB'
     つぎの相互参照へ進む.
`S-TAB'
     まえの相互参照へ戻る.
`Mouse-2'
     クリックした相互参照を辿る.

説明文に現れるコマンド名（*Note M-x::）や変数名（*Note Variables::）は
通常, 引用符（`''）で囲まれています.  その名前を`Mouse-2'でクリックし
たり, あるいは, そこへポイントを移動してRETを打つと, そのコマンドや変
数の説明文字列を表示できます.  もとの場所に戻るには`C-c C-b'を使います.

ヘルプテキスト内の相互参照にポイントを移動する便利なコマンドがあります.
TAB（`help-next-ref'）は, ポイントをつぎの相互参照箇所へ進めます.  ポ
イントをまえの相互参照箇所へ戻すには`S-TAB'（`help-previous-ref'）を使
います.



File: emacs-ja, Node: Misc Help, Next: Mark, Prev: Help Mode, Up: Help

その他のヘルプコマンド
======================

`C-h i'（`info'）はinfoプログラムを実行します.  infoは構造化されたドキュ
メントファイルを閲覧するプログラムです.  Emacsの完全なマニュアルもinfo
で読むことができます.  将来的には, GNUシステムのすべてのドキュメントが
読めるようになるでしょう.  infoの使い方についてのチュートリアルを起動
するには, infoに入ってから`h'と打ちます.

数引数を指定すると, `C-h i'はドキュメントファイルの名前を聞いてきます. 
こうすれば, トップレベルのinfoメニューに記載されていないファイルでも閲
覧できます.

infoを介してEmacsドキュメントを参照するための特別なヘルプコマンドが2つ
あります.  `C-h C-f FUNCTION RET'は, infoに入ってただちにEmacsの関数
FUNCTIONのドキュメントに移動します.  `C-h C-k KEY'は, infoに入ってただ
ちにキーKEYのドキュメントに移動します.  これら2つのキーは, それぞれ,
`Info-goto-emacs-command-node', `Info-goto-emacs-key-command-node'を実
行します.

プログラム言語のinfo版のマニュアルがあれば, プログラムの編集中にコマン
ド`C-h C-i'を使って, マニュアルドキュメントのシンボル（キーワード, 関
数, 変数）に関する箇所を参照できます.  コマンドの細かい動作は, メジャー
モードに依存します.

予期しなかったことが起きたり, 入力したコマンドがわからなくなってしまっ
たときは, `C-h l'（`view-lossage'）を使ってください.  `C-h l'は, それ
までに打鍵した最後の100個のコマンド文字を表示します.  知らないコマンド
が表示されたら, `C-h c'でその機能を知ることができます.

Emacsには数多くのメジャーモードがあり, 各メジャーモードでは, いくつか
のキーを再定義し, 編集動作も少々変更しています.  `C-h m'
（`describe-mode'）は, 使用中のメジャーモードについての説明文を表示し
ます.  これには, 通常, モード内で変更してあるすべてのコマンドについて
の記述があります.

`C-h b'（`describe-bindings'）と`C-h s'（`describe-syntax'）は, Emacs
の現在のモードに関するその他の情報を与えてくれます.  `C-h b'は, 現在有
効なすべてのキーバインドの一覧を表示します.  マイナモードで定義されて
いるローカルバインディングから始めて, 現在のメジャーモードで定義されて
いるローカルバインディング, 最後にグローバルバインディングを表示します
（*Note Key Bindings::）.  `C-h s'は, 各文字の構文の説明を付けて構文テー
ブルの内容を表示します（*Note Syntax::）.

プレフィックスキーに続けて`C-h'を打てば, 特定のプレフィックスキーにつ
いて同様な一覧を表示できます.  （この方法では表示できないプレフィック
スキーも存在する.  それらのキーでは, `C-h'に対しては独自のバインディン
グがある.  ESCは, そのようなものの1つ.  `ESC C-h'は, 実際には`C-M-h'で
あり, 関数定義（defun）をマークする. ）

`C-h'の他のオプションは, 有益な情報を収めたさまざまなファイルを表示し
ます.  `C-h C-w'は, GNU Emacsがまったく無保証であることに関する全詳細
を表示します.  `C-h n'（`view-emacs-news'）は, ファイル
`emacs/etc/NEWS'を表示します.  このファイルには, Emacsの変更に関する記
述を時間順に収めてあります.  `C-h F'（`view-emacs-FAQ'）は, Emacsの
「よくある質問集」を表示します.  `C-h t'（`help-with-tutorial'）は, 
「操作しながらEmacsを学ぶ」チュートリアルを表示します.  `C-h C-c'
（`describe-copying'）は, ファイル`emacs/etc/COPYING'を表示します.  こ
のファイルには, Emacsを配布する場合に従うべき条件を記述してあります.
`C-h C-d'（`describe-distribution'）は, ファイル`emacs/etc/DISTRIB'を
表示します.  このファイルには, Emacsの最新版の注文方法を述べてあります.
`C-h C-p'（`describe-project'）は, GNUプロジェクトに関する一般情報を表
示します.


File: emacs-ja, Node: Mark, Next: Killing, Prev: Help, Up: Top

マークとリージョン
******************

Emacsの数多くのコマンドは, カレントバッファの任意の連続領域を操作しま
す.  このようなコマンドに操作対象となるテキストを指定するには, その一
方の端に"マーク"（mark）を置き, もう一方の端にポイントを移動します. 
ポイントとマークに挟まれたテキストを"リージョン"（region）と呼びます. 
暫定マーク（transient-mark）モードをオンにすると, リージョンが存在すれ
ばEmacsはつねにそのリージョンを強調表示します（*Note Transient Mark::）.

リージョンの境界を調整するには, ポイントやマークを移動します.  時間的
にどちらを先に設定したとか, テキスト内でどちらが先にあるかとかは関係あ
りません.  いったんマークを設定すると, 他の箇所に再設定するまで, その
位置情報はそのまま変わりません.  各Emacsバッファには個別にマークがあり
ますから, 以前に選択したバッファへ戻ったときには, 以前と同じままのマー
クが残っています.

`C-y'（`yank'）や`M-x insert-buffer'などのテキストを挿入するコマンドの
多くは, 挿入したテキストの両端にポイントとマークを置いて, 挿入したテキ
ストがリージョンに含まれるようにします.

リージョンの境界を定めること以外に, あとで戻る可能性のある箇所を覚えて
おくためにもマークを使えます.  この機能をより使いやすくするために, 各
バッファでは, それまでに設定した16個のマーク位置を"マークリング"（mark
ring）に記録しています.

* Menu:

* Setting Mark::	Commands to set the mark.
* Transient Mark::	How to make Emacs highlight the region--
			  when there is one.
* Using Region::	Summary of ways to operate on contents of the region.
* Marking Objects::	Commands to put region around textual units.
* Mark Ring::   	Previous mark positions saved so you can go back there.
* Global Mark Ring::    Previous mark positions in various buffers.



File: emacs-ja, Node: Setting Mark, Next: Transient Mark, Prev: Mark, Up: Mark

マークを設定する
================

マークを設定するコマンドはつぎのとおりです.

`C-SPC'
     ポイント位置にマークを置く（`set-mark-command'）.
`C-@'
     上と同様.
`C-x C-x'
     マークとポイントを入れ換える（`exchange-point-and-mark'）.
`Drag-Mouse-1'
     ドラッグしたテキストの周囲にポイントとマークを設定する.
`Mouse-3'
     ポイント位置にマークを設定し, クリックした箇所にポイントを移動す
     る（`mouse-save-then-kill'）.

たとえば, コマンド`C-x C-u'（`upcase-region'）を使って, バッファのある
部分をすべて大文字に変換したいとしましょう.  このコマンドは, リージョ
ン中のテキストに作用します.  まず, 大文字に変換したいテキストの先頭に
移動し, `C-SPC'と打ってマークを設定します.  続いてテキストの終端に移動
して`C-x C-u'と打ちます.  あるいは, 先にテキストの終端にマークを設定し
て, テキストの始点に移動してから`C-x C-u'と打ちます.

マークを設定するもっとも一般的な方法は, `C-SPC'コマンド
（`set-mark-command'）を使うことです.  このコマンドは, ポイント位置に
マークを設定します.  そうすれば, マークを置いたままで, ポイントを移動
できます.

マウスを使ったマークの設定方法は2つあります.  テキストのある範囲でマウ
スボタン1をドラッグします.  マウスボタンを離した位置にポイントが置かれ, 
ドラッグを開始した箇所にマークが設定されます.  あるいは, マウスボタン3
をクリックします.  これは（`C-SPC'と同様に）ポイント位置にマークを設定
してから, ポイントを（`Mouse-1'のように）移動します.  両者は, マークを
設定するだけでなく, リージョンをキルリングにコピーします.  これは, 他
のウィンドウアプリケーションの動作と一貫性を持たせるためです.  キルリ
ングを変更したくなければ, キーボードコマンドを使ってマークを設定する必
要があります.  *Note Mouse Commands::.

普通の端末にはカーソルは1つしかありませんから, Emacsにはマークを置いた
位置を表示する術はありません.  ユーザーがその位置を覚えておく必要があ
ります.  この問題に対する通常の解決方法は, マークを設定したら, 忘れて
しまうまえにただちにそれを利用することです.  あるいは, `C-x C-x'
（`exchange-point-and-mark'）コマンドを使って, マーク位置を確認します. 
このコマンドは, ポイント位置にマークを置き, マークのあった位置にポイン
トを置きます.  リージョンの範囲は変わらずに, カーソルとポイントは以前
マークのあった箇所に移動します.  暫定マーク（transient-mark）モードで
は, このコマンドはマークを再度活性にします.

ポイント位置を変えずに, リージョンのもう一方の端（マークの位置）を移動
させたい場合にも, `C-x C-x'は便利な方法です.  まず, `C-x C-x'でポイン
トをリージョンの一方の端に移して, その端を移動します.  必要ならば, も
う1度`C-x C-x'を使って新しい位置にマークを置き, ポイントをもとの位置に
戻します.

ASCIIには, `C-SPC'という文字は存在しません.  CTRLを押し下げながらSPCを
打つと, ほとんどの普通の端末では文字`C-@'になります.  このキーは, 実際
に`set-mark-command'にバインドしてあります.  ただし, 幸運にも`C-SPC'で
`C-@'を送出する端末を使っているのであれば, `C-@'を`C-SPC'とみなしてか
まいません.  Xウィンドウシステムでは, `C-SPC'は実際には別の文字として
認識されますが, そのバインドはやはり`set-mark-command'です.



File: emacs-ja, Node: Transient Mark, Next: Using Region, Prev: Setting Mark, Up: Mark

暫定マークモード（transient-markモード）
========================================

Xウィンドウシステムを使っているのであれば, Emacsはカレントリージョンを
強調表示できます.  ただし, 通常はリージョンを強調表示しません.  なぜで
しょうか？

実は, もともとのEmacsではリージョンの強調表示をうまくできないのです. 
いったんマークを設定してしまうと, そのバッファ内には*つねに*リージョン
が存在することになるからです.  リージョンを強調表示し続けても迷惑なだ
けでしょう.

暫定マーク（transient-mark）モードをオンにすると, リージョンの強調表示
機能をオンにできます.  暫定マーク（transient-mark）モードは, リージョ
ンが一時的にしか『存続』しない, 通常よりきびしい操作モードです.  ユー
ザーは, リージョンを使うコマンドごとにリージョンを設定する必要がありま
す.  暫定マーク（transient-mark）モードでは, ほとんどの期間, リージョ
ンは存在しません.  それゆえ, リージョンが存在するときにリージョンを強
調表示しても邪魔になりません.

暫定マーク（transient-mark）モードをオンにするには, `M-x
transient-mark-mode'と打ちます.  このコマンドはモードのオン／オフを切
り替えますから, モードをオフにしたいときにはコマンドをもう1度繰り返し
ます.

暫定マーク（transient-mark）モードの詳細を以下に示します.

   * マークを設定するには, `C-SPC'（`set-mark-command'）と打つ.  この
     操作はマークを活性にする.  ポイントを移動するたびに, 強調表示され
     たリージョンが広がったり狭まったりする.

   * マークを設定するマウスコマンドも, マークを活性にする.  `M-@',
     `C-M-@', `M-h', `C-M-h', `C-x C-p', `C-x h'などのリージョンを設定
     するためのキーボードコマンドもマークを活性にする.

   * マークが活性ならば, キル, 字下げ, ファイルへの書き出しなどのリー
     ジョンを操作するコマンドを実行できる.

   * 文字の挿入や削除といったバッファに対する変更は, マークを不活性に
     する.  つまり, これ以降にリージョンを操作するコマンドを実行すると
     エラーとなり, 実行は拒否される.  リージョンを再度活性にするには,
     `C-x C-x'と打つ.

   * `M->'や`C-s'のような, 本来の目的を達成したあとに『マークを残す』
     種類のコマンドは, 新しいマークを活性にしない.  このような新しいリー
     ジョンを活性にするには, `C-x C-x'（`exchange-point-and-mark'）を
     実行する.

   * マークが活性であるときには, `C-s'はマークを変更しない.

   * `C-g'で中断すると, マークを不活性にする.

リージョンの強調表示には, `region'フェイスを使います.  このフェイスを
変更すれば, リージョンの強調表示方法をカスタマイズできます.

複数のウィンドウで同じバッファを表示しているときには, それぞれのウィン
ドウで別の部分を表示できます.  というのは, （マーク位置は共有されるが）
各ウィンドウごとに別々にポイントの値があるからです.  通常, 選択された
ウィンドウでのみ, リージョンを強調表示します（*Note Windows::）.  しか
し, 変数`highlight-nonselected-windows'に`nil'以外を設定すると, （暫定
マーク（transient-mark）モードがオンであり, かつ, ウィンドウのバッファ
のマークが活性である場合に限り）各ウィンドウでそれぞれのリージョンを強
調表示します.

暫定マーク（transient-mark）モードがオフであると, マークを設定するすべ
てのコマンドはマークを活性にし, マークを不活性にするものは何もありませ
ん.

暫定マーク（transient-mark）モードにおいて, 変数
`mark-even-if-inactive'が`nil'以外であると, マークが不活性であってもコ
マンドはマークやリージョンを利用できます.  通常の暫定マーク
（transient-mark）モードと同様に, リージョンが強調表示されたりされなかっ
たりしますが, 強調表示されていなくてもマークが本当になくなることはあり
ません.

暫定マーク（transient-mark）モードは『zmacsモード』としても知られてい
ます.  というのも, MITのLispマシン上で動作していたZmacsエディタが同じ
ようにマークを扱っていたからです.



File: emacs-ja, Node: Using Region, Next: Marking Objects, Prev: Transient Mark, Up: Mark

リージョンに対する操作
======================

いったんリージョンを設定しマークを活性にすれば, 以下のようにリージョン
を操作できます.

   * `C-w'コマンドでキルする（*Note Killing::）.
   * `C-x r s'でレジスタに保存する（*Note Registers::）.
   * バッファやファイルに保存する（*Note Accumulating Text::）.
   * `C-x C-l'や`C-x C-u'で大文字小文字を変換する（*Note Case::）.
   * `C-x TAB'や`C-M-\'で字下げする（*Note Indentation::）.
   * `M-x fill-region'でテキストを詰め込む（*Note Filling::）.
   * `M-x print-region'でハードコピーを印刷する（*Note Hardcopy::）.
   * `M-x eval-region'でLispコードとして評価する（*Note Lisp Eval::）.

リージョン内のテキストを操作するコマンドの多くは, その名前に`region'と
いう単語を含みます.



File: emacs-ja, Node: Marking Objects, Next: Mark Ring, Prev: Using Region, Up: Mark

テキストオブジェクトをマークするコマンド
========================================

単語, リスト, 段落, ページといったテキストのまとまりにポイントやマーク
を置くコマンドがあります.

`M-@'
     つぎの語の末尾にマークを設定する（`mark-word'）.  このコマンドと
     つぎのコマンドはポイントを移動しない.
`C-M-@'
     つぎのLisp式の末尾にマークを設定する（`mark-sexp'）.
`M-h'
     現在の段落を囲むリージョンを設定する（`mark-paragraph'）.
`C-M-h'
     現在のLisp関数定義（defun）を囲むリージョンを設定する
     （`mark-defun'）.
`C-x h'
     バッファ全体をリージョンとする（`mark-whole-buffer'）.
`C-x C-p'
     現在のページを囲むリージョンを設定する（`mark-page'）.

`M-@'（`mark-word'）がつぎの語の末尾にマークを設定するのに対し,
`C-M-@'（`mark-sexp'）はつぎのLisp式の末尾にマークを設定します.  これ
らのコマンドは, `M-f'や`C-M-f'と同様に引数を扱います.

その他のコマンドは, ポイントとマークの両方を設定して, バッファ内で対象
物を区切ります.  たとえば, `M-h'（`mark-paragraph'）は, ポイントを囲む
あるいはポイントに続く段落の先頭にポイントを移動し, その段落の末尾にマー
クを置きます（*Note Paragraphs::）.  このようにリージョンを設定するの
で, 段落全体を字下げしたり, 大文字小文字を変換したり, キルしたりできま
す.

`C-M-h'（`mark-defun'）も同様に, 現在の関数定義や後続の関数定義の先頭
にポイントを置き, その末尾にマークを置きます（*Note Defuns::）.  `C-x
C-p'（`mark-page'）は, 現在のページの先頭にポイントを置き, その末尾に
マークを置きます（`mark-page'）.  マークはページ区切りの直後に設定され
（リージョンに含まれる）, 一方, ポイントはページ区切りの直後に置かれま
す（リージョンに含まれない）.  数引数で, 現在のページのかわりに（正な
らば）後続のページや, （負ならば）先行するページを指定できます.

最後に紹介する`C-x h'（`mark-whole-buffer'）は, バッファ全体にリージョ
ンを設定します.  つまり, ポイントをバッファの先頭に置き, マークをバッ
ファの末尾に置きます.

暫定マーク（transient-mark）モードでは, これらのコマンドはすべて, マー
クを活性にします.



File: emacs-ja, Node: Mark Ring, Next: Global Mark Ring, Prev: Marking Objects, Up: Mark

マークリング
============

マークには, リージョンを区切る以外にも, あとで戻る可能性のある箇所を記
録するという便利な使い方があります.  この機能をより便利にするために, 
各バッファでは以前の16箇所のマーク位置を"マークリング"（mark ring）に
記録しています.  マークを設定するコマンドは, 古いマークをこのマークリ
ングに入れます.  マークを設定していた箇所に戻るには, `C-u C-SPC'（また
は`C-u C-@'）を使います.  これは, `set-mark-command'コマンドに数引数を
指定したものです.  このコマンドは, マークがあった箇所にポイントを移動
し, それ以前のマークを収めたマークリングからマークを復元します.  した
がって, このコマンドを繰り返すと, マークリング上にある過去のマークのす
べてを1つ1つ遡って移動できます.  このように辿ったマーク位置は, マーク
リングのうしろに付け加えられるので, なくなってしまうことはありません.

各バッファには独自のマークリングがあります.  すべての編集コマンドは, 
カレントバッファのマークリングを使います.  特に, `C-u C-SPC'は, つねに
同じバッファに留まります.

`M-<'（`beginning-of-buffer'）のような長距離を移動するコマンドの多くは, 
まずマークを設定して, 古いマークをマークリングに保存してから動作を開始
します.  このようにして, あとで簡単に戻れるようにしておきます.  探索コ
マンドは, ポイントを移動するときにはマークを設定します.  コマンドがマー
クを設定したかどうかは, エコー領域に`Mark Set'と表示されるのでわかりま
す.

何度も同じ場所に戻りたい場合には, マークリングでは不十分でしょう.  こ
のような場合には, あとで使うために位置情報をレジスタに記録できます
（*Note RegPos::）.

変数`mark-ring-max'は, マークリングに保存する最大項目数を指定します. 
すでに多くの項目が存在していて, さらにもう1つ押し込むときには, リスト
内の最古の項目を捨てます.  `C-u C-SPC'を繰り返し実行すると, いまマーク
リングに入っている位置を巡回することになります.

変数`mark-ring'は, 最新のマーカオブジェクトを先頭にして, マーカオブジェ
クトのリストとしてマークリングを保持します.  この変数は各バッファにロー
カルです.



File: emacs-ja, Node: Global Mark Ring, Next: Killing, Prev: Mark Ring, Up: Mark

グローバルマークリング
======================

個々のバッファごとの普通のマークリングに加えて, Emacsには"グローバルマー
クリング"（global mark ring）が1つあります.  グローバルマークリングは, 
最近マークを設定したバッファの系列を記録しますから, それらのバッファに
戻ることができます.

マークを設定すると, つねにカレントバッファのマークリングに項目を作りま
す.  マークを設定した以降にバッファを切り替えていると, 新しくマークを
設定するとグローバルマークリングにも項目を作成します.  その結果, グロー
バルマークリングには訪れていたバッファの系列が記録され, 各バッファでは
マークを設定した箇所が記録されます.

コマンド`C-x C-SPC'（`pop-global-mark'）は, グローバルマークリングの最
新の項目が示すバッファの位置に移動します.  グローバルマークリングも巡
回されるので, `C-x C-SPC'を繰り返し使用すると, 1つずつまえのバッファに
移動できます.




File: emacs-ja, Node: Killing, Next: Yanking, Prev: Mark, Up: Top

削除とキル
==========

バッファからテキストを消しさるコマンドのほとんどは, そのテキストをキル
リングにコピーしておくので, バッファの他の部分にそのテキストを移動した
りコピーしたりできます.  これらのコマンドを, "キル"（kill）コマンドと
呼びます.  それ以外の『テキストを消すコマンド』は, テキストをキルリン
グに保存しません.  これらを"削除"（delete）コマンドと呼びます.  （両者
を区別するのは, バッファ内のテキストを消す場合だけ. ）キルコマンドや削
除コマンドを誤って実行してしまった場合には, `C-x u'（`undo'）コマンド
を使って, もとに戻すことができます.

削除コマンドには, 一度に1つの文字だけを削除する`C-d'（`delete-char'）
やDEL（`delete-backward-char'）, 空白や改行だけを削除するコマンドがあ
ります.  単純ではないデータをかなりの分量で破壊する可能性のあるコマン
ドは, 一般にキルを行います.  コマンド名や個々の説明では, そのコマンド
がどちらの働きをするかによって, `キル'（kill）と`削除'（delete）を使い
分けています.

* Menu:

* Deletion::            Commands for deleting small amounts of text and
                          blank areas.
* Killing by Lines::    How to kill entire lines of text at one time.
* Other Kill Commands:: Commands to kill large regions of text and
                          syntactic units such as words and sentences. 



File: emacs-ja, Node: Deletion, Next: Killing by Lines, Prev: Killing, Up: Killing

削除
----

`C-d'
     つぎの文字を削除する（`delete-char'）.
`DEL'
     まえの文字を削除する（`delete-backward-char'）.
`M-\'
     ポイントの周りの空白とタブを削除する（`delete-horizontal-space'）.
`M-SPC'
     ポイントの周りの空白とタブを削除し, 空白を1個だけ残す
     （`just-one-space'）.
`C-x C-o'
     現在行の周りの空行を削除する（`delete-blank-lines'）.
`M-^'
     行間の改行とそれに続く字下げを削除して2行を繋げる
     （`delete-indentation'）.

もっとも基本的な削除コマンドは, `C-d'（`delete-char'）とDEL
（`delete-backward-char'）です.  `C-d'はポイントの直後の文字, つまり, 
カーソルが重なっている文字を削除します.  このコマンドでは, ポイントは
動きません.  DELはカーソルの直前の文字を削除して, ポイントを1つまえに
移動します.  バッファ内の他の文字と同様に, 改行も削除できます.  改行を
削除すると, 2つの行が繋がります.  実際には, `C-d'とDELがつねに削除コマ
ンドであるわけではありません.  引数を指定するとキルコマンドとなり, 同
じ方法で2文字以上を消すことができます.

他の削除コマンドは, 空白, タブ, 改行といった白文字だけを削除します.
`M-\'（`delete-horizontal-space'）は, ポイントの前後にあるすべての空白
とタブ文字を削除します.  `M-SPC'（`just-one-space'）も同様に削除します
が, 今ある空白の個数に関係なく（たとえ0個でも）, ポイントの直後に空白
を1個だけ残します.

`C-x C-o'（`delete-blank-lines'）は, 現在行に続くすべての空行を削除し
ます.  現在行が空行である場合には, （空行である現在行だけを残して）先
行する空行も同様にすべて削除します.

`M-^'（`delete-indentation'）は, 改行とその周りの空白を削除して, 通常
は空白を1個残して現在行と先行する行を繋げます.  *Note M-^:
Indentation.



File: emacs-ja, Node: Killing by Lines, Next: Other Kill Commands, Prev: Deletion, Up: Killing

行単位のキル
------------

`C-k'
     行の残りの部分, あるいは, 行全体を1行以上キルする（`kill-line'）.

もっとも単純なキルコマンドは`C-k'です.  行の先頭で使うと, その行のすべ
てのテキストをキルして, 空行にします.  空行で使うと, 改行を含めてその
行を完全にキルします.  空行でない行を完全にキルするには, 行頭で`C-k'を
2回打ちます.

一般に, `C-k'は, 行末でなければ, ポイントからその行の末尾までをキルし
ます.  行末では, ポイントのうしろの改行をキルするので, 現在行と後続の
行が繋がります.  どちらの動作をするか決めるときには, 行末にあって見に
くい空白やタブを無視しますから, ポイントが行末にあるように見えていれば,
`C-k'で改行がキルされると考えてください.

`C-k'に正の引数を指定すると, その個数の行とそれらに続く改行をキルしま
す（ただし, 現在行のポイントよりまえのテキストは残す）.  負の引数-Nを
指定すると, `C-k'は現在行に先行するN行（と現在行のポイント位置よりまえ
のテキストを含めて）を削除します.  つまり, ポイントが行頭にある状態で
`C-u - 2 C-k'とすれば, 先行する2行をキルします.

`C-k'に引数0を指定すると, 現在行のポイントよりまえのテキストをキルしま
す.

変数`kill-whole-line'が`nil'以外の場合, 行頭で`C-k'を使うと, 行末の改
行も含めて行全体をキルします.  この変数は, 通常, `nil'です.



File: emacs-ja, Node: Other Kill Commands, Next: Yanking, Prev: Killing by Lines, Up: Killing

他のキルコマンド
----------------

`C-w'
     リージョン（ポイントからマークまで）をキルする（`kill-region'）.
`M-d'
     単語をキルする（`kill-word'）.  *Note Words::.
`M-DEL'
     単語を後向きにキルする（`backward-kill-word'）.
`C-x DEL'
     文の先頭までを後向きにキルする（`backward-kill-sentence'）.
     *Note Sentences::.
`M-k'
     文の末尾までをキルする（`kill-sentence'）.
`C-M-k'
     S式をキルする（`kill-sexp'）.  *Note Lists::.
`M-z CHAR'
     つぎにCHARが現れる箇所までをキルする（`zap-to-char'）.

汎用的なキルコマンドといえば`C-w'（`kill-region'）です.  このコマンド
は, あらかじめ連続領域をポイントとマークで囲んでおけば, どんな連続領域
でもキルできます.

探索と組み合わせた便利なキルの仕方もあります.  `M-z'（`zap-to-char'）
は1文字を読み取り, ポイントからバッファ内でその文字がつぎに現れる箇所
までを（その文字も含めて）キルします.  数引数を指定した場合は, 反復回
数を意味します.  負の引数の場合は, ポイント位置から逆方向に探索し, ポ
イントの直前までをキルします.

他の構文単位でもキルできます.  `M-DEL'や`M-d'（*Note Words::）で単語を,
`C-M-k'（*Note Lists::）でS式を, `C-x DEL'や`M-k'（*Note Sentences::）
で文をキルできます.

読み出し専用のバッファでもキルできます.  実際にはバッファに変更を加え
ることはありませんし, ベルを鳴らしてその旨警告を発しますが, キルしよう
としたテキストはキルリングにコピーされます.  ですから, 別のバッファに
そのテキストをヤンクできます.  ほとんどのキルコマンドは, このようにコ
ピーするテキストを越えてポイントを進めますから, 連続してキルコマンドを
実行してもキルリングに入る項目は通常どおり1個だけです.



File: emacs-ja, Node: Yanking, Next: Accumulating Text, Prev: Killing, Up: Top

ヤンク
======

"ヤンク"（yank）とは, 以前にキルしたテキストをバッファにふたたび挿入す
ることです.  他のシステムでは『ペースト』と呼ぶこともあります.  テキス
トを移動したりコピーしたりする普通の方法は, そのテキストをいったんキル
してから, 別の場所に（1回以上）ヤンクすることです.

`C-y'
     最後にキルしたテキストをヤンクする（`yank'）.
`M-y'
     たった今ヤンクしたテキストをそれより以前にキルした一塊のテキスト
     で置き換える（`yank-pop'）.
`M-w'
     リージョンを実際にはキルせずに, 最後にキルしたテキストとして保存
     する（`kill-ring-save'）.
`C-M-w'
     つぎのキルを, 最後にキルした一塊のテキストに付け加える
     （`append-next-kill'）.

* Menu:

* Kill Ring::		Where killed text is stored.  Basic yanking.
* Appending Kills::	Several kills in a row all yank together.
* Earlier Kills::	Yanking something killed some time ago.



File: emacs-ja, Node: Kill Ring, Next: Appending Kills, Prev: Yanking, Up: Yanking

キルリング
----------

すべてのキルされたテキストは, キルされたテキストの塊をリストとする"キ
ルリング"（kill ring）に記録されています.  キルリングはたった1つしかな
くて, すべてのバッファで共有しています.  ですから, あるバッファでキル
したテキストは, 別のバッファでヤンクできます.  普通, このようにして, 
あるファイルから別のファイルへテキストを移動します.  （別の方法につい
ては, *Note Accumulating Text::. ）

コマンド`C-y'（`yank'）は, 最後にキルしたテキストをふたたび挿入します. 
カーソルは挿入したテキストの末尾に置かれます.  マークは挿入したテキス
トの先頭に置かれます.  *Note Mark::.

`C-u C-y'は, テキストのまえにカーソルを置き, うしろにマークを置きます. 
引数として`C-u'だけを指定した場合に限り, こうなります.  `C-u'と数字を
含めた他の引数を指定すると, いくつまえのキル内容をヤンクするかを意味し
ます（*Note Earlier Kills::）.

一塊のテキストをコピーする場合は, `M-w'（`kill-ring-save'）を使うとよ
いでしょう.  このコマンドは, バッファからリージョンをキルせずに, リー
ジョンをキルリングにコピーします.  このコマンドは, `C-w'に続けて`C-x
u'を実行するのとほぼ同等ですが, `M-w'はアンドゥ履歴を変更しませんし, 
一時的にせよ画面表示も変わりません.



File: emacs-ja, Node: Appending Kills, Next: Earlier Kills, Prev: Kill Ring, Up: Yanking

キルしたテキストの追加
----------------------

通常, 各キルコマンドは, キルリングに新たな項目を押し込みます.  しかし, 
連続したキルコマンドでは, それぞれでキルしたテキストを1つの項目にまと
めます.  そのため, 1回の`C-y'で, キルするまえの状態に, それらのテキス
トをひとまとめにヤンクできます.

したがって, テキストを一塊でヤンクしたい場合でも, 1つのコマンドでそれ
らをキルする必要はありません.  すべてをキルするまで, 1行ずつ, あるいは,
1単語ずつキルしていっても, 一括してもとに戻すことができます.

ポイント位置から前向きにキルするコマンドでは, 
直前にキルしたテキストの末尾に付け加えます. 
ポイント位置から後向きにキルするコマンドでは, 
テキストの先頭に付け加えます. 
このように, 前向き／後向きの両方のキルコマンドをどのように混ぜて実行しても, 
キルしたテキストの順番を崩すことなく
1つの項目としてキルリングに記録されます. 
数引数を指定しても, このような追加系列が途切れることはありません. 
たとえば, バッファにつぎのテキストが入っていて, 
-!-の位置にポイントがあるとしましょう.

     This is a line -!-of sample text.

`M-d M-DEL M-d M-DEL'と打って, 前向き／後向きと交互にキルしても, キル
リングには1つの項目として`a line of sample'が入り, バッファには`This
is text.'が残ります.  （空白が2個残っていることに注意.  これらは
`M-SPC'や`M-q'で一掃できる. ）

同じようにテキストをキルするもう1つの方法は, `M-b M-b'で後向きに2語移
動してから, `C-u M-d'で前向きに4語キルします.  こうしても, バッファと
キルリングの中身は, 先の例とまったく同じ結果になります.  `M-f M-f C-u
M-DEL'としても, 後向きに同じテキストをキルします.  これでもやはり同じ
結果が得られます.  キルリングの項目内のテキストの順序は, キルするまえ
のバッファ内での順序と同じです.

キルコマンドと最後のキルコマンドのあいだに（単なる数引数ではない）他の
コマンドが入ると, キルリングには新たな項目が作られます.  しかし, キル
コマンドを打つ直前にコマンド`C-M-w'（`append-next-kill'）を打っておけ
ば, 既存の項目へ追加するように強制できます.  `C-M-w'は, つぎがキルコマ
ンドであれば, 新たな項目を作成するかわりにキルしたテキストを以前にキル
したテキストに付け加えるよう指示します.  `C-M-w'を使うことで, まとめて
1か所にヤンクできるように, 離れた場所にあるいくつかのテキスト断片をキ
ルして集めておけます.

`M-w'に続くキルコマンドでは, `M-w'がキルリングにコピーしたテキストには
付け加えません.



File: emacs-ja, Node: Earlier Kills, Next: Accumulating Text, Prev: Appending Kills, Up: Yanking

以前にキルしたテキストのヤンク
------------------------------

直前にキルしたものではないテキストを取り出すには, `M-y'コマンド
（`yank-pop'）を使います.  `M-y'は, 直前にヤンクしたテキストをそれ以前
にキルしたテキストで置き換えます.  たとえば, 最後から2つめのキルテキス
トを取り出すには, まず`C-y'で最後にキルしたテキストをヤンクしてから,
`M-y'で1つまえのものに置き換えます.  `M-y'は`C-y'や他の`M-y'の直後でし
か使えません.

キルリング内の項目を指す『最終ヤンク』ポインタを考えると, `M-y'の動作
を理解しやすいでしょう.  キルするたびに, 『最終ヤンク』ポインタは, リ
ングの先頭に新たに作られた項目を指します.  `C-y'は, 『最終ヤンク』ポイ
ンタが指す項目をヤンクします.  `M-y'は, 『最終ヤンク』ポインタを別の項
目へ移動し, それに合わせてバッファのテキストを変更します.  `M-y'コマン
ドを繰り返せばリング内のどの項目へもポインタを移動できるので, どの項目
でもバッファに取り込めます.  ポインタがリングの最後に達すると, つぎの
`M-y'はポインタをふたたびリングの先頭の項目に移動します.

`M-y'は, リング内で『最終ヤンク』ポインタを移動しますが, リング内の項
目の順番を変えることはありません.  つねに, 最後にキルしたものが先頭に
あり, 記録に残っている最古のものが最後尾にあります.

`M-y'には数引数を指定できて, 『最終ヤンク』ポインタをいくつ進めるかを
指定します.  負の引数では, ポインタをリングの先頭に向けて移動します. 
リングの先頭からは最後の項目へ移動し, そこから先頭に向けて移動します.

目的のテキストがバッファに入ったならば, `M-y'コマンドの繰り返しを止め
れば, みつけたテキストが残ります.  そのテキストはキルリングの項目のコ
ピーなので, バッファ内で編集してもリング内の項目は変わりません.  新た
にキルしない限り, 『最終ヤンク』ポインタはキルリング内の同じ場所を指し
ていますから, `C-y'を繰り返すと, 直前に取り込んだものと同じキル内容の
コピーをヤンクできます.

目的のテキストを引き出すのに`M-y'コマンドを何回使えばよいのかわかって
いる場合には, 数引数を指定して`C-y'を使えば, 一発で目的のテキストをヤ
ンクできます.  `C-y'に数引数を指定すると, キルリング内でその個数分だけ
遡った項目のテキストを取り込みます.  たとえば, `C-u 2 C-y'は最後から2
番目にキルしたテキストを取り込みます.  つまり, `C-y M-y'とするのと等価
です.  数引数を指定した`C-y'は, 『最終ヤンク』ポインタの場所から数え始
め, ヤンクする項目にポイントを移動します.

キルリングの長さは, 変数`kill-ring-max'で制御します.  この個数以上のキ
ルテキストは保存しません.

キルリングの実際の内容は, `kill-ring'という名前の変数に入っています. 
キルリングの全内容は, コマンド`C-h v kill-ring'で見ることができます.



File: emacs-ja, Node: Accumulating Text, Next: Rectangles, Prev: Yanking, Up: Top

テキストの蓄積
==============

通常, テキストをコピーしたり移動したりするにはキルとヤンクで行います. 
しかし, 一塊のテキストを何か所にもコピーしたり, 多くの箇所に分散したテ
キストを1か所にコピーしたりするのに便利な方法が他にもあります.  一塊の
テキストを何か所にもコピーするには, そのテキストをレジスタに保存します
（*Note Registers::）.  ここでは, 何か所かに分散したテキストをバッファ
やファイルに蓄積するためのコマンドを説明します.

`M-x append-to-buffer'
     リージョンを指定したバッファの内容の末尾に付加する.
`M-x prepend-to-buffer'
     リージョンを指定したバッファの内容の先頭に付加する.
`M-x copy-to-buffer'
     リージョンを指定したバッファにコピーするが, そのバッファの古い内
     容は削除する.
`M-x insert-buffer'
     指定したバッファの内容をカレントバッファのポイント位置に挿入する.
`M-x append-to-file'
     リージョンを指定したファイルの内容の末尾に付加する.

テキストをバッファに蓄積するには, `M-x append-to-buffer'を使います. 
これは, バッファ名を読み取り, リージョンのコピーを指定したバッファに挿
入します.  存在しないバッファを指定した場合, `append-to-buffer'はバッ
ファを作成します.  テキストは, そのバッファ内のポイント位置に挿入され
ます.  バッファを編集用に使っている場合には, そのバッファ内のテキスト
のあいだ, その時点のポイント位置にコピーしたテキストを挿入します.

コピー先のバッファ内では, ポイントはコピーされたテキストの末尾に置かれ
ます.  したがって, 連続して`append-to-buffer'を使うと, コピーした順序
でバッファにテキストが蓄積されます.  厳密には, `append-to-buffer'は, 
バッファ内の既存のテキストに追加するとは限りません.  そのバッファの末
尾にポイントがある場合に限り, 追加します.  しかし, バッファを変更する
コマンドが`append-to-buffer'だけならば, ポイントはつねに末尾に置かれて
います.

`M-x prepend-to-buffer'は`append-to-buffer'にとてもよく似ていますが, 
コピー先のバッファ内のポイントは, コピーしたテキストの直前に置かれる点
が異なります.  つまり, 続けてこのコマンドを使うと, テキストは逆順に追
加されていきます.  `M-x copy-to-buffer'も同様ですが, 指定したバッファ
内の既存のテキストを削除します.  したがって, バッファには新たにコピー
したテキストだけが残ります.

別のバッファに蓄積したテキストを取り出すには, コマンド`M-x
insert-buffer'を使います.  このコマンドも引数としてBUFFERNAMEを必要と
します.  バッファBUFFERNAME内のテキストのコピーを選択しているバッファ
に挿入します.  あるいは, そのバッファを選択して編集し, 場合によっては
キルしてそのバッファからテキストを移動することもできます.  バッファに
関する背景情報は, *Note Buffers::.

テキストをEmacsのバッファに蓄積するかわりに, `M-x append-to-file'を使っ
て, テキストを直接ファイルに追加できます.  このコマンドは引数として
FILENAMEを必要とします.  リージョンのテキストを指定したファイルの末尾
に追加します.  ファイルはディスク上でただちに更新されます.

このコマンドに指定するファイルは, Emacsで訪問して*いない*ファイルだけ
に限るべきです.  Emacsで編集中のファイルを指定すると, Emacsに隠れてファ
イルを変更することになり, 編集内容の一部を失うことにもなりかねません.



File: emacs-ja, Node: Rectangles, Next: Registers, Prev: Accumulating Text, Up: Top

矩形領域
========

矩形領域コマンドはテキストの矩形領域を操作します.  矩形領域のテキスト
とは, 2つの行の範囲内にある2つの桁位置のあいだにある文字すべてを指しま
す.  矩形領域をキルする, キルした矩形領域をヤンクする, 矩形領域をクリ
アする, 矩形領域を空白やテキストで充填する, 矩形領域を削除する, といっ
たコマンドがあります.  矩形領域コマンドは, 複数段に組んだテキストを操
作したり, テキストをそのように組んだり戻したりする場合に便利です.

コマンドで操作する矩形領域を指定するには, 一方の隅にマークを設定し, そ
の対角にポイントを置きます.  このように設定した矩形領域を"矩形リージョ
ン" （region-rectangle）と呼びます.  というのも, リージョンの制御と似
た方法で矩形領域を制御できるからです.  しかし, ポイントとマークの組は, 
それを使うコマンドに依存して, リージョンとして解釈される, あるいは, 矩
形領域として解釈されることに注意してください.

ポイントとマークが同じ桁位置にある場合, それらが切り分ける矩形領域は空
です.  同じ行上にある場合は, 矩形領域の高さは1行です.  桁と行の扱い方
が非対称であるのは, ポイント（同様にマーク）は2つの桁のあいだにあるの
に対し, 行ではその中にあるからです.

`C-x r k'
     矩形リージョンのテキストをキルし, その内容を『最後にキルした矩形
     領域』として保存する（`kill-rectangle'）.
`C-x r d'
     矩形リージョンのテキストを削除する（`delete-rectangle'）.
`C-x r y'
     最後にキルした矩形領域をポイント位置を左上隅としてヤンクする
     （`yank-rectangle'）.
`C-x r o'
     空白で埋めた矩形リージョンを挿入する（`open-rectangle'）.  矩形リー
     ジョンの直前の内容は右に押しやられる.
`M-x clear-rectangle'
     矩形リージョンのすべてのテキストを空白で置き換えて, 内容をクリア
     する.
`M-x delete-whitespace-rectangle'
     指定した矩形領域の各行において, 矩形領域の左端から白文字を削除す
     る.
`C-x r t STRING RET'
     指定した矩形領域の各行にSTRINGを挿入する（`string-rectangle'）.

矩形操作は2種類に分類できます.  矩形領域を削除したり挿入したりするコマ
ンドと, 空白の矩形領域を扱うコマンドです.

矩形領域内のテキストを消すには, 2つの方法があります.  テキストを捨てる
（削除する）か, 『最後にキルした』矩形領域として保存するかです.  これ
らの機能を実現するコマンドは, `C-x r d'（`delete-rectangle'）と`C-x r
k'（`kill-rectangle'）です.  どちらも, 矩形領域の内側にある各行の部分
を削除し, それより右側にテキストがあれば, 隙間を埋めるようにそれらを左
へ移動します.

矩形領域の『キル』は普通の意味でのキルではない, ということに注意してく
ださい.  矩形領域はキルリングには保存されませんが, 最後にキルした矩形
領域を1つだけ記録できる特別な場所に保存されます.  というのは, 矩形領域
をヤンクすることは, 線形のテキストのヤンクとは大きく異なり, 特別なヤン
クコマンドが必要だったり, ヤンクしたテキストの入れ換え操作が意味をなさ
なかったりするからです.

最後にキルした矩形領域をヤンクするには, `C-x r y'（`yank-rectangle'）
と打ちます.  矩形領域のヤンクは矩形領域のキルの逆です.  ポイントは矩形
領域の左上隅の位置を指定します.  その場所には矩形領域の1行目が挿入され, 
矩形領域の2行目はそのつぎの行にというように挿入されます.  影響される行
数は, 保存されている矩形領域の高さで決まります.

矩形領域のキルとヤンクを使うと, 1段組みの一覧表を2段組の一覧表に変換で
きます.  一覧表の後半を矩形領域としてキルして, 一覧表の第1行の隣にヤン
クすればよいのです.

また, `C-x r r R'や`C-x r i R'を使えば, 矩形領域をレジスタにコピーした
り, レジスタから矩形領域をコピーしたりできます.  *Note Rectangle
Registers: RegRect.

空白の矩形領域を作るコマンドは2つあります.  `M-x clear-rectangle'は既
存のテキストを空白で置き換え, `C-x r o'（`open-rectangle'）は空白の矩
形領域を挿入します.  矩形領域をクリアすることは, 矩形領域を削除してか
ら同じ大きさの空白の矩形領域を挿入するのと同じことです.

コマンド`M-x delete-whitespace-rectangle'は, 特定の桁位置から始まる横
に並んだ白文字を削除します.  矩形領域内の各行に作用し, 桁位置は矩形領
域の左端です.  矩形領域の右端はこのコマンドには関係ありません.

コマンド`C-x r t'（`M-x string-rectangle'）は, 矩形領域を指定した文字
列で置き換えます.  文字列の幅は, 矩形領域の幅と同じである必要はありま
せん.  文字列の幅が足りなければ, 矩形領域の右側にあるテキストは左へ移
動します.  文字列の幅が広ければ, 矩形領域の右側にあるテキストは右へ移
動します.


File: emacs-ja, Node: Registers, Next: Display, Prev: Rectangles, Up: Top

レジスタ
********

Emacsの"レジスタ"（registers）は, あとで使うためにテキストやポイント位
置を保存するための場所です.  テキストや矩形領域をレジスタにいったん保
存すれば, 何度でもバッファにコピーできます.  また, レジスタに保存した
位置には何度でもポイントを移動できます.

各レジスタには1文字の名前が付いています.  レジスタには, テキストの一部, 
矩形領域, 位置, ウィンドウの構成情報, ファイル名を保存できますが, 1度
にはそのうちの1つしか保存できません.  レジスタに保存した内容は, そのレ
ジスタに他のものを保存するまでは保持され続けます.  レジスタRに何が入っ
ているか調べるには, `M-x view-register'を使います.

`M-x view-register RET R'
     レジスタRの内容を表示する.

* Menu:

* Position: RegPos.           Saving positions in registers.
* Text: RegText.              Saving text in registers.
* Rectangle: RegRect.         Saving rectangles in registers.
* Configurations: RegConfig.  Saving window configurations in registers.
* Files: RegFiles.            File names in registers.
* Numbers: RegNumbers.        Numbers in registers.
* Bookmarks::                 Bookmarks are like registers, but persistent.



File: emacs-ja, Node: RegPos, Next: RegText, Prev: Registers, Up: Registers

レジスタに位置を保存する
========================

位置を保存するとは, あとで戻ってこられるようにバッファ中の位置を記録す
ることです.  保存した位置に移動すると, そのバッファに切り替えてからポ
イントをその位置に移動します.

`C-x r SPC R'
     ポイント位置をレジスタRに保存する（`point-to-register'）.
`C-x r j R'
     レジスタRに保存した位置に移動する（`jump-to-register'）.

ポイントの現在位置をレジスタに保存するには, 名前Rを選んでから, `C-x r
SPC R'と打ちます.  他のものを保存するまで, レジスタRはこうして保存した
位置を保持し続けます.

コマンド`C-x r j R'は, レジスタRに記録した位置にポイントを移動します. 
レジスタは変わらず, 同じ位置を記録し続けます.  何度でも保存した位置に
移動できます.

`C-x r j'を使って保存位置に移動しようとしたとき, その対象となるバッファ
がすでに消去されていた場合には, `C-x r j'は同じファイルを訪問するバッ
ファを作成し直そうとします.  もちろん, これはファイルを訪問したバッファ
に対してのみ働きます.



File: emacs-ja, Node: RegText, Next: RegRect, Prev: RegPos, Up: Registers

レジスタにテキストを保存する
============================

テキストの同じ部分のコピーを頻繁に挿入する場合, キルリングからヤンクす
るのは便利ではないでしょう.  というのは, キルするごとに, 必要な部分が
リングの下方に徐々に移動してしまうからです.  別の手段としては, レジス
タにテキストを保存しておき, レジスタから取り込むという方法があります.

`C-x r s R'
     レジスタRにリージョンをコピーする（`copy-to-register'）.
`C-x r i R'
     レジスタRからテキストを挿入する（`insert-register'）.

`C-x r s R'は, リージョンのテキストのコピーをRという名前のレジスタに保
存します.  `C-x r s R'に数引数を指定すると, 保存すると同時にバッファか
らテキストを削除します.

`C-x r i R'はレジスタRからテキストをバッファに挿入します.  通常, テキ
ストの直前にポイントを置き, 直後にマークを置きます.  しかし, 数引数
（`C-u'）を指定すると, テキストの直後にポイントを置き, 直前にマークを
置きます.



File: emacs-ja, Node: RegRect, Next: RegConfig, Prev: RegText, Up: Registers

レジスタに矩形領域を保存する
============================

レジスタには, 連続したテキスト以外にも, 矩形領域を保持できます.  矩形
領域は, 文字列のリストとして表されます.  バッファ内での矩形領域の指定
方法に関する基礎情報については, *Note Rectangles::.

`C-x r r R'
     矩形領域をレジスタRにコピーする（`copy-rectangle-to-register'）. 
     数引数を指定すると, コピー後に矩形領域を削除する.
`C-x r i R'
     レジスタRに保存した矩形領域（が存在すればそれ）を挿入する
     （`insert-register'）.

`C-x r i R'コマンドは, レジスタにテキストが入っていれば, そのテキスト
の文字列を挿入しますし, 矩形領域があれば矩形領域を挿入します.

コマンド`sort-columns'も参照してください.  このコマンドは矩形領域をソー
トすると考えられます.  *Note Sorting::.



File: emacs-ja, Node: RegConfig, Next: RegFiles, Prev: RegRect, Up: Registers

レジスタにウィンドウ構成を保存する
==================================

選択したフレームのウィンドウ構成をレジスタに保存したり, すべてのフレー
ムのすべてのウィンドウ構成を保存したりできて, しかも, あとでその構成に
戻せます.

`C-x r w R'
     選択したフレームのウィンドウの状態をレジスタRに保存する
     （`window-configuration-to-register'）.
`C-x r f R'
     全フレームの状態を, 各フレームのすべてのウィンドウを含めて, レジ
     スタRに保存する（`frame-configuration-to-register'）.

ウィンドウやフレームの構成をもとに戻すには, `C-x r j R'を使います.  こ
れは, カーソル位置を復元するコマンドと同じです.  フレームの構成を復元
すると, 構成情報に含まれていない既存のフレームは隠れた状態になります. 
これらのフレームを削除したければ, `C-u C-x r j R'を使います.



File: emacs-ja, Node: RegNumbers, Next: Bookmarks, Prev: RegFiles, Up: Registers

レジスタに数値を保持する
========================

レジスタに数値を保存しておき, 数値を10進数でバッファに挿入してから数値
を増やすコマンドがあります.  これらのコマンドは, キーボードマクロで役
立ちます（*Note Keyboard Macros::）.

`C-u NUMBER C-x r n REG'
     数値NUMBERをレジスタREGに保存する（`number-to-register'）.
`C-u NUMBER C-x r + REG'
     レジスタREG内の数値をNUMBERだけ増やす（`increment-register'）.
`C-x r g REG'
     レジスタREGの数値をバッファに挿入する.

`C-x r g'は, レジスタの数値以外の内容をバッファに挿入するために使うコ
マンドと同じです.



File: emacs-ja, Node: RegFiles, Next: RegNumbers, Prev: RegConfig, Up: Registers

レジスタにファイル名を保持する
==============================

特定のファイル名を頻繁に訪問する場合には, これらの名前をレジスタに置い
ておくと, より簡単にファイルを訪問できます.  ファイル名をレジスタに置
くLispコードをつぎに示します.

     (set-register ?R '(file . NAME))

たとえば,

     (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))

とすると, 上に示したファイル名をレジスタ`z'に保存します.

レジスタRに入れた名前のファイルを訪問するには, `C-x r j R'と打ちます. 
（このコマンドは, 保存位置に移動したりフレーム構成を復元するために使う
コマンドと同じ. ）



File: emacs-ja, Node: Bookmarks, Next: Display, Prev: RegNumbers, Up: Registers

ブックマーク
============

"ブックマーク"（bookmarks）とは, 移動先の位置を記録しておくためのレジ
スタのようなものです.  レジスタと違って, 長い名前を付けることができて, 
自動的につぎのEmacsセッションに引き継がれます.  ブックマークの典型的な
使い方は, 各ファイルの『どこを読んでいるか』を記録しておくことです.

`C-x r m RET'
     訪問先のファイルのポイント位置にブックマークを設定する.

`C-x r m BOOKMARK RET'
     ポイント位置に, BOOKMARKという名前のブックマークを設定する
     （`bookmark-set'）.

`C-x r b BOOKMARK RET'
     名前がBOOKMARKであるブックマークに移動する（`bookmark-jump'）.

`C-x r l'
     すべてのブックマークを一覧表示する（`list-bookmarks'）.

`M-x bookmark-save'
     現在のすべてのブックマークの値をデフォルトのブックマークファイル
     に保存する.

ブックマークの典型的な使い方は, 各ファイルごとに現在のポイント位置を保
存しておくことです.  ブックマークを設定するコマンド`C-x r m'は, 訪問先
のファイルの名前をブックマーク名のデフォルトとして使います.  ブックマー
クが指すファイルをもとにブックマークの名前を付ければ, `C-x r b'で任意
のファイルを再訪問して, 同時にブックマーク位置に移動するという操作を楽
に行えます.

設定したすべてのブックマークの一覧を別のバッファに表示するには, `C-x r
l'（`list-bookmarks'）と打ちます.  そのバッファに切り替えれば, ブック
マークの定義を編集したり, ブックマークに注記を付けたりできます.  この
バッファで使える特別な編集コマンドについての情報を得るには, このバッファ
で`C-h m'と打ちます.

内容を変更したブックマークがある場合, Emacsを終了する時点で, Emacsはブッ
クマークの値をデフォルトのブックマークファイル`~/.emacs.bmk'に保存する
かどうか聞いてきます.  `M-x bookmark-save'コマンドを使っても, 変更した
ブックマークをいつでも保存できます.  ブックマークコマンドは, 個人のデ
フォルトのブックマークファイルを自動的に読み込みます.  これらの保存と
読み込みによって, ブックマークの内容をつぎのEmacsセッションに引き継げ
るのです.

変数`bookmark-save-flag'に1を設定しておくと, ブックマークを設定する各
コマンドは, ブックマークの保存も行います.  こうしておけば, Emacsがクラッ
シュした場合でも, ブックマークデータを失わなくてすみます.  （この変数
の値が数値であれば, ブックマークを何回変更したら保存するという意味. ）

ブックマークの位置情報は, その周辺の文脈情報と一緒に保存されるので, ファ
イルが少し変更されていたとしても, `bookmark-jump'は正しい位置をみつけ
だせます.  変数`bookmark-search-size'で, ブックマーク位置の前後何文字
分の内容を保存するかを指定します.

ブックマークを用いるコマンドには, 以下のものもあります.

`M-x bookmark-load RET FILENAME RET'
     ブックマークデータのリストを収めたFILENAMEという名前のファイルを
     ロードする.  デフォルトのブックマークファイル以外のブックマークデー
     タを収めたファイルに対しても, コマンド`bookmark-write'と同じく, 
     このコマンドを使える.

`M-x bookmark-write RET FILENAME RET'
     現在設定されているブックマークデータをファイルFILENAMEに保存する.

`M-x bookmark-delete RET BOOKMARK RET'
     BOOKMARKという名前のブックマークを削除する.

`M-x bookmark-insert-location RET BOOKMARK RET'
     ブックマークBOOKMARKが指しているファイルの名前をバッファに挿入す
     る.

`M-x bookmark-insert RET BOOKMARK RET'
     ブックマークBOOKMARKが指すファイルの*内容*をバッファに挿入する.


File: emacs-ja, Node: Display, Next: Search, Prev: Registers, Up: Top

画面の制御
**********

大きなバッファの一部しかウィンドウには収まりませんから, Emacsは必要そ
うな部分を表示しようとします.  画面制御コマンドを使って, テキストのど
の部分を表示したいのか, また, どのように表示するか指定できます.

* Menu:

* Scrolling::	           Moving text up and down in a window.
* Horizontal Scrolling::   Moving text left and right in a window.
* Follow Mode::            Follow mode lets two windows scroll as one.
* Selective Display::      Hiding lines with lots of indentation.
* Optional Mode Line::     Optional mode line display features.
* Text Display::           How text characters are normally displayed.
* Display Vars::           Information on variables for customizing display.



File: emacs-ja, Node: Scrolling, Next: Horizontal Scrolling, Prev: Display, Up: Display

スクロール
==========

バッファを表示しているウィンドウに全部を表示するには大きすぎるテキスト
が入っているバッファでは, Emacsはテキストの連続する一部分を表示します. 
表示する部分にはつねにポイントが入っています.

"スクロール"（scroll）とは, ウィンドウ内でテキストを上下に動かして, テ
キストの異なる部分を表示することです.  前向きのスクロールでは, テキス
トを上へ移動して, 新たなテキストがウィンドウの最下端から現れます.  後
向きのスクロールでは, テキストを下に移動して, 新たなテキストがウィンド
ウの最上端から現れます.

ポイントをウィンドウの下端や上端を超えて移動すると, 自動的にスクロール
します.  本節で紹介するコマンドを使って, 明示的にスクロールすることも
できます.

`C-l'
     画面をクリアして再表示し, 選択されたウィンドウではポイントが縦方
     向の中央に位置するようにスクロールする（`recenter'）
`C-v'
     （ウィンドウ1面分か指定した行数だけ）前向きにスクロールする
     （`scroll-up'）.
`NEXT'
     同様に前向きにスクロールする.
`M-v'
     後向きにスクロールする（`scroll-down'）.
`PRIOR'
     同じく後向きにスクロールする.
`ARG C-l'
     ポイントがARG行目にくるようにスクロールする（`recenter'）.
`C-M-l'
     有益な情報が画面上にくるように発見的方法でスクロールする
     （`reposition-window'）.

もっとも基本的なスクロールコマンドは, 引数を指定しない`C-l'
（`recenter'）です.  このコマンドは, 画面全体をクリアして, すべてのウィ
ンドウを再表示します.  さらに, ポイントがウィンドウの中央の行に位置す
るように, 選択されているウィンドウをスクロールします.

スクロールコマンド`C-v'と`M-v'は, ウィンドウ内の全テキストを上下に何行
か移動します.  `C-v'（`scroll-up'）に引数を指定すると, `C-l'と同じよう
にテキストとポイントを一緒に上へ移動して, 追加分（引数分）の行をウィン
ドウの下部に表示します.  `C-v'に負の引数を指定した場合は, ウィンドウの
上端に追加分の行を表示します.  `M-v'（`scroll-down'）は`C-v'に似ていま
すが, スクロール方向が逆です.  ファンクションキーのNEXTとPRIORは,
`C-v'と`M-v'に等価です.

スクロールコマンドの名前は, ウィンドウ内でテキストを動かす向きに基づい
ています.  したがって, 前向きにスクロールするコマンドは, 画面上ではテ
キストを上へ移動するため, `scroll-up'と呼ばれます.

一度にウィンドウ1面分のバッファを読んでいくには, 引数を指定せずに`C-v'
を使います.  ウィンドウの下端2行を上端に持っていき, それに続けてこれま
で表示されていなかったほぼウィンドウ1面分の行を表示します.  ポイントが
ウィンドウの上端より上に出てしまう場合には, ポイントはウィンドウの新た
な上端の行に移動します.  引数を指定しない`M-v'も同様に, テキストを重複
させながら, 後向きに移動します.  `C-v'や`M-v'で重複させる行数は, 変数
`next-screen-context-lines'で制御します.  デフォルトでは2です.

画面上でのポイント位置を保ったまま1画面分のスクロールを行うコマンドを
好むユーザーもいます.  このようにするには, 変数
`scroll-preserve-screen-position'に`nil'以外を設定します.  このモード
は, 1画面分ずつスクロールしながらファイルを閲覧するような場合に便利で
す.  スクロールを始めた画面に戻ると, ポイントは開始時の行位置に戻りま
す.  しかし, つぎの画面に移動して, そこに表示されているテキストにポイ
ントを移動するような使い方にはむいていません.

スクロールのもう1つの方法は, 数引数を指定した`C-l'を使うことです.  引
数を指定すると, `C-l'は画面をクリアしません.  選択されているウィンドウ
だけをスクロールします.  正の引数Nを指定すると, ポイント位置が上端から
N行目にくるように, テキストの位置を変更します.  引数として0を指定する
と, ポイント位置は最上端の行になります.  ポイントがテキストに対して動
くわけではなくて, テキストとポイントは一緒に画面上を動きます.  `C-l'に
負の引数を指定すると, ポイントはウィンドウの下端から指定行数にきます. 
たとえば, `C-u - 1 C-l'とするとポイントは最下行になり, `C-u - 5 C-l'と
すれば下から5行目にポイントがきます.  `C-u C-l'のように`C-u'だけを引数
に指定すると, ポイントが画面中央にくるようにスクロールします.

`C-M-l'コマンド（`reposition-window'）は, 有益な情報を画面上に持ってく
るようにように設計された発見的手法で, カレントウィンドウをスクロールし
ます.  たとえば, Lispファイルでは, このコマンドは, 可能であれば現在の
関数定義（defun）全体を画面上にもってこようとします.

表示の際, ポイントがテキストの表示部分から飛び出してしまうと, 自動的に
スクロールします.  通常, この自動スクロールでは, ポイントがウィンドウ
縦方向の中央に位置するように画面を移動します.  しかし,
`scroll-conservatively'に小さな数Nを設定しておくと, ポイントが画面から
少しだけ（N行未満）はみだすと, Emacsはポイントを画面内に戻すのに必要な
分だけスクロールします.  デフォルトでは, `scroll-conservatively'は0で
す.

変数`scroll-margin'は, ポイントをウィンドウの上端や下端にどれだけ近づ
けられるかを制限します.  その値は画面上での行数です.  ポイントがウィン
ドウの上端や下端からその行数以内にくると, Emacsはウィンドウを中央に位
置付けし直します.  デフォルトでは, `scroll-margin'は0です.



File: emacs-ja, Node: Horizontal Scrolling, Next: Follow Mode, Prev: Scrolling, Up: Display

水平スクロール
==============

"水平スクロール"（horizontal scrolling）とは, すべての行をウィンドウ内
で横方向に動かすことです.  これにより, 左端近くのテキストは表示されな
くなります.

`C-x <'
     カレントウィンドウのテキストを左にスクロールする（`scroll-left'）.
`C-x >'
     右にスクロールする（`scroll-right'）.

ウィンドウが水平方向にスクロールされているときには, テキスト行を継続
（*Note Continuation Lines::）しないで切り捨てます.  テキストの左側を
切り捨てているときは最初の桁に`$'を表示し, 右側を切り捨てているときに
は最後の桁に`$'を表示します.

コマンド`C-x <'（`scroll-left'）は, 選択されたウィンドウを引数Nの桁数
だけ左にスクロールします.  各行の最初の部分はウィンドウの左端から出て
しまいます.  引数を指定しないと, ほぼウィンドウ幅（正確には2桁少ない桁
数）だけスクロールします.

`C-x >'（`scroll-right'）は, 同様に右にスクロールします. 
ウィンドウが（各行がウィンドウの左端から始まっている）通常の表示をしていると, 
それ以上はスクロールできません. 
スクロールさせようとしても何も起こりません. 
つまり, `C-x >'に与える引数を正確に計算する必要はないのです. 
十分に大きな引数を指定すれば, 通常の表示に戻せます. 

水平スクロール（hscroll）モードをオンにすると, 自動的に水平スクロール
を行います.  このモードがオンであると, ポイントが左右端から離れすぎな
い場所に見えるようにEmacsが水平方向にウィンドウをスクロールします.  こ
のモードのオン／オフを切り替えるコマンドは, `M-x hscroll-mode'です.



File: emacs-ja, Node: Follow Mode, Next: Selective Display, Prev: Horizontal Scrolling, Up: Display

追従モード
==========

"追従（follow）モード"は, 同じバッファを表示している2つのウィンドウを,
1つの『仮想ウィンドウ』としてスクロールするマイナモードです.  追従
（follow）モードを使うには, ウィンドウが1つだけのフレームに移動して,
`C-x 3'を使って左右に並んだ2つのウィンドウに分割してから, `M-x
follow-mode'と打ちます.  これ以後, いずれのウィンドウのバッファでも編
集できますし, どちらをスクロールしてもかまいません.  もう一方のウィン
ドウは他方に追従します.

追従（follow）モードをオフにするには, もう一度`M-x follow-mode'を打ち
ます.



File: emacs-ja, Node: Selective Display, Next: Optional Mode Line, Prev: Follow Mode, Up: Display

選択的な表示
============

Emacsには, （指定した）桁数以上字下げしてある行を隠す機能があります. 
プログラムの一部を概観するのにこの機能を使えます.

行を隠すには, 数引数Nを指定して`C-x $' （`set-selective-display'）と打
ちます.  これにより, N桁以上字下げしてある行は画面から消えます.  1行以
上の不可視行に先行する可視行の末尾には, 3つのドット（`...'）を表示しま
す.  この印が不可視行の存在を示す唯一のものです.

コマンド`C-n'や`C-p'は, 不可視行が存在しないかのように不可視行を飛び越
えて移動します.

不可視行は依然としてバッファ内に存在しています.  たいていの編集コマン
ドはそれらを通常と同じように扱うので, 隠蔽されたテキスト内にポイントを
移動してしまうことも起こりえます.  このような場合, カーソルは先行する
行の末尾の3つのドットの直後に表示されます.  ポイントが可視行の行末の改
行文字の直前にあるときには, 3つのドットの直前にカーソルが現れます.

すべての行をふたたび表示するには, 引数を指定せずに`C-x $'を打ちます.

変数`selective-display-ellipses'に`nil'を設定すると, 不可視行に先行す
る可視行の末尾には3つのドットを表示しなくなります.  すると, 不可視行の
存在を示すものは何もありません.  この変数を設定すると, 自動的にローカ
ルになります.



File: emacs-ja, Node: Optional Mode Line, Next: Text Display, Prev: Selective Display, Up: Display

モード行の付加機能
==================

行番号（line-number）モードがオンであると, ポイントの現在の行番号をモー
ド行に表示します.  このモードのオン／オフを切り替えるには, コマンド
`M-x line-number-mode'を使います.  通常はオンです.  行番号は, バッファ
の百分率を示すPOSのまえに, 行番号であること示す文字`L'とともに表示され
ます.  マイナモードやこのコマンドの使用方法について詳しくは, *Note
Minor Modes::.

バッファが非常に大きい（`line-number-display-limit'の値以上に大きい）
場合には, この行番号を表示しません.  計算が非常に遅くなるので, バッファ
が大きい場合にはEmacsは行番号を計算しません.  バッファをナロイング
（*Note Narrowing::）してある場合, 表示される行番号はバッファの参照可
能な部分に対するものです.

桁番号（column-number）モードをオンにすると, 現在の桁番号も表示できま
す.  このモードでは, `C'に続けて現在の桁番号を表示します.  このモード
のオン／オフを切り替えるには, `M-x column-number-mode'と打ちます.

Emcasでは, すべてのモード行に, 時刻とシステムの負荷状況を表示できます. 
この機能をオンにするには, `M-x display-time'と打ちます.  このときモー
ド行に追加される情報は, 通常は, バッファ名のあと, 括弧で囲まれたモード
名のまえに表示されます.  その表示はつぎのようになります.

     HH:MMpm L.LL

ここで, HHとMMは, 時分を表し, つねに`am'か`pm'が続きます.  L.LLは, シ
ステム全体で実行中のプロセスの個数の最近の平均数です.  （オペレーティ
ングシステムが情報を提供しなければ, いくつかの内容が消えていることもあ
る. ）時刻を24時間表示したければ, 変数`display-time-24hr-format'に`t'
を設定します.

負荷レベル表示に続く語`Mail'は, 未読のメイルがある場合に表示されます.



File: emacs-ja, Node: Text Display, Next: Display Vars, Prev: Optional Mode Line, Up: Display

テキストの表示方法
==================

Emacsバッファ内のASCII印字文字（8進コードで040から0176）は, それぞれの
図形で表示されます.  非ASCIIのマルチバイトの印字文字（8進コード0400以
上）も同様です.

ASCIIコントロール文字の中には, 特別な方法で表示されるものもあります. 
改行文字（8進コード012）は, 新たな行を始めるという形で表示されます. 
タブ文字（8進コード011）は, つぎのタブストップ位置（通常は8桁ごと）ま
で移動するという形で表示されます.

その他のASCIIコントロール文字は, 通常, カレット（`^'）に続けてコントロー
ル変種でない文字で表示されます.  つまり, control-Aは`^A'のように表示さ
れます.

0200から0377までの非ASCII文字は, 8進のエスケープシーケンスで表示されま
す.  たとえば, 文字コード0243（8進）は, `\243'と表示されます.  しかし, 
ヨーロッパ向けの表示をオンにしていると, これらのたいていの文字は非
ASCII印字文字として扱われ, （端末がこれらの文字を表示できると仮定して）
それぞれの図形で表示されます.  *Note Single-Byte European Support::.



File: emacs-ja, Node: Display Vars, Next: Search, Prev: Text Display, Up: Display

表示を制御する変数
==================

本節は, カスタマイズに関する情報のみです.  初心者の方は読み飛ばしてく
ださい.

変数`mode-line-inverse-video'は, （端末が反転表示を扱えると仮定して）
モード行を反転表示するかどうかを制御します.  `nil'は反転表示しないこと
を意味します.  *Note Mode Line::.  `modeline'フェイスに前景色を指定し
ていて, しかも, `mode-line-inverse-video'が`nil'以外であれば,
`modeline'フェイスのデフォルトの背景色は通常の前景色です.  *Note
Faces::.

変数`inverse-video'が`nil'以外である場合, Emacsは画面上のすべての行を
通常の状態から反転表示します.

変数`visible-bell'が`nil'以外の場合, Emacsは, 通常は端末のベルを鳴らす
場面では, 画面全体を点滅します.  端末に画面を点滅する機能がなければ, 
この変数は何の効果もありません.

Emacsを休止したあとで再開した場合, 通常Emacsは画面をクリアし, 画面全体
を再表示します.  ページメモリを複数個備えた端末では, termcapの定義を変
更して, （それぞれ, Emacsを起動するときと抜けるときに端末に出力される）
文字列`ti'と`te'でページメモリを切り替えて, 1ページをEmacs用に使い, も
う1ページを他の出力用に使うようにできます.  そして, 変数
`no-redraw-on-reenter'に`nil'以外を設定します.  こうすると, Emacsは, 
再開時には最後に出力した内容が画面ページに入っているものと仮定します.

変数`echo-keystrokes'は, 複数個の文字キーのエコーを制御します.  設定す
る値は, エコーを開始するまでの待機時間の秒数です.  ゼロを指定するとエ
コーしません.  *Note Echo Area::.

変数`ctl-arrow'に`nil'を設定すると, 改行とタブを除いて, バッファ内のコ
ントロール文字を8進のエスケープシーケンスで表示します.  変数
`ctl-arrow'の値を変更すると, この変数はカレントバッファにローカルにな
ります.  それまでは, デフォルトの値が使われます.  デフォルトの初期値は
`t'です.  *Note 表示テーブル: (elisp-ja)Display Tables.。

通常, バッファ内のタブ文字は, つぎのタブストップ位置までの空白として表
示され, タブストップは8個分の空白と同じ間隔です.  タブ1個あたりの空白
の文字数は, 変数`tab-width'で制御します.  この変数も`ctl-arrow'と同様
に, 変更するとバッファにローカルになります.  バッファ内のタブ文字をど
のように表示するかと, コマンドとしてのTABの定義とは無関係であることに
注意してください.  変数`tab-width'の値は1以上1000以下の整数である必要
があります.

変数`truncate-lines'に`nil'以外を設定すると, テキストの各行は表示上は
画面の1行を占有します.  テキスト行が長すぎる場合は, 画面に収まる範囲だ
けを表示します.  一方, `truncate-lines'に`nil'を設定すると, 長いテキス
ト行は, 画面上では2行以上にわたってテキスト行の表示に必要なだけの行数
で表示されます.  *Note Continuation Lines::.  変数`truncate-lines'の値
を変更すると, カレントバッファにローカルになります.  それまでは, デフォ
ルトが使われます.  デフォルトの初期値は`nil'です.

変数`truncate-partial-width-windows'に`nil'以外を設定すると, 画面やフ
レームの幅に満たないウィンドウでは, テキストの表示方法は
`truncate-lines'の値とは無関係に, 継続行ではなく切り捨てて表示します. 
左右に並べたウィンドウに関しては, *Note Split Window::.  *Note Emacsの
画面表示: (elisp-ja)Display.も参照してください.

変数`baud-rate'は, Emacsにとっての端末の出力速度を保持します.  この変
数の値を設定したとしても, 実際のデータ転送速度を変更できるわけではなく, 
この値はパディングの計算などに用いられます.  さらに, ウィンドウシステ
ムを使用している場合であっても, 画面の一部をスクロールするのか, 再表示
するのかの決定にも影響します.  （ウィンドウシステムには正しい『出力速
度』がないにしても, スクロール／再表示を調整できるようにこのように設計
してある. ）

どんな文字コードの表示方法も, 表示テーブルを用いてカスタマイズできます.
*Note 表示テーブル: (elisp-ja)Display Tables.。


File: emacs-ja, Node: Search, Next: Fixit, Prev: Display, Up: Top

探索と置換
**********

他のエディタと同様に, Emacsにも文字列を探索するコマンドがあります.  主
な探索コマンドが"インクリメンタル"（incremental）であるという点で, 普
通とは違います.  探索したい文字列全体を入力し終えなくても, 探索を始め
ます.  他のエディタの探索コマンドのように, インクリメンタルでない探索
コマンドもあります.

指定した文字列の出現すべてを探し出して別の文字列に置換する, 普通の置換
コマンド`replace-string'に加えて, Emacsにはより高級な, 出現箇所をみつ
けるたびに置換するかどうか対話的に尋ねる問い合わせ型置換コマンド
`query-replace'もあります.

* Menu:

* Incremental Search::	   Search happens as you type the string.
* Nonincremental Search::  Specify entire string and then search.
* Word Search::		   Search for sequence of words.
* Regexp Search::	   Search for match for a regexp.
* Regexps::		   Syntax of regular expressions.
* Search Case::		   To ignore case while searching, or not.
* Replace::		   Search, and replace some or all matches.
* Other Repeating Search:: Operating on all matches for some regexp.



File: emacs-ja, Node: Incremental Search, Next: Nonincremental Search, Prev: Search, Up: Search

インクリメンタルサーチ
======================

インクリメンタルサーチでは, 探索文字列の最初の文字を打つとただちに探索
を開始します.  探索文字列を入力するたびに, Emacsは（それまでに入力した）
文字列がどこでみつかるか表示します.  目的の箇所を特定するのに十分なだ
けの文字を打ってしまえば, そこで終りにできます.  つぎに何をするかにも
よりますが, RETで探索を陽に終了する必要がある場合もあります.

`C-s'
     前向きにインクリメンタルサーチする（`isearch-forward'）.
`C-r'
     後向きにインクリメンタルサーチする（`isearch-backward'）.

`C-s'はインクリメンタルサーチを始めます.  `C-s'はキーボードから文字を
読み取り, 打った文字が最初に現れる位置までカーソルを移動します.  たと
えば, `C-s'に続けて`F'を打つと, カーソルは最初に現れる`F'の直後に移動
します.  さらに`O'を打つと, カーソルは最初に現れる`FO'の直後に移動しま
す.  さらに`O'を打つと, 探索を開始した場所以降で最初に現れる`FOO'の直
後にカーソルが移動します.  各段階において, 反転表示できる端末では, 探
索文字列に一致するバッファ内のテキストを強調表示します.  また, 各段階
において, エコー領域に表示した現在の探索文字列も更新します.

探索する文字列を打ちまちがえたときには, DELで取り消せます.  DELを1回押
すごとに, 探索文字列の最後の文字を取り消していきます.  ただし, Emacsが
つぎの入力文字を受け付け可能になるまで, この取り消し操作は実行できませ
ん.  つまり, 取り消そうと思っている文字をみつけるか, もしくはみつけら
れなかったことが確定する必要があります.  それまで待てないなら, 以下に
説明するように`C-g'を使ってください.

目的の箇所まで移動できたら, RETを打ちます.  すると, 探索を終了しカーソ
ルはその箇所に留まります.  また, 探索に関係ないコマンドを打っても, 探
索を終了し, そのコマンドを実行します.  したがって, `C-a'と打てば, 探索
を終了し, カーソルを行頭に移動します.  RETが必要な場面は, つぎに入力し
たいコマンドが, 印字文字, DEL, RET, および, 探索で特別な意味を持つその
他の各種コントロール文字（`C-q', `C-w', `C-r', `C-s', `C-y', `M-y',
`M-r', `M-s'）である場合だけです.

`FOO'を探してそれがみつかった場合でも, 予期していた`FOO'ではないことも
あるでしょう.  最初の`FOO'以降に, 2つめの`FOO'があることを忘れていたよ
うな場合です.  このようなときには, さらに`C-s'を打てば, 探索文字列のつ
ぎの出現箇所に移動できます.  この操作は何度でも繰り返せます.  行き過ぎ
てしまったときには, DELで`C-s'の操作を取り消せます.

探索を終了したあとでも, 単に`C-s C-s'と打てば, ふたたび同じ文字列を探
索できます.  つまり, 最初の`C-s'がインクリメンタルサーチを起動して, つ
ぎの`C-s'が『再探索』を意味します.

以前に探索した文字列を再利用するには, "探索リング"（search ring）を使
います.  コマンド`M-p'と`M-n'でリング内を移動して, 再利用する文字列を
取り出します.  これらのコマンドは, 探索リング内の選択した要素をミニバッ
ファに置きますから, 編集することも可能です.  `C-s'や`C-r'を打てば, 文
字列の編集を終了して探索を開始できます.

探している文字列がまったくみつからなかった場合には, エコー領域に
`Failing I-Search'と表示されます.  カーソルは, 指定した文字列に可能な
限り一致する箇所の直後にあります.  たとえば, `FOOT'を探索しようとした
のに`FOOT'がなければ, カーソルは`FOOL'の`FOO'の直後にあります.  この時
点でできることはいくつかあります.  文字列を打ちまちがえたのならば, そ
れを消去して訂正します.  その箇所でよいのなら, 『探索したものを受理す
る』ために, RETか他のEmacsコマンドを打ちます.  あるいは, `C-g'を打てば, 
探索文字列からみつけられなかった文字（`FOOT'中の`T'）を取り除き, みつ
けた文字列（`FOOT'中の`FOO'）はそのままにしておくこともできます.  ここ
で, さらに`C-g'を打つと, 探索全体を取り止めて, 探索を開始した位置に戻
ります.

探索文字列に大文字を指定すると, 大文字小文字を区別（case-sensitive）し
て探索します.  探索文字列から大文字を削除すると, この効果は消えます.
*Note Search Case::.

探索に失敗したときに, さらに`C-s'を打って探索の続行を指示すると, バッ
ファの先頭からもう一度探索し始めます.  後向きの探索に失敗したときに再
度`C-r'を打つと, バッファの末尾から探索を再開します.  これらの操作は"
巻き直し"（wrapping around）と呼ばれます.  巻き直しが起こると, 探索の
プロンプトには`Wrapped'が表示されます.  もともとの探索開始位置を通過し
てなお探索を続けると, 表示が`Overwrapped'に変わります.  これは, 探索文
字列にすでに一度一致した箇所を再度探索していることを意味します.

『中断』文字`C-g'は, 探索中には特別な意味があり, その機能は探索の状態
に依存します.  指定したものがみつかり入力待ちの状態にあると, `C-g'は探
索全体を取り消します.  カーソルは探索開始位置に戻ります.  Emacsが探索
中であったり探索に失敗したために, 探索文字列内に未発見の文字がある場合
に`C-g'を打つと, 探索文字列から未発見の文字を消去します.  そうすると, 
これで探索が成功したことになるので, 入力待ちになります.  続けて`C-g'を
打つと, 探索全体を取り消します.

改行を探索するには, `C-j'を打ちます.  コントロールSや改行などのコント
ロール文字を探索するには, まず`C-q'を打ってクォートする必要があります.
`C-q'のこの機能は, 挿入時の利用法に似ています（*Note Inserting Text::）. 
このコマンドは, あとに続く文字を, 同じ文脈における『普通の』文字と同様
に扱うようにします.  文字を8進コードで指定することもできて, `C-q'に続
けて8進数字列を入力します.

`C-r'を使えば, 後向き探索に変更できます.  ファイルのうしろのほうで探索
し始めたために探索に失敗したのであれば, これを試してください.  `C-r'を
繰り返し打つと, 後向きにさらに探索を続けます.  `C-s'は, ふたたび前向き
探索を再開します.  探索中の`C-r'はDELで取り消せます.

始めから後向きで探索するのであれば, `C-s'のかわりに`C-r'を使って探索を
始めます.  `C-r'は, 後向きに探索するコマンド`isearch-backward'を起動し
ます.  前向き探索が開始位置よりうしろにある一致箇所をみつけるのと同様
に, 後向き探索は開始位置よりまえにある一致箇所をみつけだします.

インクリメンタルサーチ中には, 文字`C-y'と`C-w'を使って, バッファから探
索文字列へテキストを取り込むことができます.  この機能は, ポイント位置
にあるテキストの出現箇所を探すときに便利です.  `C-w'は, ポイント以降の
単語を探索文字列の一部としてコピーし, ポイントをその単語の末尾に進めま
す.  探索を繰り返す意味で`C-s'を打つと, その単語を含んだ文字列を探索し
ます.  `C-y'も`C-w'に似ていますが, 現在行の残りの部分をすべて探索文字
列にコピーします.  大文字小文字を区別しない探索では, `C-y'と`C-w'はと
もに, コピーするテキストを小文字だけに変換します.

文字`M-y'は, キルリングから探索文字列にテキストをコピーします.  これに
は, ヤンクコマンド`C-y'がヤンクするのと同じテキストを用います.  *Note
Yanking::.

インクリメンタルサーチを終了すると, 探索開始前にポイントが*あった*位置
にマークを置きます.  これにより容易にその位置に戻れます.  暫定マーク
（transient-mark）モードでは, マークが不活性のときに限って, インクリメ
ンタルサーチが設定するマークも不活性です.

インクリメンタルサーチ中に用いる特別な文字をカスタマイズするには, キー
マップ`isearch-mode-map'中のバインディングを変更します.  バインディン
グ一覧は, `C-h f isearch-mode RET'を使って`isearch-mode'に関する説明文
を参照してください.


低速端末でのインクリメンタルサーチ
----------------------------------

速度の遅い端末でのインクリメンタルサーチでは, 表示時間が少なくてすむよ
うに設計された表示形式を使います.  みつけた箇所でバッファを再表示する
かわりに, 新たに1行分のウィンドウを作ってそこにみつけた行を表示します. 
この1行分のウィンドウは, 探索することでポイントが画面に表示中のテキス
トから飛び出た時点で使われます.

探索を終了すると, この1行分のウィンドウは消えます.  そして, Emacsは探
索を完了したウィンドウを再表示して, 新たなポイント位置を示します.


低速向けの表示形式を使うのは, 端末のボーレートが変数
`search-slow-speed'の値以下である場合で, その初期値は1200です.

低速向けの表示形式に使う表示用ウィンドウの行数は, 変数
`search-slow-window-lines'で制御します.  通常の値は1です.



