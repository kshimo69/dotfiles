Info file: elisp-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp-ja: (elisp-ja).	The Emacs Lisp Reference Manual(Japanese).
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり, Emacs 20.3版に対応します.

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the section entitled "GNU General Public License" is included exactly
as in the original, and provided that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the Free
Software Foundation instead of in the original English.






File: elisp-ja, Node: Change Hooks, Next: Non-ASCII Characters, Prev: Registers, Up: Text

変更フック
==========

これらのフックにより, すべてのバッファ（それらをバッファローカルにして
おけば特定のバッファ）におけるすべての変更を知るようにできます.  テキ
ストの特定部分の変更を検出する方法については, *Note Special
Properties::も参照してください.

これらのフックに使う関数において正規表現を使う場合には, マッチデータを
保存し復元する必要があります.  さもないと, それらを呼び出す編集操作と
奇妙な干渉を引き起こします.

 -- Variable: before-change-functions
     この変数は, バッファを変更するまえに呼び出すべき関数のリストを保
     持する.  各関数は2つの引数, つまり, 整数で表した変更対象の領域の
     先頭と末尾を受け取る.  変更対象のバッファはつねにカレントバッファ
     である.

 -- Variable: after-change-functions
     この変数は, バッファを変更したあとに呼び出すべき関数のリストを保
     持する.  各関数は3つの引数, つまり, 変更されたばかりの領域の先頭
     と末尾, 変更前に存在していたテキストの長さを受け取る.  3つの引数
     はすべて整数である.  変更対象のバッファはつねにカレントバッファで
     ある.

     古いテキストの長さは, 変更前のそのテキストの先頭と末尾のバッファ
     内位置の差である.  変更済みのテキストの長さは, 単純に始めの2つの
     引数の差である.

 -- Macro: combine-after-change-calls BODY...
     このマクロは通常どおりBODYを実行するが, 一連の変更に対して安全と
     思えるときには, `after-change-functions'の関数を一度だけ呼び出す.

     プログラムからバッファの同じ部分でテキスト変更を複数回行う場合, 
     プログラムの当該部分の周りでマクロ`combine-after-change-calls'を
     使うと, フック`after-change-functions'を使用してるときには動作が
     かなり速くなりうる.  最終的にフック`after-change-functions'が呼ば
     れると, `combine-after-change-calls'の本体で行った変更すべてを含
     むようなバッファ部分が引数に指定される.

     *警告：*` ' フォーム`combine-after-change-calls'の本体の内側では
     `after-change-functions'と`after-change-function'の値を変更しない
     こと.

     *注意：*` ' 変更がバッファの広く分散した部分に行われるときにもこ
     れは動作するが, 推奨できない.  非効率なふるまいをするようなフック
     関数があるからである.

 -- Variable: before-change-function
     この廃れた変数は, 任意のバッファの変更を行うまえに呼ばれる1つの関
     数を保持する（`nil'ならばそのような関数はなし）.
     `before-change-functions'の関数と同様に呼ばれる.

 -- Variable: after-change-function
     この廃れた変数は, 任意のバッファの変更を行ったあとに呼ばれる1つの
     関数を保持する（`nil'ならばそのような関数はなし）.
     `after-change-functions'の関数と同様に呼ばれる.

上の4つの変数は, これらの関数が実行中には一時的に`nil'に束縛されます. 
つまり, これらの関数の1つがバッファを変更しても, その変更ではこれらの
関数を呼び出しません.  フック関数においてこれらの関数を実行するような
変更を行いたい場合には, フック関数でこれらの変数をそれらの通常の値に束
縛し直します.

この保護的な機構の1つの不便な帰結は, `after-change-functions'や
`before-change-functions'には, その変数の値を変更する関数を持てないこ
とです.  しかし, これは本当の制限ではありません.  それらの関数で実行す
べき関数のリストを変更したければ, 単純に1つの定まった関数をフックに追
加し, その関数では呼び出すべき別の関数を指定する別の変数を調べます. 
つぎのようにします.

     (setq my-own-after-change-functions nil)
     (defun indirect-after-change-function (beg end len)
       (let ((list my-own-after-change-functions))
         (while list
           (funcall (car list) beg end len)
           (setq list (cdr list)))))

     (add-hooks 'after-change-functions
                'indirect-after-change-function)

 -- Variable: first-change-hook
     この変数は, 未変更状態のバッファを変更するたびに実行されるノーマ
     ルフックである.


File: elisp-ja, Node: Non-ASCII Characters, Next: Searching and Matching, Prev: Text, Up: Top

非ASCII文字
***********

本章では, 非ASCIIに関連する特別なことがらとそれらが文字列やバッファに
どのように保存されるかについて述べます.

* Menu:

* Text Representations::
* Converting Representations::
* Selecting a Representation::
* Character Codes::
* Character Sets::
* Chars and Bytes::
* Splitting Characters::
* Scanning Charsets::
* Translation of Characters::
* Coding Systems::
* Input Methods::



File: elisp-ja, Node: Text Representations, Next: Converting Representations, Prev: Non-ASCII Characters, Up: Non-ASCII Characters

テキスト表現
============

Emacsには2つの"テキスト表現", つまり, 文字列やバッファでテキストを表す
方法が2つあります.  これらは, "ユニバイト"（unibyte）と"マルチバイト"
（multibyte）と呼ばれます.  各文字列や各バッファでは, これらの2つの表
現の一方を使います.  ほとんどの目的には, Emacsがこれらのあいだで適切に
変換するので, 読者はこれらの表現に関しては無視できます.  Lispプログラ
ムでは, これらの違いに注意する必要がしばしばあります.

ユニバイト表現では, 各文字は1バイトを占め, そのため, 可能な文字コード
の範囲は0から255です.  コード0から127はASCII文字です.  コード128から
255は非ASCII文字集合の1つ（変数`nonascii-insert-offset'に設定して文字
集合を選べる）に使われます.

マルチバイト表現では, 1文字は1バイト以上を占め, そのため, Emacsの文字
コードの範囲全体を格納できるのです.  マルチバイト文字の最初のバイトは
つねに128から159（8進数で0200から0237）の範囲にあります.  これらの値を
"リーディングコード"（leading code）と呼びます.  マルチバイト文字の2バ
イト以降はつねに160から255（8進数で0240から0377）の範囲にあります.  こ
れらの値を"トレイリングコード"（trailing code）と呼びます.

バッファでは, 変数`enable-multibyte-characters'のバッファローカルな値
が使用する表現を指定します.  文字列の表現は, 文字列を作成するときの文
字列の内容に基づいて決定されます.

 -- Variable: enable-multibyte-characters
     この変数は, バッファのテキスト表現を指定する.  これが`nil'以外で
     あると, バッファはマルチバイトテキストを保持する.  さもなければユ
     ニバイトテキストを保持する.

     この変数に直接設定することはできない.  そのかわりに, バッファの表
     現を変更するには, 関数`set-buffer-multibyte'を使う.

 -- Variable: default-enable-multibyte-characters
     この変数の値は, `(default-value 'enable-multibyte-characters)'に
     完全に等価であり, この変数に設定するとデフォルト値を変更する.  バッ
     ファの`enable-multibyte-characters'のローカルな束縛に設定すること
     は許されていないが, デフォルト値を変更することは可能であり, そう
     しても既存のバッファには影響しないので理にかなっている.

     コマンド行オプション`--unibyte'は, 起動時の早い段階でデフォルト値
     に`nil'を設定することで役目を果たす.

 -- Function: multibyte-string-p STRING
     文字列STRINGにマルチバイト文字が含まれると`t'を返す.



File: elisp-ja, Node: Converting Representations, Next: Selecting a Representation, Prev: Text Representations, Up: Non-ASCII Characters

テキスト表現の変換
==================

Emacsはユニバイトテキストをマルチバイトに変換できます.  マルチバイトテ
キストをユニバイトにも変換できますが, この変換では情報が欠落します. 
バッファにテキストを挿入するとき, あるいは, 複数の文字列から1つの文字
列にテキストを収めるときに, 一般にこれらの変換が行われます.  文字列の
内容をどちらかの表現に明示的にも変換できます.

Emacsは, 文字列を作成するときにはその内容に基づいて文字列の表現を選び
ます.  一般則は, ユニバイトテキストを他のマルチバイトテキストに組み入
れるときにはユニバイトテキストをマルチバイトテキストに変換します.  マ
ルチバイト表現のほうが汎用であり, ユニバイトテキストのどんな文字でも保
持できるからです.

バッファにテキストを挿入するときには, Emacsは, 当該バッファの
`enable-multibyte-characters'の指定に従ったバッファの表現にテキストを
変換します.  特に, ユニバイトバッファにマルチバイトテキストを挿入する
ときには, マルチバイトテキスト内のすべての文字を一般には保存できなくて
も, Emacsはテキストをユニバイトに変換します.  自然な代替案はバッファ内
容をマルチバイトに変換することですが, これは受け入れられません.  バッ
ファの表現はユーザーが選択したものであり自動的には無視できないからです.

ユニバイトテキストをマルチバイトテキストに変換してもASCII文字は無変更
であり, 128から159も同様です.  160から255の非ASCIIについては, 各文字に
`nonascii-insert-offset'の値を加算することで変換します.  この変数に設
定すると, ユニバイト文字がどの文字集合に対応するかを指定できます
（*Note Character Sets::）.  たとえば, `nonascii-insert-offset'が`(-
(make-char 'latin-iso8859-1) 128)'の2048であると, 非ASCIIのユニバイト
はLatin 1に対応します.  `(- (make-char 'greek-iso8859-7) 128)'の2688で
あると, ギリシャ文字に対応します.

マルチバイトテキストをユニバイトに変換するのは簡単で, 各文字コードと
255の論理積をとります.  `nonascii-insert-offset'に文字集合の始まりに対
応する合理的な値が設定されていれば, この変換は逆変換になります.  つま
り, ユニバイトテキストをマルチバイトに変換し, それをユニバイトに戻すと
もとのユニバイトテキストになります.

 -- Variable: nonascii-insert-offset
     この変数は, ユニバイトテキストをマルチバイトに変換するときに非
     ASCII文字に加算する値を指定する.  これは, 128から255のユニバイト
     の非ASCIIの範囲の文字を挿入する`self-insert-command'にも適用され
     る.  しかし, 関数`insert-char'はこの変換を行わない.

     文字集合CSを選択する正しい値は, `(- (make-char CS) 128)'である.
     `nonascii-insert-offset'の値が0であると, 実際の変換には0ではなく
     Latin 1文字集合に対する値を使う.

 -- Variable: nonascii-translation-table
     この変数は, `nonascii-insert-offset'のより一般的な代替を提供する.
     128から255の範囲の各コードをマルチバイト文字に変換する方法を独立
     して指定するために使える.  その値はベクトルか`nil'であること.  こ
     れが`nil'以外であると, `nonascii-insert-offset'に優先する.

 -- Function: string-make-unibyte STRING
     この関数は, STRINGのテキストがすでにユニバイトでなければユニバイ
     ト表現に変換してから結果を返す.  STRINGがユニバイトであれば無変更
     で返す.

 -- Function: string-make-multibyte STRING
     この関数は, STRINGのテキストがすでにマルチバイトでなければマルチ
     バイト表現に変換してから結果を返す.  STRINGがマルチバイトであれば
     無変更で返す.



File: elisp-ja, Node: Selecting a Representation, Next: Character Codes, Prev: Converting Representations, Up: Non-ASCII Characters

表現の選択
==========

既存のバッファや文字列がユニバイトであるときにマルチバイトとして調べた
り, その逆のように調べるのが有用なこともあります

 -- Function: set-buffer-multibyte MULTIBYTE
     カレントバッファの表現方法を設定する.  MULTIBYTEが`nil'以外である
     と, バッファはマルチバイトになる.  MULTIBYTEが`nil'であると, バッ
     ファはユニバイトになる.

     この関数は, バイト列としてみたバッファ内容を変更しない.  その結果, 
     文字として見たときの内容を変更できる.  マルチバイト表現では1文字
     とみなされる2バイトの列は, ユニバイト表現では2文字になる.

     この関数は, `enable-multibyte-characters'にどちらの表現を使用して
     いるかを記録する.  さらに（オーバレイ, テキスト属性, マーカなどの）
     バッファ内のさまざまなデータを調整して, それ以前と同様に同じテキ
     ストに及ぶようにする.

 -- Function: string-as-unibyte STRING
     この関数は, 各バイトを1文字とみなしてSTRINGと同じバイトの文字列を
     返す.  つまり, 値にはSTRINGより多くの文字が含まれることがある.

     STRINGがすでにユニバイトであると, 値はSTRINGそのものである.

 -- Function: string-as-multibyte STRING
     この関数は, マルチバイトの各列を1文字とみなしてSTRINGと同じバイト
     の文字列を返す.  つまり, 値にはSTRINGより少ない文字が含まれること
     がある.

     STRINGがすでにマルチバイトであると, 値はSTRINGそのものである.



File: elisp-ja, Node: Character Codes, Next: Character Sets, Prev: Selecting a Representation, Up: Non-ASCII Characters

文字コード
==========

ユニバイトとマルチバイトのテキスト表現では, 異なる文字コードを使ってい
ます.  ユニバイト表現において正しい文字コードは0から255の範囲であり, 
これらの値は1バイトに収まります.  マルチバイト表現において正しい文字コー
ドは0から524287の範囲ですが, この範囲のすべての値が正しいとは限りませ
ん.  特に, 値128から255は（『生のバイト』にはありうる. *Note Explicit
Encoding::）, マルチバイトテキストでは正しくありません.  0から127の
ASCIIコードのみが, どちらの表現でも完全に正しいのです.

 -- Function: char-valid-p CHARCODE
     この関数は, CHARCODEが2つのテキスト表現のどちらか一方で正しければ
     `t'を返す.

          (char-valid-p 65)
               => t
          (char-valid-p 256)
               => nil
          (char-valid-p 2248)
               => t



File: elisp-ja, Node: Character Sets, Next: Chars and Bytes, Prev: Character Codes, Up: Non-ASCII Characters

文字集合
========

Emacsは文字をさまざまな"文字集合"（character set）に分類します.  文字
集合にはシンボルである名前があります.  各文字はたった1つの文字集合に属
します.

一般に, 異なる文字体系ごとに1つの文字集合があります.  たとえば,
`latin-iso8859-1'は1つの文字集合であり, `greek-iso8859-7'は別の文字集
合であり, `ascii'も別の文字集合です.  Emacsの1つの文字集合には最大9025
個の文字を保持できます.  したがって, 論理的には1つの文字集合にまとめら
れる文字群を, 複数の文字集合に分割する場合もあります.  たとえば, Big 5
として一般には知られている中国文字の1つの集合は, Emacsの2つの文字集合,
`chinese-big5-1'と`chinese-big5-2'に分割されます.

 -- Function: charsetp OBJECT
     OBJECTが文字集合の名前のシンボルであれば`t'を返す.  さもなければ
     `nil'を返す.

 -- Function: charset-list
     この関数は, 定義されているすべての文字集合の名前のリストを返す.

 -- Function: char-charset CHARACTER
     この関数は文字CHARACTERが属する文字集合の名前を返す.



File: elisp-ja, Node: Chars and Bytes, Next: Splitting Characters, Prev: Character Sets, Up: Non-ASCII Characters

文字とバイト
============

マルチバイト表現では, 各文字は1バイトかそれ以上のバイトを占めます.  各
文字集合には, 通常は1バイト長か2バイト長の"導入列"（introduction
sequence）があります（例外：ASCIIの導入列は0バイト長である）.  導入列
は, 文字集合の任意の文字のバイト列の始まりです.  文字のバイト列の残り
の部分は, 同じ文字集合内で他の文字とその文字を区別します.  文字集合に
依存して, 区別するためのバイトは1バイトか2バイトです.  そのようなバイ
ト数を文字集合の"次元"（dimension）と呼びます.

 -- Function: charset-dimension CHARSET
     この関数は, 文字集合CHARSETの次元を返す.  現在, 次元はつねに1か2
     である.

文字集合の導入列のバイト長を判定するもっとも簡単な方法はつぎのとおりで
す.

     (- (char-bytes (make-char CHARSET))
        (charset-dimension CHARSET))



File: elisp-ja, Node: Splitting Characters, Next: Scanning Charsets, Prev: Chars and Bytes, Up: Non-ASCII Characters

文字の分割
==========

本節の関数は, 文字とそれを表現するために用いられるバイト値のあいだの変
換を行います.  ほとんどの目的に関しては, Emacsが必要に応じて自動的に行
うため, 文字を表現するためのバイト列を扱う必要はありません.

 -- Function: char-bytes CHARACTER
     この関数は, 文字CHARACTERを表現するために必要なバイト数を返す. 
     これは, 文字CHARACTERが属する文字集合だけに依存し, その文字集合
     （*Note Character Sets::）の次元とその導入列の和に等しい.

          (char-bytes 2248)
               => 2
          (char-bytes 65)
               => 1
          (char-bytes 192)
               => 1

     マルチバイト表現とユニバイト表現のどちらに対してもこの関数で正し
     い結果を得られるのは, 2つの表現で用いられる非ASCII文字コードに重
     なりがないからである.

 -- Function: split-char CHARACTER
     文字CHARACTERの文字集合の名前に続けて, その文字集合でCHARACTERを
     識別する1バイトか2バイトの値（整数）から成るリストを返す.  バイト
     値の個数はその文字集合の次元である.

          (split-char 2248)
               => (latin-iso8859-1 72)
          (split-char 65)
               => (ascii 65)

     ユニバイトの非ASCII文字は, 文字集合`ascii'の一部とみなす.

          (split-char 192)
               => (ascii 192)

 -- Function: make-char CHARSET &rest BYTE-VALUES
     この関数は, 文字集合CHARSETにおいてBYTE-VALUESで識別される文字を
     返す.  これは, `split-char'のほぼ逆関数にあたる.  通常, 文字集合
     CHARSETの次元に応じて, 1つか2つのBYTE-VALUESを指定する.  たとえば
     つぎのとおり.

          (make-char 'latin-iso8859-1 72)
               => 2248

BYTE-VALUESを指定せずに`make-char'を呼び出すと, その結果は文字集合
CHARSETを代表する"汎用文字"（generic character）である.  汎用文字は整
数であるが, 文字としてバッファに挿入するには正しく*ない*ものである.  1
つの文字集合全体を表すために`char-table-range'で使える（*Note
Char-Tables::）.  `char-valid-p'は汎用文字に対しては`nil'を返す.  たと
えばつぎのとおり.

     (make-char 'latin-iso8859-1)
          => 2176
     (char-valid-p 2176)
          => nil
     (split-char 2176)
          => (latin-iso8859-1 0)



File: elisp-ja, Node: Scanning Charsets, Next: Translation of Characters, Prev: Splitting Characters, Up: Non-ASCII Characters

文字集合の走査
==============

バッファや文字列の一部分にどの文字集合が現れるかを調べられると有用なこ
とがあります.  その1つの用途は, 当該テキストすべてを表現する能力がある
コーディングシステム（*Note Coding Systems::）を探すことです.

 -- Function: find-charset-region BEG END &optional TRANSLATION
     この関数は, カレントバッファのBEGとENDのあいだに現れる文字集合の
     リストを返す.

     省略可能な引数TRANSLATIONは, テキストを走査するときに使用する変換
     表を指定する（*Note Translation of Characters::）.  これが`nil'以
     外であると, 領域内の各文字をこの表を介して変換し, 戻り値は, バッ
     ファ内の実際の文字のかわりに変換した文字に関する情報を与える.

 -- Function: find-charset-string STRING &optional TRANSLATION
     この関数は, 文字列STRINGに現れる文字集合のリストを返す.

     省略可能な引数TRANSLATIONは変換表を指定する.  上記の
     `find-charset-region'を参照.



File: elisp-ja, Node: Translation of Characters, Next: Coding Systems, Prev: Scanning Charsets, Up: Non-ASCII Characters

文字の変換
==========

"変換表"（translation table）は, 文字群を文字群へ対応付けます.  これら
の表は, 符号化と復号化, 他の目的に使われます.  独自の変換表を指定する
コーディングシステムもあります.  他のすべてのコーディングシステムに適
用されるデフォルトの変換表もあります.

 -- Function: make-translation-table TRANSLATIONS
     この関数は, 引数TRANSLATIONSに基づいた変換表を返す.  引数
     TRANSLATIONSの各要素は, `(FROM . TO)'の形であり, 文字FROMをTOへ変
     換することを意味する.

     1つの文字集合全体を同じ次元の別の文字集合へ対応付けることも可能で
     ある.  それには, FROMに（文字集合を表す）汎用文字を指定する
     （*Note Splitting Characters::）.  この場合, TOも, 同じ次元の別の
     文字集合の汎用文字であること.  こうすると, この変換表は, FROMの文
     字集合の各文字をTOの文字集合の対応する文字へ変換する.

復号化では, もとの復号化結果の文字に変換表による変換を適用します.  コー
ディングシステムに属性`character-translation-table-for-decode'があれば, 
これは使用する変換表を指定します.  さもなければ,
`standard-character-translation-table-for-decode'が`nil'以外であれば, 
復号化ではその表を使います.

符号化では, バッファ内の文字に変換表による変換を適用し, 変換結果を実際
に符号化します.  コーディングシステムに属性
`character-translation-table-for-encode'があれば, これは使用する変換表
を指定します.  さもなければ, 変数
`standard-character-translation-table-for-encode'が使用する変換表を指
定します.

 -- Variable: standard-character-translation-table-for-decode
     これは, 変換表を指定しないコーディングシステムに対する復号化時の
     デフォルトの変換表である.

 -- Variable: standard-character-translation-table-for-encode
     これは, 変換表を指定しないコーディングシステムに対する符号化時の
     デフォルトの変換表である.



File: elisp-ja, Node: Coding Systems, Next: Input Methods, Prev: Translation of Characters, Up: Non-ASCII Characters

コーディングシステム
====================

Emacsがファイルを読み書きしたり, Emacsがサブプロセスへテキストを送った
りサブプロセスからテキストを受け取るときには, "コーディングシステム"
（coding system）で指定される文字コード変換と行末変換を行います.

* Menu:

* Coding System Basics::
* Encoding and I/O::
* Lisp and Coding Systems::
* User-Chosen Coding Systems::
* Default Coding Systems::
* Specifying Coding Systems::
* Explicit Encoding::
* Terminal I/O Encoding::
* MS-DOS File Types::



File: elisp-ja, Node: Coding System Basics, Next: Encoding and I/O, Prev: Coding Systems, Up: Coding Systems

コーディングシステムの基本概念
------------------------------

"文字コード変換"（character code conversion）とは, Emacsの内部で使用す
る符号と他の符号とのあいだでの変換のことです.  Emacsでは, 相互に変換で
きる多くの異なる符号を扱えます.  たとえば, Emacsは, Latin 1, Latin 2,
Latin 3, Latin 4, Latin 5, ISO 2022のいくつかの変種を相互に変換できま
す.  同じ文字集合に対する異なる符号を扱うこともできます.  たとえば, キ
リル（ロシア語）文字に対してはISO, Alternativnyj, KOI8の3つのコーディ
ングシステムがあります.

ほとんどのコーディングシステムでは変換する文字コードを特定しますが, 指
定せずにデータに基づいて発見的手法で選ぶものもあります.

"行末変換"（end of line conversion）は, ファイル内の行の終りを表すさま
ざまなシステムで使われている3つの異なる慣習を扱います.  UNIXの慣習では, 
行送り文字（改行文字とも呼ぶ）を使います.  DOSの慣習では, 行末には復帰
と行送りの2文字の列を使います.  Macの慣習では, 復帰のみを使います.

`latin-1'のような"基底コーディングシステム"（base coding system）では, 
行末変換を指定せずにデータに基づいて選びます.  `latin-1-unix',
`latin-1-dos', `latin-1-mac'のような"変種コーディングシステム"
（variant coding system）では, 明示的に行末変換も指定します.  ほとんど
の基底コーディングシステムには, `-unix', `-dos', `-mac'を付加して作ら
れる名前の対応する3つの変種があります.

コーディングシステム`raw-text'は文字コード変換を行わない特別なもので, 
このコーディングシステムで訪問したバッファはユニバイトバッファになりま
す.  行末変換も指定しないので内容に基づいて決定でき, 行末変換を指定す
る3つの変種もあります.  `no-conversion'は`raw-text-unix'に等価であり, 
文字コードも行末も変換しないことを指定します.

コーディングシステム`emacs-mule'は, Emacs内部での符号でデータを表現す
ることを指定します.  これは, コード変換を行わないという意味では
`raw-text'に似ていますが, 結果がマルチバイトデータになる点が異なります.

 -- Function: coding-system-get CODING-SYSTEM PROPERTY
     この関数は, コーディングシステムCODING-SYSTEMの指定した属性を返す. 
     コーディングシステムのほとんどの属性は内部目的用であるが, 読者が
     有用と思うものが1つ, `mime-charset'がある.  この属性の値は, 当該
     コーディングシステムで読み書きする文字コード向けのMIMEに使用する
     名前である.

          (coding-system-get 'iso-latin-1 'mime-charset)
               => iso-8859-1
          (coding-system-get 'iso-2022-cn 'mime-charset)
               => iso-2022-cn
          (coding-system-get 'cyrillic-koi8 'mime-charset)
               => koi8-r

     属性`mime-charset'の値は, コーディングシステムの別名としても定義
     されている.



File: elisp-ja, Node: Encoding and I/O, Next: Lisp and Coding Systems, Prev: Coding System Basics, Up: Coding Systems

符号化と入出力
--------------

コーディングシステムの主目的は, ファイルの読み書きに使うことです.  関
数`insert-file-contents'はファイルのデータを復号化するためにコーディン
グシステムを使い, `write-region'はバッファ内容を符号化するためにコーディ
ングシステムを使います.

使用するコーディングシステムを明示する（*Note Specifying Coding
Systems::）こともできるし, デフォルトの機構（*Note Default Coding
Systems::）を暗に使うこともできます.  しかし, これらの方式ではすべきこ
とを完全に指定しきれないこともあります.  たとえば, `undefined'のような
コーディングシステムを選んで, データに基づいて文字コード変換を行うよう
にするかもしれません.  そのような場合, コーディングシステムの選択は入
出力操作によって完了します.  しばしば, 選択されたコーディングシステム
をあとで知りたくなります.

 -- Variable: buffer-file-coding-system
     この変数は, カレントバッファで訪問するときに使用したコーディング
     システムを記録する.  これは, バッファを保存したり, `write-region'
     でバッファの一部を書くときに使われる.  これらの操作において, ユー
     ザーに別のコーディングシステムを指定するように問い合わせた場合に
     は, `buffer-file-coding-system'は指定された別のコーディングシステ
     ムに更新される.

 -- Variable: save-buffer-coding-system
     この変数は, `write-region'には使わないが, バッファを保存するため
     に使うコーディングシステムを指定する.  バッファを保存する際に, ユー
     ザーに別のコーディングシステムを指定するように問い合わせ, かつ,
     `save-buffer-coding-system'を用いている場合には, これは指定された
     別のコーディングシステムに更新される.

 -- Variable: last-coding-system-used
     ファイルやサブプロセスに対する入出力操作では, 使用したコーディン
     グシステム名をこの変数に設定する.  明示的に符号化／復号化する関数
     （*Note Explicit Encoding::）もこの変数に設定する.

     *警告：*` ' サブプロセスから出力を受け取るとこの変数が設定される
     ため, Emacsが待つたびに変化する可能性がある.  したがって, 読者の
     興味がある値を保存するような関数を呼び出した直後にその値をコピー
     して使うこと.

変数`selection-coding-system'は, ウィンドウシステムのセレクションを符
号化する方法を指定します.  *Note Window System Selections::.



File: elisp-ja, Node: Lisp and Coding Systems, Next: User-Chosen Coding Systems, Prev: Encoding and I/O, Up: Coding Systems

Lispにおけるコーディングシステム
--------------------------------

コーディングシステムを扱うLispの機能について述べます.

 -- Function: coding-system-list &optional BASE-ONLY
     この関数は, すべてのコーディングシステム名（シンボル）のリストを
     返す.  BASE-ONLYが`nil'以外であると, 値には基底コーディングシステ
     ムのみを含める.  さもなければ, 値には変種コーディングシステムも含
     まれる.

 -- Function: coding-system-p OBJECT
     この関数は, OBJECTがコーディングシステム名であると`t'を返す.

 -- Function: check-coding-system CODING-SYSTEM
     この関数は, CODING-SYSTEMの正当性を調べる.  正しいものならば
     CODING-SYSTEMを返す.  さもなければ, 条件`coding-system-error'付き
     のエラーを通知する.

 -- Function: coding-system-change-eol-conversion CODING-SYSTEM EOL-TYPE
     この関数は, CODING-SYSTEMに類似のコーディングシステムを返すが,
     `eol-type'で指定された行末変換のものである.  EOL-TYPEは, `unix',
     `dos', `mac', `nil'のいずれかであること.  `nil'であると, 返された
     コーディングシステムは, データから行末変換を決定する.

 -- Function: coding-system-change-text-conversion EOL-CODING TEXT-CODING
     この関数は, 行末変換にEOL-CODINGを使い, テキストの変換に
     TEXT-CODINGを使っているコーディングシステムを返す.  TEXT-CODINGが
     `nil'であると, `undecided'かEOL-CODINGに応じた`undecided'の変種の
     1つを返す.

 -- Function: find-coding-systems-region FROM TO
     この関数は, FROMとTOのあいだのテキストの符号化に使用できるコーディ
     ングシステムのリストを返す.  リスト内のすべてのコーディングシステ
     ムは, 当該部分のテキストのどんなマルチバイト文字も安全に符号化で
     きる.

     テキストにマルチバイト文字が含まれない場合, 関数はリスト
     `(undecided)'を返す.

 -- Function: find-coding-systems-string STRING
     この関数は, 文字列STRINGのテキストの符号化に使用できるコーディン
     グシステムのリストを返す.  リスト内のすべてのコーディングシステム
     は, STRINGのどんなマルチバイト文字も安全に符号化できる.  テキスト
     にマルチバイト文字が含まれない場合, これはリスト`(undecided)'を返
     す.

 -- Function: find-coding-systems-for-charsets CHARSETS
     この関数は, リストCHARSETS内のすべての文字集合の符号化に使用でき
     るコーディングシステムのリストを返す.

 -- Function: detect-coding-region START END &optional HIGHEST
     この関数は, STARTからENDまでのテキストを復号化するもっともらしい
     コーディングシステムを選ぶ.  このテキストは『生のバイト』（*Note
     Explicit Encoding::）であること.

     この関数は, 通常, 走査したテキストの復号化を扱えるコーディングシ
     ステムのリストを返す.  それらは優先順位の降順に並ぶ.  しかし,
     HIGHESTが`nil'以外であると, 戻り値はもっとも順位の高い1つのコーディ
     ングシステムである.

     領域にASCII文字だけが含まれる場合, 値は`undecided'か`(undecided)'
     である.

 -- Function: detect-coding-string STRING HIGHEST
     この関数は`detect-coding-region'と同様であるが, バッファ内のバイ
     トのかわりに文字列STRINGの内容に作用する.

サブプロセスとの入出力に使用されるコーディングシステムを調べたり設定す
る方法については, *Note Process Information::.



File: elisp-ja, Node: User-Chosen Coding Systems, Next: Default Coding Systems, Prev: Lisp and Coding Systems, Up: Coding Systems

ユーザー指定のコーディングシステム
----------------------------------

 -- Function: select-safe-coding-system FROM TO &optional PREFERRED-CODING-SYSTEM
     この関数はFROMとTOのあいだのテキストを符号化するコーディングシス
     テムを選ぶが, 必要ならばユーザーに問い合わせる.

     省略可能な引数PREFERRED-CODING-SYSTEMは, 最初に試すコーディングシ
     ステムを指定する.  それが指定領域のテキストを処理できるならば, そ
     れを使う.  この引数を省略すると, `buffer-file-coding-system'のカ
     レントバッファでの値をまず試す.

     領域内にPREFERRED-CODING-SYSTEMで符号化できないマルチバイト文字が
     ある場合, この関数は, 当該テキストを符号化可能なコーディングシス
     テム一覧からユーザーに選択してもらい, ユーザーが選択したものを返
     す.

     特殊機能：` 'FROMが文字列であると, 文字列を調べる対象とし, TOは無
     視する.

補完を用いてユーザーにコーディングシステムを指定させるために使える2つ
の関数はつぎのとおりです.  *Note Completion::.

 -- Function: read-coding-system PROMPT &optional DEFAULT
     この関数は, 文字列PROMPTをプロンプトとしてミニバッファを使ってコー
     ディングシステムを読み取り, コーディングシステム名をシンボルとし
     て返す.  ユーザーの入力が空であると, DEFAULTは返すべきコーディン
     グシステムを指定する.  それはシンボルか文字列であること.

 -- Function: read-non-nil-coding-system PROMPT
     この関数は, 文字列PROMPTをプロンプトとしてミニバッファを使ってコー
     ディングシステムを読み取り, コーディングシステム名をシンボルとし
     て返す.  ユーザーが空を入力しようとすると再度問い合わせる.  *Note
     Coding Systems::.



File: elisp-ja, Node: Default Coding Systems, Next: Specifying Coding Systems, Prev: User-Chosen Coding Systems, Up: Coding Systems

デフォルトのコーディングシステム
--------------------------------

本節では, 特定のファイルや特定のサブプログラムを実行するときのデフォル
トのコーディングシステムを指定する変数と, それらを使った入出力操作を行
う関数について述べます.

これらの変数の目的は, 読者が望むデフォルトをいったんこれらに設定してお
けば, 再度変更する必要がないようにすることです.  Lispプログラムの特定
の操作向けに特定のコーディングシステムを指定するには, これらの変数を変
更しないでください.  かわりに, `coding-system-for-read'や
`coding-system-for-write'を使って上書きします（*Note Specifying Coding
Systems::）.

 -- Variable: file-coding-system-alist
     この変数は, 特定のファイルの読み書きに使用するコーディングシステ
     ムを指定する連想リストである.  各要素は`(PATTERN . CODING)'の形で
     あり, PATTERNは特定のファイル名に一致する正規表現である.  PATTERN
     に一致するファイル名に当該要素を適用する.

     要素のCDR, CODINGはコーディングシステムであるか, 2つのコーディン
     グシステムを収めたコンスセルであるか, 関数シンボルであること.
     CODINGがコーディングシステムであると, ファイルの読み書きの両方に
     そのコーディングシステムを使う.  CODINGが2つのコーディングシステ
     ムを収めたコンスセルであると, そのCARは復号化に使うコーディングシ
     ステムを指定し, そのCDRは符号化に使うコーディングシステムを指定す
     る.

     CODINGが関数シンボルであると, その関数は, コーディングシステムか,
     2つのコーディングシステムを収めたコンスセルを返すこと.  その値は
     上に述べたように使われる.

 -- Variable: process-coding-system-alist
     この変数は, サブプロセスで実行しているプログラムに依存してサブプ
     ロセスに使うコーディングシステムを指定する連想リストである.
     `file-coding-system-alist'と同様に働くが, PATTERNはサブプロセスを
     始めるために用いたプログラム名に対して一致を取る点が異なる.  この
     連想リストに指定したコーディングシステムは, サブプロセスとの入出
     力に使用するコーディングシステムの初期化に用いれるが,
     `set-process-coding-system'を使って, あとで別のコーディングシステ
     ムを指定できる.

*警告：*` ' データからコーディングシステムを決定する`undecided'のよう
なコーディングシステムは, 非同期サブプロセスの出力に対しては完全に信頼
性のある動作はできない.  これは, Emacsが非同期サブプロセスの出力が到着
するたびに一塊で処理するからである.  コーディングシステムが文字コード
変換や行末変換を未指定にしていると, Emacsは1つの塊から正しい変換を検出
しようと試みるが, これがつねに動作するとは限らない.

したがって, 非同期サブプロセスでは, 可能な限り文字コード変換と行末変換
の両方を指定したコーディングシステムを使います.  つまり, `undecided'や
`latin-1'などではなく, `latin-1-unix'のようなものを使います.

 -- Variable: network-coding-system-alist
     この変数は, ネットワークストリームに使用するコーディングシステム
     を指定する連想リストである.  `file-coding-system-alist'と同様に働
     くが, 要素内のPATTERNはポート番号か正規表現である点が異なる.  そ
     れが正規表現であると, ネットワークストリームを開くために使用した
     ネットワークサービス名に対して一致をとる.

 -- Variable: default-process-coding-system
     この変数は, なにも指定されていないサブプロセス（やネットワークス
     トリーム）の入出力に使用するコーディングシステムを指定する.

     値は, `(INPUT-CODING . OUTPUT-CODING)'の形のコンスセルであること. 
     ここで, INPUT-CODINGはサブプロセスからの入力に適用され,
     OUTPUT-CODINGはそれへの出力に適用される.

 -- Function: find-operation-coding-system OPERATION &rest ARGUMENTS
     この関数は, ARGUMENTSを指定してOPERATIONを行うときに（デフォルト
     で）使用されるコーディングシステムを返す.  その値はつぎの形である.

          (DECODING-SYSTEM ENCODING-SYSTEM)

     第1要素DECODING-SYSTEMは（OPERATIONが復号化を行う場合には）復号化
     に用いるコーディングシステムであり, ENCODING-SYSTEMは（OPERATION
     が符号化を行う場合には）符号化に用いるコーディングシステムである.

     引数OPERATIONは, Emacsの入出力基本関数の`insert-file-contents',
     `write-region', `call-process', `call-process-region',
     `start-process', `open-network-stream'のいずれかであること.

     残りの引数は, これらの入出力基本関数に指定するであろう引数と同じ
     であること.  基本関数に依存して, 引数の1つを"対象"として選ぶ.  た
     とえば, OPERATIONがファイル入出力を行う場合, ファイル名を指定する
     引数が対象である.  サブプロセスの基本関数では, プロセス名が対象で
     ある.  `open-network-stream'では, サービス名やポート番号が対象で
     ある.

     この関数は, OPERATIONに応じて当該対象を`file-coding-system-alist'
     や`process-coding-system-alist'や`network-coding-system-alist'で
     探す.  *Note Default Coding Systems::.



File: elisp-ja, Node: Specifying Coding Systems, Next: Explicit Encoding, Prev: Default Coding Systems, Up: Coding Systems

1つの操作向けにコーディングシステムを指定する
---------------------------------------------

変数`coding-system-for-read'と／や`coding-system-for-write'を束縛する
ことで, 特定の1つの操作向けのコーディングシステムを指定できます.

 -- Variable: coding-system-for-read
     この変数が`nil'以外であると, ファイルを読むときや同期プロセスから
     の入力に用いるコーディングシステムを指定する.

     これは非同期プロセスやネットワークストリームにも適用されるが, 異
     なった方法で適用される.  サブプロセスを開始したりネットワークスト
     リームを開いたときの`coding-system-for-read'の値は, そのサブプロ
     セスやネットワークストリームの入力の復号化方法を指定する.  変更さ
     れない限り, そのサブプロセスやネットワークストリームに対して使わ
     れ続ける.

     この変数の正しい使い方は, 特定の入出力操作に対して`let'で束縛する
     ことである.  そのグローバルな値は通常は`nil'であり, グローバルに
     これ以外の値を設定するべきではない.  この変数の正しい使い方の例を
     つぎに示す.

          ;; 文字コード変換せずにファイルから読む
          ;; CRLFが行末を表すと仮定する
          (let ((coding-system-for-write 'emacs-mule-dos))
            (insert-file-contents filename))

     その値が`nil'以外であると, `coding-system-for-read'は,
     `file-coding-system-alist', `process-coding-system-alist',
     `network-coding-system-alist', を含めて入力に用いるコーディングシ
     ステムの他のすべての指定方法に優先する.

 -- Variable: coding-system-for-write
     これは`coding-system-for-read'と同様に働くが, 入力ではなく出力に
     適用される点が異なる.  ファイル, サブプロセス, ネットワーク接続へ
     書くことに影響する.

     `call-process-region'と`start-process'のように, 1つの操作で入力と
     出力を行うときには, `coding-system-for-read'と
     `coding-system-for-write'の両方が影響する.

 -- Variable: inhibit-eol-conversion
     この変数が`nil'以外であると, コーディングシステムでなにが指定され
     ていようと行末変換を行わない.  これは, Emacsの入出力とサブプロセ
     スのすべての基本関数, 明示的な符号化／復号化関数（*Note Explicit
     Encoding::）に適用される.



File: elisp-ja, Node: Explicit Encoding, Next: Terminal I/O Encoding, Prev: Specifying Coding Systems, Up: Coding Systems

明示的な符号化と復号化
----------------------

Emacsへ／からテキストを転送するすべての操作には, テキストを符号化した
り復号化するコーディングシステムを使う能力があります.  本節に述べる関
数を用いてテキストを明示的に符号化したり復号化できます.

符号化の結果と復号化する入力は, 通常のEmacsのテキストではありません. 
それらは『生のバイト』, つまり, 外部ファイルと同じ方法でテキストを表現
するバイト列です.  バッファに生のバイトが収められている場合,
`set-buffer-multibyte'（*Note Selecting a Representation::）を用いてバッ
ファはユニバイト表現であると印を付けるのがもっとも自然ですが, これは必
須ではありません.  バッファの内容が単に一時的に生のバイトであるときに
は, バッファはマルチバイトのままにしておきます.  バッファ内容を復号化
すれば正しくなります.

明示的に復号化するためにバッファに生のバイトを入れる普通の方法は,
`insert-file-contents-literally'（*Note Reading from Files::）でファイ
ルから読むか, `find-file-noselect'でファイルを訪問するときに引数
RAWFILEに`nil'以外を指定します.

テキストの明示的な符号化で得た結果である生のバイトを使う普通の方法は, 
ファイルやプロセスへそれらをコピーします.  たとえば, `write-region'
（*Note Writing to Files::）でそれらを書くには,
`coding-system-for-write'に`no-conversion'を束縛して`write-region'の符
号化を抑制します.

生のバイトには, 正しいマルチバイト文字に余分なトレイリングコードが付い
たように見える長すぎるバイト列が含まれる場合があります.  ほとんどの目
的には, バッファや文字列のそのような列をEmacsは1文字として扱い, その文
字コードを調べるとマルチバイト文字の列に対応した値を得るはずです.  余
分なバイト列は無視されます.  このふるまいは透明性がよくありませんが, 
生のバイトはEmacsの限定された場面でのみ使われ, 実用上の問題は回避でき
ます.

 -- Function: encode-coding-region START END CODING-SYSTEM
     この関数は, コーディングシステムCODING-SYSTEMに従ってSTARTからEND
     のテキストを符号化する.  符号化結果はバッファ内のもとのテキストを
     置き換える.  符号化結果は『生のバイト』であるが, マルチバイトであっ
     たバッファはマルチバイトのままである.

 -- Function: encode-coding-string STRING CODING-SYSTEM
     この関数は, コーディングシステムCODING-SYSTEMに従って文字列STRING
     のテキストを符号化する.  符号化したテキストを含む新たな文字列を返
     す.  符号化結果は『生のバイト』のユニバイト文字列である.

 -- Function: decode-coding-region START END CODING-SYSTEM
     この関数は, コーディングシステムCODING-SYSTEMに従ってSTARTからEND
     のテキストを復号化する.  復号化結果はバッファ内のもとのテキストを
     置き換える.  明示的な復号化が有用であるためには, 復号化前のテキス
     トは『生のバイト』であること.

 -- Function: decode-coding-string STRING CODING-SYSTEM
     この関数は, コーディングシステムCODING-SYSTEMに従って文字列STRING
     のテキストを復号化する.  復号化したテキストを含む新たな文字列を返
     す.  明示的な復号化が有用であるためには, 復号化前のSTRINGの内容は
     『生のバイト』であること.



File: elisp-ja, Node: Terminal I/O Encoding, Next: MS-DOS File Types, Prev: Explicit Encoding, Up: Coding Systems

端末入出力の符号化
------------------

Emacsは, コーディングシステムを用いてキーボード入力を復号化したり, 端
末出力を符号化できます.  Latin-1などの特定の符号を用いてテキストを送信
したり表示する端末に対しては, これは有用です.  Emacsは, 端末に対する符
号化や復号化では`last-coding-system-used'に設定しません.

 -- Function: keyboard-coding-system
     この関数は, キーボード入力の復号化に用いているコーディングシステ
     ムを返す.  コーディングシステムを使用していなければ`nil'を返す.

 -- Function: set-keyboard-coding-system CODING-SYSTEM
     この関数は, キーボード入力の復号化に使用するコーディングシステム
     としてCODING-SYSTEMを指定する.  CODING-SYSTEMが`nil'であると, キー
     ボード入力に復号化を用いないことを意味する.

 -- Function: terminal-coding-system
     この関数は, 端末出力の符号化に用いているコーディングシステムを返
     す.  コーディングシステムを使用していなければ`nil'を返す.

 -- Function: set-terminal-coding-system CODING-SYSTEM
     この関数は, 端末出力の符号化に使用するコーディングシステムとして
     CODING-SYSTEMを指定する.  CODING-SYSTEMが`nil'であると, 端末出力
     に符号化を用いないことを意味する.



File: elisp-ja, Node: MS-DOS File Types, Next: Input Methods, Prev: Terminal I/O Encoding, Up: Coding Systems

MS-DOSのファイル型
------------------

MS-DOSやMS-Windows上のEmacsは, 特定のファイル名をテキストファイルやバ
イナリファイルとして認識します.  『バイナリファイル』とは, 必ずしも文
字を意味しないバイト値のファイルです.  Emacsは, バイナリファイルに対し
ては行末変換や文字コード変換を行いません.  一方, その名前から『テキス
トファイル』と印が付いた新規ファイルを作成すると, EmacsはDOSの行末変換
を行います.

 -- Variable: buffer-file-type
     この変数は, 各バッファで自動的にバッファローカルになり, バッファ
     で訪問したファイルのファイル型を記録する.  バッファが
     `buffer-file-coding-system'でコーディングシステムを指定しない場合, 
     バッファ内容を書き出すときに用いるコーディングシステムをこの変数
     を用いて決定する.  テキストに対しては`nil', バイナリに対して`t'で
     あること.  これが`t'であると, コーディングシステムは
     `no-conversion'である.  さもなければ, `undecided-dos'を用いる.

     通常, この変数はファイルを訪問すると設定される.  いかなる変換も行
     わずにファイルを訪問すると`nil'に設定される.

 -- User Option: file-name-buffer-file-type-alist
     この変数は, テキスト／バイナリファイルを認識するための連想リスト
     を保持する.  各要素は(REGEXP . TYPE)の形である.  ここで, REGEXPは
     ファイル名に対して一致をとり, TYPEは, テキストファイルでは`nil', 
     バイナリファイルでは`t', あるいは, どちらであるかを計算するために
     呼び出す関数である.  それが関数であると, 1つの引数（ファイル名）
     で呼ばれ, `t'か`nil'を返すこと.

     MS-DOSやMS-Windowsで動作しているEmacsは, この連想リストを調べて, 
     ファイルを読む際に使用するコーディングシステムを決定する.  テキス
     トファイルでは`undecided-dos'が使われる.  バイナリファイルでは
     `no-conversion'が使われる.

     指定したファイルがこの連想リストの要素に一致しないと,
     `default-buffer-file-type'がファイルの扱い方を指定する.

 -- User Option: default-buffer-file-type
     この変数は, `file-name-buffer-file-type-alist'が指定しない型のファ
     イルの扱い方を指定する.

     この変数が`nil'以外であると, そのようなファイルはバイナリとして扱
     われ, コーディングシステム`no-conversion'を用いる.  さもなければ
     それらに対して特別なことを行わずに, Emacsの通常のとおりにファイル
     内容からコーディングシステムを決定する.



File: elisp-ja, Node: Input Methods, Next: Searching and Matching, Prev: Coding Systems, Up: Non-ASCII Characters

入力方式
========

"入力方式"（input method）は, キーボードから非ASCII文字を入力する簡便
な方法を提供します.  プログラムが読み取るための非ASCII文字の符号変換を
行うコーディングシステムと異なり, 入力方式は人間向けのコマンドを提供し
ます.  （テキストを入力するための入力方式の使い方については, *Note 入
力方式: (emacs-ja)Input Methods. ）入力方式の定義方法については本書で
はまだ明文化してありませんが, ここではそれらの使い方について述べます.

各入力方式には名前があります.  それは現在のところ文字列ですが, 将来は
入力方式名としてシンボルも使えるようになります.

 -- Variable: current-input-method
     この変数は, カレントバッファで現在活性な入力方式の名前を保持する. 
     （この変数に設定すると自動的にバッファローカルになる. ）`nil'であ
     ると, バッファでは入力方式が活性ではない.

 -- Variable: default-input-method
     この変数は, 入力方式を選ぶコマンド向けのデフォルトの入力方式を保
     持する.  `current-input-method'と異なり, この変数は通常はグローバ
     ルである.

 -- Function: set-input-method INPUT-METHOD
     この関数は, カレントバッファにおいて入力方式INPUT-METHODを活性に
     する.  `default-input-method'にもINPUT-METHODを設定する.
     INPUT-METHODが`nil'であると, この関数はカレントバッファの入力方式
     を不活性にする.

 -- Function: read-input-method-name PROMPT &optional DEFAULT INHIBIT-NULL
     この関数は, プロンプトPROMPTを用いてミニバッファで入力方式名を読
     む.  DEFAULTが`nil'以外であると, ユーザーが空の入力をするとデフォ
     ルトでこれを返す.  しかし, INHIBIT-NULLが`nil'以外であると, 空の
     入力はエラーを通知する.

     戻り値は文字列である.

 -- Variable: input-method-alist
     この変数は, 使用可能なすべての入力方式を定義する.  各要素は1つの
     入力方式を定義し, つぎの形であること.

          (INPUT-METHOD LANGUAGE-ENV ACTIVATE-FUNC
           TITLE DESCRIPTION ARGS...)

     ここで, INPUT-METHODは入力方式名であり文字列である.  LANGUAGE-ENV
     も別の文字列であり当該入力方式を推奨する言語環境の名前である. 
     （これは説明文目的のためだけである. ）

     TITLEは, この入力方式が活性である場合にモード行に表示される文字列
     である.  DESCRIPTIONはこの入力方式と何向きであるかを説明する文字
     列である.

     ACTIVATE-FUNCは, この入力方式を活性にするために呼び出す関数である.
     ARGSがあればACTIVATE-FUNCへの引数として渡される.  つまり,
     ACTIVATE-FUNCの引数はINPUT-METHODとARGSである.

入力方式に対する基本的なインターフェイスは変数`input-method-function'
を介して行います.  *Note Reading One Event::.



File: elisp-ja, Node: Searching and Matching, Next: Syntax Tables, Prev: Non-ASCII Characters, Up: Top

探索と一致
**********

GNU Emacsにはバッファから指定したテキストを探す方法が2つあります.  文
字列そのものを正確に探索するのと正規表現の探索です.  正規表現の探索の
あとでは, 正規表現全体やそのさまざまな部分に一致したテキストを表す"マッ
チデータ"（match data）を調べることができます.

* Menu:

* String Search::         Search for an exact match.
* Regular Expressions::   Describing classes of strings.
* Regexp Search::         Searching for a match for a regexp.
* POSIX Regexps::         Searching POSIX-style for the longest match.
* Search and Replace::	  Internals of `query-replace'.
* Match Data::            Finding out which part of the text matched
                            various parts of a regexp, after regexp search.
* Searching and Case::    Case-independent or case-significant searching.
* Standard Regexps::      Useful regexps for finding sentences, pages,...

`skip-chars...'などの関数もある種の探索を行います.  *Note Skipping
Characters::.



File: elisp-ja, Node: String Search, Next: Regular Expressions, Prev: Searching and Matching, Up: Searching and Matching

文字列の探索
============

これらは, バッファ内のテキストを探索するための基本関数です.  これらは
プログラムで使うことを意図していますが, 対話的に呼び出すこともできます. 
その場合, 探索文字列を問い合わせてきますが, LIMITとNOERRORは`nil'に,
REPEATは1に設定されます.

これらの探索関数は, バッファがマルチバイトであると探索文字列をマルチバ
イトに変換します.  バッファがユニバイトであると探索文字列をユニバイト
に変換します.  *Note Text Representations::.

 -- コマンド: search-forward STRING &optional LIMIT NOERROR REPEAT
     この関数は, ポイントから前方へ向けて文字列STRINGにちょうど一致す
     るものを探す.  それに成功すれば, ポイントをみつけた出現箇所の末尾
     に移動し, ポイントの新たな値を返す.  一致がみつからなければ, 戻り
     値と副作用はNOERRORに依存する（下記参照）.

     つぎの例では, ポイントは始めは行頭にある.  そして`(search-forward
     "fox")'は`fox'の最後の文字のうしろにポイントを移動する.

          ---------- Buffer: foo ----------
          -!-The quick brown fox jumped over the lazy dog.
          ---------- Buffer: foo ----------

          (search-forward "fox")
               => 20

          ---------- Buffer: foo ----------
          The quick brown fox-!- jumped over the lazy dog.
          ---------- Buffer: foo ----------

     引数LIMITは探索の上限を指定する.  （カレントバッファ内の位置であ
     ること. ）その位置を越える箇所での一致は受け入れない.  LIMITを省
     略したり`nil'であると, デフォルトは, バッファの参照可能部分の末尾
     である.

     探索に失敗した場合の動作は, NOERRORの値に依存する.  NOERRORが
     `nil'であると, エラー`search-failed'を通知する.  NOERRORが`t'であ
     ると, `search-forward'は`nil'を返しなにもしない.  NOERRORが`nil'
     でも`t'でもないと, `search-forward'はポイントを上限位置へ移動して
     `nil'を返す.  （この場合にもポイントの新たな値を返すほうが一貫性
     があるが, 値`nil'に依存しているプログラムがある. ）

     REPEATを指定してあると（正の数であること）, その回数だけ探索を繰
     り返す（一致箇所の末尾を新たな探索の開始位置とする）.  連続してこ
     れらの探索に成功すると関数は成功し, ポイントを移動してその新たな
     値を返す.  さもなければ探索は失敗である.

 -- コマンド: search-backward STRING &optional LIMIT NOERROR REPEAT
     この関数は, ポイントから後方へ向けてSTRINGを探索する.
     `search-forward'と同様であるが, 後方へ向けて探索し一致箇所の先頭
     にポイントを置く点が異なる.

 -- コマンド: word-search-forward STRING &optional LIMIT NOERROR REPEAT
     この関数は, ポイントから前方へ向けてSTRINGに一致する『単語』を探
     索する.  一致をみつけると, 一致箇所の末尾にポイントを設定しポイン
     トの新たな値を返す.

     単語の一致では, STRINGを単語の列とみなし, それらを区切る句読点は
     無視する.  バッファ内の同じ単語の列を探す.  バッファ内の各単語は
     別々になっている必要があるが（単語`ball'を探索すると単語`balls'に
     は一致しない）, 句読点や空白の詳細は無視される（`ball boy'を探索
     すると`ball.  Boy!'に一致する）.

     つぎの例では, ポイントは始めはバッファの先頭にある.  探索するとポ
     イントは`y'と`!'のあいだに移動する.

          ---------- Buffer: foo ----------
          -!-He said "Please!  Find
          the ball boy!"
          ---------- Buffer: foo ----------

          (word-search-forward "Please find the ball, boy.")
               => 35

          ---------- Buffer: foo ----------
          He said "Please!  Find
          the ball boy-!-!"
          ---------- Buffer: foo ----------

     LIMITが`nil'以外（カレントバッファ内の位置）であると, それは探索
     の上限を指定する.  みつかった一致箇所はその位置を越えてはならない.

     NOERRORが`nil'であると, 探索に失敗するとエラー
     `word-search-failed'を通知する.  NOERRORが`t'であると, エラーを通
     知するかわりに`nil'を返す.  NOERRORが`nil'でも`t'でもないと, ポイ
     ントをLIMIT（あるいはバッファの末尾）へ移動して`nil'を返す.

     REPEATが`nil'以外であると, その回数だけ探索を繰り返す.  ポイント
     は最後の一致箇所の末尾へ置かれる.

 -- コマンド: word-search-backward STRING &optional LIMIT NOERROR REPEAT
     この関数はポイントから後方へ向けてSTRINGに一致する単語を探索する. 
     この関数は`word-search-forward'と同様であるが, 後方へ向けて探索し
     一致箇所の先頭にポイントを置く点が異なる.



File: elisp-ja, Node: Regular Expressions, Next: Regexp Search, Prev: String Search, Up: Searching and Matching

正規表現
========

"正規表現"（regular expression, 略して"regexp"）は, 文字列の（無限の可
能性もある）集合を表すパターンです.  正規表現への一致を探すことは, 非
常に強力な操作です.  本節では, 正規表現の書き方を説明します.  続く節で
は, それらを探索する方法を説明します.

* Menu:

* Syntax of Regexps::       Rules for writing regular expressions.
* Regexp Example::          Illustrates regular expression syntax.



File: elisp-ja, Node: Syntax of Regexps, Next: Regexp Example, Prev: Regular Expressions, Up: Regular Expressions

正規表現の構文
--------------

正規表現では, 数個の文字が特別な構成であり, 残りは"普通"です.  普通の
文字は, その文字だけに一致する単純な正規表現です.  特別な文字は, `.',
`*', `+', `?', `[', `]', `^', `$', `\'であり, 将来新たな文字が定義され
ることはありません.  正規表現に現れるこれら以外の文字は, まえに`\'がな
い限り普通の文字です.

たとえば, `f'は特別な文字ではないので普通の文字です.  ですから, `f'は
文字列`f'だけに一致する正規表現です.  （これは文字列`ff'には一致しない. 
）同様に, `o'は`o'だけに一致する正規表現です.

任意の2つの正規表現AとBを連結できます.  その結果は, Aが文字列の始めの
部分に一致し, かつ, Bがその文字列の残りに一致するときにその文字列に一
致する正規表現になります.

簡単な例として, 正規表現 `f'と`o'を連結して正規表現`fo'を得られます. 
これは文字列`fo'だけに一致します.  これは明らかですね.  より強力なこと
をするには, 特別な文字の1つを使う必要があります.  それらの一覧を以下に
示します.

`.' （ピリオド）
     特別な文字であり, 改行以外の任意の1文字に一致する.  連結を使って
     `a.b'のような正規表現を作れる.  これは, `a'で始まり`b'で終る任意
     の3文字の文字列に一致する.

`*'
     単独では構成要素ではない.  直前の正規表現を可能な限り反復すること
     を意味する後置演算子である.  すなわち, `o*'は（`o'が存在しない場
     合も含めて）任意個の`o'に一致する.

     `*'はつねに先行する*最小*の正規表現に適用される.  したがって,
     `fo*'は`fo'を繰り返すのではなく, `o'を繰り返す.  この正規表現は
     `f', `fo', `foo'などに一致する.

     `*'を用いた構成の一致を処理するときには, ただちに得られる限りの反
     復回数に展開される.  そうしてから, 残りのパターンを処理する.  一
     致に失敗するとバックトラック（後戻り）が発生して, `*'を用いた構成
     の反復回数を減らしてパターンの残りの部分が一致できるようにする. 
     たとえば, 文字列`caaar'に対して`ca*ar'を一致させることを考えてみ
     る.  始めに, `a*'を3つの`a'すべてに一致させようとする.  しかし, 
     残りのパターンが`ar'なのに`r'しか残っていないため, この試みは失敗
     する.  そこで, つぎは`a*'を`a'2つだけに一致させる.  こうすると, 
     残りの正規表現も正しく一致する.

     入れ子にした反復演算子がバックトラックのループを指定する場合, そ
     れはとても遅くなる.  たとえば, 正規表現`\(x+y*\)*a'を
     `xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz'の列に一致させると最終的に
     失敗するまで何時間も費してしまう.  遅さの原因は, Emacsは35個の`x'
     をグループに分ける各方法をすべて試してからでないとそれらが一致し
     ないことを結論できないからである.  読者の正規表現が素早く動作する
     ことを保証するために, 入れ子になった繰り返しを注意深く調べること.

`+'
     `*'に似た後置演算子だが, 直前の正規表現に1回以上一致する必要があ
     る.  たとえば, `ca+r'は, 文字列`car'や`caaaar'には一致するが, 文
     字列`cr'には一致ない.  一方, `ca*r'の場合は, 上記の3つすべてに一
     致する.

`?'
     `*'に似た後置演算子だが, 直前の正規表現に1回だけ一致するか, ある
     いは, 1回も一致しない.  たとえば, `ca?r'は, `car'や`cr'に一致する
     が, 他のものには一致しない.

`[ ... ]'
     `['で始まり`]'で終る"文字選択"を表す.  もっとも単純な場合は, この
     2つの中括弧のあいだにある文字の1つ1つがこの文字選択に一致する.

     したがって, `[ad]'は, `a'1文字か`d'1文字のどちらにも一致する.
     `[ad]*'は, `a'と`d'だけから成る（空の文字列を含む）任意の文字列に
     一致する.  このことから, `c[ad]*r'は, `cr', `car', `cdr',
     `caddaar'などに一致することがわかる.

     文字選択には, 文字範囲の指定を含めることもでき, 始めの文字と終り
     の文字のあいだに`-'を書く.  つまり, `[a-z]'はすべてのASCII小英文
     字に一致する.  範囲指定と個々の文字を自由に織り混ぜてよく,
     `[a-z$%.]'のように書ける.  これは, 任意のASCII小英文字, `$', `%', 
     ピリオドに一致する.
 
     正規表現`[\200-\377]'ですべての非ASCII文字につねに一致するとは限
     らない.  ユニバイト（*Note Text Representations::）のバッファや文
     字列を探索するときにはうまく働くが, マルチバイトのバッファや文字
     列では多くの非ASCII文字のコードは8進数0377より大きいために働かな
     い.  しかし, 正規表現`[^\000-\177]'は, ASCII文字のみを除外してい
     るため, マルチバイト表現でもユニバイト表現でもすべての非ASCII文字
     に一致する.

     範囲指定の始めと終りは同じ文字集合（*Note Character Sets::）に属
     している必要がある.  したがって, `[a-\x8e0]'は正しくない.  `a'は
     ASCII文字集合に属し, 文字0x8e0（グレーブアクセント付き`a'）は
     EmacsのLatin-1の文字集合に属しているからである.

     正規表現の普通の特別な文字は, 文字選択の内側では特別ではないこと
     に注意.  文字選択の内側では, まったく別の文字の集まり, `]', `-',
     `^'が特別である.

     文字選択に`]'を含めるには, `]'を最初の文字として指定する必要があ
     る.  たとえば, `[]a]'は, `]'や`a'に一致する.  `-'を含めるには,
     `-'を文字選択の最初の文字か最後の文字として書くか, 範囲指定のあと
     に置く.  したがって, `[]-]'は, `]'と`-'の両方に一致する.

     文字選択に`^'を含めるには, `^'を文字選択の2番目以降に置く.

`[^ ... ]'
     `[^'は"文字選択の補集合"の始まりを意味し, 指定した文字を除く任意
     の文字に一致する.  すなわち, `[^a-z0-9A-Z]'は, 英文字と数字文字を
     *除く*すべての文字に一致する.

     `^'は文字選択の先頭になければ文字選択では特別な意味を持たない.
     `^'に続く文字は先頭にあるものとして扱われる（いいかえれば, ここで
     は`-'や`]'は特別な意味を持たない）.

     文字選択の補集合は, 一致しない文字として改行を指定しない限り, 改
     行にも一致する.  この点は, `grep'のようなプログラムでの正規表現の
     扱い方と対照的である.

`^'
     空の文字列に一致する特別な文字であり, 一致を取る対象のテキストの
     行頭のみに一致する.  それ以外では, 一致に失敗する.  したがって,
     `^foo'は, 行頭にある`foo'に一致する.

     バッファのかわりに文字列と一致を取るときには, `^'は文字列の先頭や
     改行文字`\n'のうしろに一致する.

`$'
     `^'と同様だが行末のみに一致する.  したがって, `x+$'は, 行末にある
     1文字以上の`x'から成る文字列に一致する.

     バッファのかわりに文字列と一致を取るときには, `$'は文字列の末尾や
     改行文字`\n'のまえに一致する.

`\'
     2つの機能がある.  （`\'を含む）特別な文字をクォートする（意味を抑
     える）ことと, 特別な構成を導入することである.

     `\'は特別な文字をクォートするので, `\$'は文字`$'だけに一致する正
     規表現, `\['は文字`['だけに一致する正規表現, といった具合になる.

     `\'にはLisp文字列の入力構文（*Note String Type::）でも特別な意味
     があり, `\'でクォートする必要があることに注意してほしい.  たとえ
     ば, 文字`\'に一致する正規表現は`\\'である.  文字群`\\'を含むLisp
     文字列を書くには, 各`\'をクォートするために`\'が必要である.  した
     がって, `\'に一致する正規表現の入力構文は`"\\\\"'である.

*注意：*` '従来との互換性のために, 特別な文字がそれらの特別な意味をな
しえない文脈で使われた場合には, 普通の文字として扱われる.  たとえば,
`*foo'では, `*'の対象となる正規表現が直前にないため, `*'は普通の文字と
して扱われる.  このようなふるまいに依存することはよいことではない.  特
別な文字は書く位置に関係なくクォートするべきである.

多くの場合, 任意の文字を伴う`\'はその文字だけに一致します.  しかし, い
くつか例外があって, `\'で始まる2文字列が特別な意味を持つ場合があります. 
（2文字目にくる文字は, 単独で使った場合にはつねに普通の文字として扱わ
れる. ）以下に`\'の構成を示します.

`\|'
     選択肢を指定する.  `\|'をあいだに伴った2つの正規表現AとBは, AかB
     のいずれかに一致する文字列に一致する正規表現となる.

     したがって, `foo\|bar'は, `foo'や`bar'に一致するが, それ以外の文
     字列には一致しない.

     `\|'は, 周囲にある適用しうる正規表現の中でも最大のものに適用され
     る.  `\|'によるグループ化を制限するのは, これを囲む`\( ... \)'に
     よるグループ化だけである.

     何度`\|'を使っても処理できるだけの十分なバックトラック能力がある.

`\( ... \)'
     以下の3つの目的を果たすグループ化のための構成.

       1. 他の操作に使うために一連の選択肢`\|'を括る.  したがって,
          `\(foo\|bar\)x'は, `foox'か`barx'のいずれかに一致する.

       2. 後置演算子, `*', `+', `?'を適用できるように, 複雑な正規表現
          を括る.  したがって, `ba\(na\)*'は, `bananana'のように, （0
          個以上の）任意個の文字列`na'に一致する.

       3. あとで参照できるように, 一致した部分文字列を記録する.

     最後の使い方は, 括弧によるグループ化という考え方から派生したもの
     ではない.  同一の`\( ... \)'構成に与えた2つめの別の機能である. 
     実用上, これら2つの意味が混同されることはないからである.  この機
     能をつぎに説明する.

`\DIGIT'
     D番目に現れた`\( ... \)'に一致したテキストと同じテキストに一致す
     る.

     いいかえれば, 一致を処理するときには, `\( ... \)'構成の末尾に達す
     ると, この構成に一致したテキストの始めと終りを記録する.  そして, 
     正規表現のそれよりうしろでは, 『D番目に現れた`\( ... \)'に一致し
     たテキスト』という意味でそれがなんであろうと`\'に続けて数字Dを使
     える.

     1つの正規表現内に現れる最初の9個の`\( ... \)'に一致する文字列には, 
     正規表現中で開き括弧が現れた順に, 1から9までの番号を割り振る.  そ
     のため, `\1'から`\9'で, 対応する`\( ... \)'に一致したテキストを参
     照できる.

     たとえば, `\(.*\)\1'は, 改行を含まない文字列で, かつ, 前半と後半
     が同一である文字列に一致する.  `\(.*\)'は前半部分に一致し, それは
     どのようなものでもかまわない.  一方, それに続く`\1'は, 前半部分と
     まったく同じテキストに一致しなければならない.

`\w'
     任意の単語構成文字に一致する.  エディタの構文テーブルによってこの
     文字が決まる.  *Note Syntax Tables::.

`\W'
     単語構成文字以外の文字に一致する.

`\sCODE'
     構文コードがCODEである文字だけに一致する.  ここで, CODEは構文コー
     ドを表す文字である.  つまり, `w'は単語構成要素を, `-'は白文字を,
     `('は開き括弧を表すといった具合である.  白文字の構文を表すには,
     `-'か空白のいずれかを使う.  構文コードとそれらを表す文字の一覧に
     ついては, *Note Syntax Class Table::.

`\SCODE'
     構文がCODEでない任意の文字に一致する.

つぎの正規表現は空の文字列に一致します.  つまりこれらは文字を使用しま
せんが, これらが一致するかどうか文脈に依存します.

`\`'
     空の文字列に一致するが, 一致対象であるバッファや文字列の先頭に限
     る.

`\''
     空の文字列に一致するが, 一致対象であるバッファや文字列の末尾に限
     る.

`\='
     空の文字列に一致するが, ポイント位置に限る.  （文字列に対する一致
     ではこの構文は定義されない. ）

`\b'
     空の文字列に一致するが, 単語の先頭や末尾に限る.  したがって,
     `\bfoo\b'は, 単語として独立して現れる`foo'に一致する.
     `\bballs?\b'は, 単語として独立して現れる`ball'や`balls'に一致する.

     `\b'は, バッファの先頭や末尾にあるテキストとは無関係に, バッファ
     の先頭や末尾にも一致する.

`\B'
     空の文字列に一致するが, 単語の先頭や末尾*以外*に限る.

`\<'
     空の文字列に一致するが, 単語の先頭に限る.  `\<'はバッファの先頭に
     も一致するが, 単語構成文字が続く場合に限る.

`\>'
     空の文字列に一致するが, 単語の末尾に限る.  `\>'はバッファの末尾に
     も一致するが, 単語構成文字で終了している場合に限る.

任意の文字列が正しい正規表現ではありません.  たとえば, （`[]]'のような
少数の例外を除けば）角括弧が対応していない文字列は正しくありませんし,
1つの`\'で終る文字列も正しくありません.  不正な正規表現を探索関数に渡
すと, エラー`invalid-regexp'が通知されます.

 -- Function: regexp-quote STRING
     この関数は, STRINGだけに正確に一致する正規表現の文字列を返す.  こ
     れにより, 正規表現を必要とする関数を呼び出すときにこの文字列だけ
     に正確に一致できる.

          (regexp-quote "^The cat$")
               => "\\^The cat\\$"

     `regexp-quote'の用途の1つは, 正規表現で記述された文脈に正確に一致
     する文字列を組み合わせることである.  たとえば, つぎは, 白文字で囲
     まれたSTRINGの値で表される文字列を探索する.

          (re-search-forward
           (concat "\\s-" (regexp-quote string) "\\s-"))

 -- Function: regexp-opt STRINGS &optional PAREN
     この関数は, 文字列STRINGSのいずれかに一致する効率よい正規表現を返
     す.  これは, たとえばフォントロック（font-lock）モードなどで, 可
     能な限り高速な一致や探索を行う必要がある場合に有用である.

     省略可能な引数PARENが`nil'以外であると, 返される正規表現はつねに
     少なくとも1つの括弧によるグループ構文で囲まれる.

     つぎの`regexp-opt'の簡略版定義は, 実際の値に等価な（ただしそれほ
     ど効率よくない）正規表現を生成する.

          (defun regexp-opt (strings paren)
            (let ((open-paren (if paren "\\(" ""))
                  (close-paren (if paren "\\)" "")))
              (concat open-paren
                      (mapconcat 'regexp-quote strings "\\|")
                      close-paren)))

 -- Function: regexp-opt-depth REGEXP
     この関数は, REGEXP内のグループ化構文（括弧で括った式）の総個数を
     返す.



File: elisp-ja, Node: Regexp Example, Next: Regexp Search, Prev: Syntax of Regexps, Up: Regular Expressions

複雑な正規表現の例
------------------

ここでは, 任意個数の白文字を伴った文末を認識するためにEmacsで使われて
いる複雑な正規表現について述べます.  それは変数`sentence-end'の値です.

まず, タブ文字と空白を区別するためにLisp構文の文字列として正規表現を示
します.  文字列定数はダブルクォートで始まり終ります.  `\"'は文字列の一
部としてのダブルクォート, `\\'は文字列の一部としてのバックスラッシュ,
`\t'はタブ, `\n'は改行を表します.

     "[.?!][]\"')}]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"

対照的に, 変数`sentence-end'を評価するとつぎのようになっているはずです.

     sentence-end
          => "[.?!][]\"')}]*\\($\\| $\\|  \\|  \\)[       
     ]*"

この出力では, タブと改行はそれ自身として現れています.

この正規表現には, 連続してつぎのような4つの部分が含まれています.

`[.?!]'
     パターンの最初の部分は, 3つの文字, ピリオド, 疑問符, 感嘆符のいず
     れかに一致する文字選択である.  一致部分はこれらの3つの文字の1つで
     始まる必要がある.

`[]\"')}]*'
     パターンの2番目の部分は, ピリオド, 疑問符, 感嘆符のいずれかに続く, 
     任意の閉じ括弧やクォーテーションマークの0個以上の繰り返しに一致す
     る.  `\"'は, 文字列内のダブルクォートを表すLisp構文である.  最後
     の`*'は, 直前の正規表現（この場合は文字選択）を0回以上繰り返すこ
     とを表す.

`\\($\\| $\\|\t\\|  \\)'
     パターンの3番目の部分は, 文末に続く白文字, つまり, （空白を伴うか
     もしれない）行末, 1つのタブ, 2つの空白のいずれかに一致する.  2つ
     のバックスラッシュは, 括弧や縦棒を正規表現の構文にする.  括弧はグ
     ループを区切り, 縦棒は選択肢を区切る.  ドル記号は行末に一致するた
     めに用いている.

`[ \t\n]*'
     パターンの最後の部分は, 文末に最低限必要な白文字より余計な白文字
     に一致する.



File: elisp-ja, Node: Regexp Search, Next: POSIX Regexps, Prev: Regular Expressions, Up: Searching and Matching

正規表現の探索
==============

GNU Emacsでは, 正規表現に一致するつぎの部分をインクリメンタルにもそう
でなくも探せます.  インクリメンタルサーチコマンドについては, *Note 正
規表現探索: (emacs-ja)Regexp Search.を参照してください.  ここでは, プ
ログラムで有用な探索関数のみについて述べます.  基本的なものは
`re-search-forward'です.

これらの探索関数は, バッファがマルチバイトであれば正規表現をマルチバイ
トに変換します.  バッファがユニバイトであれば, 正規表現をユニバイトに
変換します.  *Note Text Representations::.

 -- コマンド: re-search-forward REGEXP &optional LIMIT NOERROR REPEAT
     この関数は, カレントバッファにおいて前方へ向けて正規表現REGEXPに
     一致するテキストの文字列を探索する.  関数はREGEXPに一致しないテキ
     ストはすべて飛び越え, みつけた一致箇所の末尾へポイントを置く.  ポ
     イントの新たな値を返す.

     LIMITが`nil'以外（カレントバッファ内の位置であること）であると, 
     探索の上限を表す.  その位置を越える箇所での一致は受け入れない.

     REPEATを指定してあると（正の数であること）, その回数だけ探索を繰
     り返す（一致箇所の末尾を新たな探索の開始位置とする）.  連続してこ
     れらの探索に成功すると関数は成功し, ポイントを移動してその新たな
     値を返す.  さもなければ探索は失敗である.

     関数が失敗した場合の動作は, NOERRORの値に依存する.  NOERRORが
     `nil'であると, エラー`search-failed'を通知する.  NOERRORが`t'であ
     ると, `re-search-forward'はなにもせずに`nil'を返す.  NOERRORが
     `nil'でも`t'でもないと, `re-search-forward'はポイントをLIMIT（あ
     るいはバッファの末尾）へ移動して`nil'を返す.

     つぎの例では, ポイントは始めは`T'のまえにある.  探索を呼び出すと, 
     ポイントは当該行の末尾（`hat'の`t'と改行のあいだ）へ移動する.

          ---------- Buffer: foo ----------
          I read "-!-The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (re-search-forward "[a-z]+" nil t 5)
               => 27

          ---------- Buffer: foo ----------
          I read "The cat in the hat-!-
          comes back" twice.
          ---------- Buffer: foo ----------

 -- コマンド: re-search-backward REGEXP &optional LIMIT NOERROR REPEAT
     この関数は, カレントバッファにおいて後方へ向けて正規表現REGEXPに
     一致するテキストの文字列を探索し, みつけた一致箇所の先頭へポイン
     トを置く.

     この関数は`re-search-forward'に類似したものであるが, 単純な鏡像で
     はない.  `re-search-forward'は, 一致箇所の先頭が開始位置に可能な
     限り近い一致箇所を探す.  `re-search-backward'が完全な鏡像であれば, 
     一致箇所の末尾が可能な限り近い一致箇所を探す.  しかし, 実際には, 
     一致箇所の先頭が可能な限り近い一致箇所を探す.  これは, 正規表現と
     の一致をとる処理は, 指定開始位置において先頭から末尾へ向けてつね
     に行われるからである.

     `re-search-forward'の完全な鏡像には, 正規表現の一致を末尾から先頭
     へ向けて行う特別な機能が必要である.  それを実装する手間をかけるほ
     どの価値はない.

 -- Function: string-match REGEXP STRING &optional START
     この関数は, 文字列STRINGにおいて正規表現REGEXPに一致した最初の箇
     所の添字を返す.  あるいは, 一致がなければ`nil'を返す.  STARTが
     `nil'以外であると, STRINGの指定した添字から探索を始める.

     たとえばつぎのとおりである.

          (string-match
           "quick" "The quick brown fox jumped quickly.")
               => 4
          (string-match
           "quick" "The quick brown fox jumped quickly." 8)
               => 27

     文字列の最初の文字の添字は0であり, 2番目の文字の添字は1であるといっ
     た具合になる.

     この関数から戻ったあとでは, 一致箇所を越えた最初の文字の添字は
     `(match-end 0)'で得られる.  *Note Match Data::.

          (string-match
           "quick" "The quick brown fox jumped quickly." 8)
               => 27

          (match-end 0)
               => 32

 -- Function: looking-at REGEXP
     この関数は, カレントバッファ内のポイントの直後のテキストが正規表
     現REGEXPに一致するかどうかを調べる.  ここで『直後』とは, 開始位置
     は固定されていて, ポイントのうしろの最初の文字で始まる場合にのみ
     探索は成功する.  結果は, 一致すれば`t'であり, さもなければ`nil'で
     ある.

     この関数はポイントを移動しないが, マッチデータを更新する.
     `match-beginning'や`match-end'を使ってマッチデータを参照できる.

     つぎの例では, ポイントは`T'の直前にある.  ポイントがこれ以外の場
     所にあると結果は`nil'になる.

          ---------- Buffer: foo ----------
          I read "-!-The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (looking-at "The cat in the hat$")
               => t



File: elisp-ja, Node: POSIX Regexps, Next: Search and Replace, Prev: Regexp Search, Up: Searching and Matching

POSIXの正規表現探索
===================

普通の正規表現関数は, `\|'や反復構文を扱うために必要なときにはバックト
ラックしますが, これを行い続けるのは*なんらか*の一致をみつけるまでです. 
みつけてしまえば, それらは成功してみつけた最初の一致を報告します.

本節では, 正規表現の一致に関するPOSIX規格で規定された完全なバックトラッ
クを行う代替の探索関数について述べます.  それらはすべての可能性を試し
尽くしすべての一致箇所を探し終えるまでバックトラックを継続してます. 
そのため, POSIXで要求されるとおりの最長の一致を報告できるのです.  これ
は動作がとても遅いですから, 最長一致が本当に必要な場合に限ってこれらの
関数を使ってください.

 -- Function: posix-search-forward REGEXP &optional LIMIT NOERROR REPEAT
     これは`re-search-forward'と同様であるが, 正規表現の一致に関する
     POSIX規格で規定された完全なバックトラックを行う.

 -- Function: posix-search-backward REGEXP &optional LIMIT NOERROR REPEAT
     これは`re-search-backward'と同様であるが, 正規表現の一致に関する
     POSIX規格で規定された完全なバックトラックを行う.

 -- Function: posix-looking-at REGEXP
     これは`looking-at'と同様であるが, 正規表現の一致に関するPOSIX規格
     で規定された完全なバックトラックを行う.

 -- Function: posix-string-match REGEXP STRING &optional START
     これは`string-match'と同様であるが, 正規表現の一致に関するPOSIX規
     格で規定された完全なバックトラックを行う.




