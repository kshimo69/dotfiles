Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja, Node: Create Tags Table, Next: Select Tags Table, Prev: Tag Syntax, Up: Tags

タグテーブルの作成
------------------

タグテーブルファイルを作成するには, `etags'プログラムを使います.
`etags'は, 数種類の言語について, 構文を解析しタグを取り出すことができ
ます.  *Note Tag Syntax::.  つぎのように実行します.

     etags INPUTFILES...

`etags'は指定されたファイルを読み, カレント作業ディレクトリの`TAGS'と
いう名前のファイルにタグテーブルを書き出します.  `etags'は, ファイル名
とその内容から自動的に使用言語を識別します.  後述の`--language=NAME'オ
プションで, 言語を明示することもできます.

ファイルを変更するなどしてタグテーブルの内容が古くなった場合, テーブル
を更新するには, 最初にタグテーブルを作成した手順を繰り返します.  頻繁
に更新する必要はありません.

タグテーブルに記録できなかったり, 誤ったファイルを記録してしまった場合,
Emacsはタグの定義をみつけることはできません.  しかし, （タグの定義を含
んだファイルを多少編集するなどしたために）タグテーブルに記録された位置
が多少ズレている程度ならば, タグをみつけるのに通常より少し時間がかかる
だけです.  記録された位置が大幅に狂っていたとしても, Emacsはタグをみつ
けることができますが, そのためにファイル全体を調べなくてはなりません.

ですから, 新しいタグを定義したとき, タグの定義を別のファイルに移動した
とき, ファイルを相当変更したときには, タグテーブルの更新が必要です. 
しかし, ファイルを編集するつどタグテーブルを更新する必要はありませんし, 
毎日更新する必要すらないでしょう.

タグテーブルに別のタグテーブルを取り込むこともできます.  取り込むタグ
ファイル名をオプション`--include=FILE'で指定してタグファイルを作成しま
す.  このように作成したタグファイルには, 指定したソースファイルに加え
て, 取り込んだタグファイルに記録されていたファイルも含まれます.

`etags'を実行するときに相対ファイル名でソースファイルを指定すると, タ
グファイルには, タグファイルを書き出したときのディレクトリを基準にした
ファイル名が記録されます.  こうした場合, タグファイルとソースファイル
を含んだディレクトリ木構造全体を移動することができ, しかも, タグファイ
ルはソースファイルを正しく指し続けます.

`etags'の引数として絶対ファイル名を指定すると, タグファイルには絶対ファ
イル名が記録されます.  こうした場合, ソースファイルが同じ場所にある限
り, タグファイルを移動してもタグファイルは同じファイルを指し続けます. 
絶対ファイル名は, `/', あるいは, MS-DOSとMS-Windowsでは`DEVICE:/'で始
まります.

非常に多数のファイルからタグテーブルを作成する場合, コマンド行の長さを
制限しているシステムもあるので, ファイル名をコマンドラインで指定すると
きに問題が起こる可能性があります.  この制限を回避するもっとも単純な方
法は, つぎのように, ファイル名を指定する位置にダッシュを打って,
`etags'に標準入力からファイル名を読み込ませることです.

     find . -name "*.[chCH]" -print | etags -

オプション`--language=NAME'を使えば, 言語を明示的に指定できます.  この
オプションはファイル名と混ぜていくつでも使用できます.  それぞれ, あと
に続くファイル名に適用されます.  `--language=auto'を指定すると,
`etags'はファイル名とその内容からふたたび使用言語を推測します.
`--language=none'を指定すれば, 言語に依存した処理をいっさい行わないよ
うになります.  すると, `etags'は正規表現による一致だけに基づいてタグを
認識します.  `etags'が知っている言語と, 言語を推測するファイル名規則を
表示するには, `etags --help'を指定します.

`--regex'オプションは, 正規表現による一致に基づいてタグを認識させる一
般的な方法です.  このオプションとファイル名を自由に混ぜて使用できます. 
各`--regex'オプションは, それ以前に指定した正規表現に追加され, オプショ
ンのあとにあるファイルに適用されます.  オプションの構文はつぎのとおり
です.

     --regex=/TAGREGEXP[/NAMEREGEXP]/

ここで, TAGREGEXPは, 行に一致させてタグを取り出すために使われます.  こ
れはつねに位置が固定されています.  つまり, `^'が前置されているかのよう
に扱われます.  字下げ分を考慮したければ, 正規表現を`[ \t]*'で始めて, 
行頭の任意個の空白に一致するようにします.  正規表現においては, `\'は直
後の文字をクォートし, `\t'はタブ文字を表します.  `etags'では, これら以
外にはCで使われるエスケープシーケンスを扱えないことに注意してください.

`etags'の正規表現の構文は, Emacsのものと同じで, "反復回数演算子"
（interval operator）が拡張されています.  この演算子は, `grep'や`ed'で
使えるものと同じ動作をします.  反復回数演算子の構文は`\{M,N\}'であり, 
直前の正規表現のM回以上N回以下の繰り返しに一致します.

TAGREGEXPがタグとして認識したい部分よりも長く一致するようにはしないで
ください.  TAGREGEXPに一致する部分が必要以上に長くなるのが避けられない
ならば, タグの範囲を狭めるためにNAMEREGEXPを追加するとよいかもしれませ
ん.  正規表現を利用した例をいくつか紹介しましょう.

`-R'オプションは, それまでに`--regex'オプションで定義したすべての正規
表現を削除します.  つぎの使用例からもわかるように, オプションのあとに
続くファイルに適用されます.

     etags --regex=/REG1/ voo.doo --regex=/REG2/ \
         bar.ber -R --lang=lisp los.er

この例では, `etags'は, `voo.doo'と`bar.ber'に対しては, その内容から使
用言語を推定します.  さらに, `voo.doo'から余分にタグを認識するために
REG1を使い, `bar.ber'から余分にタグを認識するためにはREG1とREG2の両方
を使います.  `los.er'からタグを認識するには, Lispのタグ構文規則だけを
使い, 正規表現による一致はいっさい使いません.

別の例を示しましょう.  ここでは, シェルが解釈しないように正規表現をクォー
トします.

   * Emacsのソースファイルに含まれる`DEFVAR'マクロをタグとする.

          --regex='/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/'

   * VHDLファイルからタグを取り出す（この例は本来は単一の長い行だが, 
     印刷の関係で分割してある）.

          --language=none
          --regex='/[ \t]*\(ARCHITECTURE\|CONFIGURATION\) +[^ ]* +OF/'
          --regex='/[ \t]*\(ATTRIBUTE\|ENTITY\|FUNCTION\|PACKAGE\
          \( BODY\)?\|PROCEDURE\|PROCESS\|TYPE\)[ \t]+\([^ \t(]+\)/\3/'

   * Tclファイルからタグを取り出す（この例はNAMEREGEXPの使用例でもある）.

          --lang=none --regex='/proc[ \t]+\([^ \t]+\)/\1/'

他のオプション一覧を表示するには, `etags --help'を実行してください.



File: emacs-ja, Node: Select Tags Table, Next: Find Tag, Prev: Create Tags Table, Up: Tags

タグテーブルの選択
------------------

Emacsでは, いつでも1つの"選択された"タグテーブルがあり, タグテーブルを
使って動作するコマンドは選択されたタグテーブルを使用します.  タグテー
ブルを選択するには, `M-x visit-tags-table'と打ちます.  すると, タグテー
ブルファイル名を聞いてきます.  デフォルトのファイル名は, デフォルトディ
レクトリの`TAGS'です.

このコマンドは, ファイル名を変数`tags-file-name'に格納するだけです. 
タグテーブルを使おうとしない限り, Emacsは実際にはタグテーブルの内容を
読み込みません.  `visit-tags-table'を使わずに, 自分自身でこの変数にファ
イル名を設定してもかまいません.  この変数の初期値は`nil'です.  これは, 
タグテーブルを使うすべてのコマンドに, 使用するタグテーブルファイルを尋
ねさせることになります.

すでにタグテーブルを読み込んであるときに`visit-tags-table'を使うと, 2
つの選択肢があります.  現在のタグテーブルリストに新たにタグテーブルを
追加するか, タグテーブルリストを新規に始めるかです.  タグコマンドは, 
現在のリストにあるすべてのタグテーブルを使用します.  新たなタグテーブ
ルリストを始めると, 他のタグテーブルの*かわり*に新たなタグテーブルが使
われます.  現在のリストに新たなタグテーブルを追加すると, 他のタグテー
ブルと*ともに*新たなものも使われます.  タグコマンドがタグテーブルリス
トを走査するときには, つねにリストの先頭から始めるわけではありません. 
現在のファイルを記録しているタグテーブルがあれば, まずそれから始めてリ
ストの末尾まで進みます.  そして, リストの先頭からリストに含まれるすべ
てのタグテーブルを調べ終るまで走査を続けます.

変数`tags-table-list'に文字列のリストを設定すれば, タグテーブルの正確
なリストをあらかじめ指定できます.  たとえば, つぎのようにします.

     (setq tags-table-list
           '("~/emacs" "/usr/local/lib/emacs/src"))

この設定例では, タグコマンドは, 個人の`~/emacs'ディレクトリと
`/usr/local/lib/emacs/src'ディレクトリの（2つの）`TAGS'ファイルを見に
いきます.  上で述べたように, タグファイルを使う順番は, 対象としている
ファイルやそのファイルを記述しているタグテーブルに依存します.

`tags-file-name'と`tags-table-list'の両方に値を設定してはいけません.



File: emacs-ja, Node: Find Tag, Next: Tags Search, Prev: Select Tags Table, Up: Tags

タグの探索
----------

タグテーブルで実現されるもっとも重要な機能は, 指定したタグの定義を探し
出すことです.

`M-. TAG RET'
     タグTAGの最初の定義を探す（`find-tag'）.
`C-u M-.'
     最後に指定したタグのつぎの定義を探す.
`C-u - M-.'
     まえにみつかったタグに戻る.
`C-M-. PATTERN RET'
     名前がPATTERNに一致するタグを探す（`find-tag-regexp'）.
`C-u C-M-.'
     最後に使用したパターンに一致するつぎのタグを探する.
`C-x 4 . TAG RET'
     タグTAGの最初の定義を探し, 別のウィンドウに表示する
     （`find-tag-other-window'）.
`C-x 5 . TAG RET'
     タグTAGの最初の定義を探し, バッファを選択するための新たなフレーム
     を作る.  （`find-tag-other-frame'）.
`M-*'
     まえに`M-.'を起動した場所へ戻る.

`M-.'（`find-tag'）は, 指定したタグの定義を探すコマンドです.  まず, タ
グテーブルの中で文字列としてタグ名を探し, タグテーブルの情報を用いて, 
定義されているファイルの名前とファイル内でのおおよその文字位置を求めま
す.  続いて, `find-tag'はそのソースファイルを訪れて, ポイントをおおよ
その文字位置に移動してから, 範囲を広げながらタグの定義を探します.

（単にRETと打って）引数を指定しないと, ポイントの直前または周辺にあるS
式をTAG引数として使います.  S式に関しては, *Note Lists::.

コマンド`M-.'にタグの名前を完全に与える必要はありません.  その一部分で
十分です.  というのは, `M-.'は, 部分文字列としてTAGを含むタグをタグテー
ブルで探すからです.  もちろん, 部分一致よりも全一致のほうが望ましいで
す.  同じ部分文字列に一致する別のタグを探すには, `C-u M-.'のように
`find-tag'に数引数を指定します.  こうするとタグ名を聞いてきませんが, 
最後に使ったものと同じ部分文字列を含む別のタグをタグテーブルから探しま
す.  もし本物のMETAキーが使えるのであれば, `C-u M-.'のかわりに`M-0
M-.'と打つほうが簡単でしょう.

バッファの切り替えを伴う他のコマンドと同様に, `find-tag'にも新たなバッ
ファを別のウィンドウに表示したり, 新規作成したフレームに表示する変種が
あります.  前者は`C-x 4 .'であり, コマンド`find-tag-other-window'を起
動します.  後者は`C-x 5 .'であり, `find-tag-other-frame'を起動します.

最近にみつけたタグ位置に戻るには, `C-u - M-.'を使います.  より一般的に
は, `M-.'に負の数引数を指定します.  このコマンドは, 別のバッファへも移
動します.  `C-x 4 .'に負の数引数を指定すると, 別のウィンドウでまえのタ
グ位置に戻ります.

最近にみつけたタグ位置に戻るだけでなく, タグを*探したとき*の場所へ戻る
こともできます.  それには, コマンド`pop-tag-mark'を起動する`M-*'を使い
ます.  典型的な使い方では, `M-.'で何かの定義を調べてから, `M-*'でもと
の場所に戻ります.

`C-u - M-.'と`M-*'のどちらも, 変数`find-tag-marker-ring-length'で指定
される深さまで, 辿った経路を引き返せます.

コマンド`C-M-.'（`find-tag-regexp'）は, 指定した正規表現に一致するタグ
を訪れます.  部分文字列ではなく正規表現に一致するものであることを除け
ば, `M-.'と同じです.



File: emacs-ja, Node: Tags Search, Next: List Tags, Prev: Find Tag, Up: Tags

タグテーブルを用いた探索と置換
------------------------------

ここで紹介するコマンドは, 選択されたタグテーブルに記録されているすべて
のファイルを1つ1つ訪れては探索を行います.  これらのコマンドに対しては, 
タグテーブルは探索対象となる一連のファイルを指定するだけです.

`M-x tags-search RET REGEXP RET'
     選択されたタグテーブル内の各ファイルから指定された正規表現を探索
     する.
`M-x tags-query-replace RET REGEXP RET REPLACEMENT RET'
     選択されたタグテーブル内の各ファイルに対して,
     `query-replace-regexp'を実行する.
`M-,'
     ポイント位置から上記のコマンドのいずれかを再実行する
     （`tags-loop-continue'）.

`M-x tags-search'は, ミニバッファで正規表現を読み取り, 選択されたタグ
テーブル内のすべてのファイル1つ1つについて, 正規表現に一致する部分を探
します.  このコマンドは探索しているファイル名を表示するので, 進行状況
がわかります.  正規表現に一致する部分がみつかると, `tags-search'はすぐ
に戻ります.

一致する部分をみつけたあとに, 残りも探したくなるでしょう.  つぎの一致
を探すには, `M-,'（`tags-loop-continue'）と打って, `tags-search'を再開
します.  これは, カレントバッファの残りを探索してから, タグテーブルの
残りのファイルについても探索します.

`M-x tags-query-replace'は, タグテーブル内のすべてのファイルを対象に,
`query-replace-regexp'を実行します.  このコマンドは, 通常の`M-x
query-replace-regexp' （問い合わせ型置換）と同じく, 探索すべき正規表現
と置換文字列を読み取ります.  そして, `M-x tags-search'のように探索を行
い, 利用者の入力に応じて一致部分を処理することを繰り返します.  問い合
わせ型置換について詳しくは, *Note Replace::.

`M-x tags-query-replace'を一度起動するだけで, タグテーブル内の全ファイ
ルの置換を行うことができます.  しかし, 一時的に置換作業から抜け出して, 
問い合わせ型置換とは関係ないことを行えると便利です.  `M-,'と打てば, 問
い合わせ型置換を再開できます.  このコマンドは, 最後に行ったタグの探索
コマンドか置換コマンドを再開します.

ここで紹介したコマンドは, `find-tag'系列のコマンドよりも, 幅広い探索を
実行します.  `find-tag'コマンドは, 指定した部分文字列や正規表現に一致
するタグの定義だけをみつけます.  コマンド`tags-search'と
`tags-query-replace'は, 通常の探索コマンドや置換コマンドがカレントバッ
ファで行うように, 正規表現に一致するあらゆる部分を探し出します.

これらのコマンドは, （Emacsバッファにまだ訪れていないものに対しては）
探索すべきファイル用に一時的なバッファを作成します.  一致部分がみつか
らなければバッファはただちに消されますが, みつかれば存続します.

`tags-search'は, `grep'プログラムにたいへんよく似ていると思われたかも
しれません.  Emacsの下位プロセスとして`grep'を実行して, Emacsに一致し
た行を1つずつ表示させることもできます.  これは, コンパイルを実行するの
と同じように動作します.  `grep'が一致を検出したソース箇所を探すことは, 
コンパイルエラーを探すのと同様に動作します.  *Note Compilation::.
        


File: emacs-ja, Node: List Tags, Next: Emerge, Prev: Tags Search, Up: Tags

タグテーブルの照会
------------------

`M-x list-tags RET FILE RET'
     プログラムファイルFILEで定義されているタグの一覧を表示する.
`M-x tags-apropos RET REGEXP RET'
     REGEXPに一致するすべてのタグを表示する.

`M-x list-tags'は, 選択されたタグテーブルに記載されているファイルのど
れか1つのファイル名を読み取り, そのファイルで定義されているすべてのタ
グを表示します.  引数の『ファイル名』は, タグテーブルに記録されたファ
イル名と単純に文字列として比較されます.  ファイル名というよりは, 文字
列として読まれます.  したがって, 補完やデフォルトはありませんし, タグ
テーブルに格納されているとおりに正確にファイル名を入力する必要がありま
す.  タグテーブル内のファイル名にディレクトリが含まれない限り, ファイ
ル名にもディレクトリを含めてはいけません.

`M-x tags-appropos'は, タグに対する`apropos'にあたります （*Note
Apropos::）.  このコマンドは, 正規表現を読み取り, 選択されたタグテーブ
ルの中から正規表現に一致する項目のタグをすべてみつけだし, そのタグ名を
表示します.

現在のタグテーブルに含まれるタグ名を名前空間として, バッファ内で補完を
行うこともできます.  *Note Symbol Completion::.



File: emacs-ja, Node: Emerge, Next: C Modes, Prev: Tags, Up: Programs

emergeを用いたファイルの併合
============================

ちょっとしたミスで, 1つのプログラムから2つの別の版を作ってしまうことも
あります.  この混乱した状態を収拾するには, それらを併合する必要があり
ます.  emergeを使うと, 併合作業が容易になります.  手動で比較するコマン
ドについては, *Note Comparing Files::と*Note Emerge: (ediff)Emerge.を
参照してください.

* Menu:

* Overview of Emerge::	How to start Emerge.  Basic concepts.
* Submodes of Emerge::	Fast mode vs. Edit mode.
			  Skip Prefers mode and Auto Advance mode.
* State of Difference::	You do the merge by specifying state A or B
			  for each difference.
* Merge Commands::	Commands for selecting a difference,
			  changing states of differences, etc.
* Exiting Emerge::	What to do when you've finished the merge.
* Combining in Emerge::	    How to keep both alternatives for a difference.
* Fine Points of Emerge::   Misc.



File: emacs-ja, Node: Overview of Emerge, Next: Submodes of Emerge, Prev: Emerge, Up: Emerge

emergeの概要
------------

以下の4つのコマンドのいずれかでemergeを実行します.

`M-x emerge-files'
     指定した2つのファイルを併合する.

`M-x emerge-files-with-ancestor'
     共通の祖先を参照しながら, 指定した2つのファイルを併合する.

`M-x emerge-buffers'
     2つのバッファを併合する.

`M-x emerge-buffers-with-ancestor'
     3番目のバッファに入っている共通の祖先を参照しながら, 2つのバッファ
     を併合する.

emergeコマンドは, 2つのファイル, あるいは, 2つのバッファを比較して, 比
較結果を3つのバッファ, つまり, 各入力テキストに1つずつ（"Aバッファ"と
"Bバッファ"）と, 併合を実施するバッファ（"併合バッファ"）に表示します. 
併合バッファには, 比較によって得られる差分だけでなく, 併合したテキスト
全体が表示されます.  2つの入力テキストが相違している箇所については, ど
ちらのテキストを併合バッファに含めるか選択できます.

既存のバッファを入力源とするemergeコマンドでは, 入力バッファがナロイン
グされていると, バッファの参照可能な部分だけを使います（*Note
Narrowing::）.

併合したい2つのテキストのもとである共通の祖先にあたる版を利用できると
きには, emergeはそれを使ってどちらの選択肢が正しいのか推測します.  一
方の入力と祖先との一致部分がどこかにあれば, もう一方の入力には併合結果
に残すべき意図的な変更がなされていると推測します.  共通の祖先のテキス
トを指定するには, 名前に`with-ancestor'の付いたコマンドを使ってくださ
い.  これらのコマンドは, A版, B版, 共通の祖先に対応する3つのファイル名
かバッファ名を読み取ります.

入力を比較してバッファの準備を終えると, つぎは対話的な併合作業が始まり
ます.  併合バッファで特別な"併合コマンド"を打って併合作業を制御します. 
併合バッファには, 単なる差分ではなく併合したテキスト全体が表示されます. 
入力テキストの各相違箇所に対して, どちら側を残すか選択したり, 両者をも
とにして編集できます.

併合バッファでは, emergeモードと呼ばれる特別なメジャーモードが使われ, 
これらを選択するコマンドがあります.  もちろん, 通常のEmacsコマンドでバッ
ファを編集することもできます.

emergeの注意は, いつでも"注目"相違箇所と呼ばれる相違箇所に向けられてい
ます.  3つのバッファ内では, 注目相違点はつぎのように印が付けられます.

     vvvvvvvvvvvvvvvvvvvv
     TEXT THAT DIFFERS
     ^^^^^^^^^^^^^^^^^^^^

emergeはすべての相違箇所に順に番号をふります.  さらに, モード行にはつ
ねに注目相違箇所の番号が表示されます.

通常, 併合バッファはA版の内容で始まります.  しかし, A版の内容が共通の
祖先の内容と一致するときには, 併合バッファはB版の内容で始まります.

emergeを終えると, 併合バッファにはその時点の併合済みテキストが残ります.
emerge終了時には, `C-x C-w'でファイルに保存できます.  `emerge-files'や
`emerge-files-with-ancestor'に数引数を指定すると, ミニバッファで出力ファ
イル名を読み取ります.  （どちらの場合でも, これがいちばん最後に聞かれ
るファイル名. ）すると, emerge終了時には, 併合済みのテキストがその出力
ファイルに保存されます.

emergeを終えると, 通常, emergeコマンドが併合バッファをファイルに保存し
ます.  emergeを`C-]'でアボートするとemergeコマンドは併合バッファを保存
しませんが, 必要ならばユーザー自身で保存できます.



File: emacs-ja, Node: Submodes of Emerge, Next: State of Difference, Prev: Overview of Emerge, Up: Emerge

emergeのサブモード
------------------

併合コマンドを指示するためのモードが2つ, つまり, 高速モード（Fast mode）
と編集モード（Edit mode）があり, どちらかを選べます.  高速モードでは, 
基本的な併合コマンドは1文字で表され, 通常のEmacsコマンドは禁止されてい
ます.  併合コマンドだけを使用するのであれば, 高速モードが便利です.  編
集モードでは, すべての併合コマンドはプレフィックス`C-c C-c'で始まり, 
通常のEmacsコマンドも使えます.  このモードでは, 併合バッファを編集でき
ますが, emergeの処理は遅くなります.

編集モードに切り替えるには`e'を使い, 高速モードに切り替えるには`C-c
C-c f'を使います.  モード行には, 編集モードは`E', 高速モードは`F'と表
示されます.

emergeには, 特定の併合コマンドの動作に影響を与えるサブモードがさらに2
つあります.  自動前進（auto-advance）モードと優先箇所スキップ
（skip-prefers）モードです.

自動前進モードがオンであると, コマンド`a'と`b'は, 自動的につぎの相違箇
所にポイントを進めます.  このモードでは, どちらかの入力だけを選ぶ状況
である限り, 高速に併合を行えます.  モード行には`A'と表示され, 自動前進
モードであるを示します.

優先箇所スキップモードがオンであると, コマンド`n'と`p'は, A優先／B優先
の状態にある相違箇所をスキップします（*Note State of Difference::）. 
つまり, どちらの版も『正しい』と推定されない相違箇所だけを調べことにな
ります.  モード行には`S'と表示され, 優先箇所スキップモードであることを
示します.

自動前進モードをオン／オフするには, コマンド`s a'
（`emerge-auto-advance-mode'）を使います.  優先箇所スキップモードをオ
ン／オフするには, コマンド`s s'（`emerge-skip-prefers-mode'）を使いま
す.  どちらのコマンドも, 正の数引数を指定するとオンにし, 負あるいは0の
数引数を指定するとオフにし, 引数を指定しないとトグル（切り替え）します.



File: emacs-ja, Node: State of Difference, Next: Merge Commands, Prev: Submodes of Emerge, Up: Emerge

相違箇所の状態
--------------

併合バッファ内では, 相違箇所は`v'と`^'の文字だけの行に挟まれて示されま
す.  各相違箇所は, つぎの7つのいずれかの状態になっています.

状態A
     この相違箇所はA版の内容である.  `a'コマンドは必ずこの状態にする. 
     モード行には`A'と表示される.

状態B
     この相違箇所はB版の内容である.  `b'コマンドは必ずこの状態にする. 
     モード行には`B'と表示される.

デフォルトA
デフォルトB
     まだ決心していないので, 『デフォルト』で, 相違箇所は状態A（A版の
     内容）か状態B（B版の内容）である.  どちらかの選択肢が『優先される』
     （下記参照）場合を除いて, 相違箇所はすべてデフォルトAで始まる（つ
     まり, 併合バッファの内容はAバッファのコピー）.

     相違箇所を選択すると, その状態は, デフォルトAやデフォルトBから状
     態Aや状態Bに遷移する.  つまり, 一度でも選択した相違箇所は, デフォ
     ルトAやデフォルトBの状態であることはなく, これらの状態はけっして
     モード行には表示されない.

     デフォルトの状態として, コマンド`d a'はデフォルトAを選び, `d b'デ
     フォルトBを選ぶ.  これらのコマンドで選んだデフォルトの状態は, 一
     度も選択してなく, かつ, どちらの版も優先されない相違箇所に適用さ
     れる.  併合作業を先頭から順に行っている場合, 最後に選択した相違箇
     所に続く相違箇所群が一度も選択されていないものである.  したがって, 
     先頭から順に進めるのであれば, `d a'と`d b'を使い分けて, 併合バッ
     ファのある部分ではA版をデフォルトとし, 別の部分ではB版をデフォル
     トとすることができる.

優先A
優先B
     どちらかが"優先され"ているので, 相違箇所は状態A（A版の内容）か状
     態B（B版の内容）である.  つまり, 明示的にはまだ選択していないが, 
     当該箇所では, 一方の版が共通の祖先に一致するため, 他方の版のほう
     が正しく思われるのである.  したがって, Aバッファが共通の祖先と一
     致する箇所では, 実際に変更されたほうが正しいものである可能性があ
     るので, B版が優先される.

     これらの2つの状態は, モード行では`A*'や`B*'と表示される.

混合状態
     `x c'や`x C'コマンドの結果, 相違箇所は, 状態A（A版の内容）と状態B
     （B版の内容）の混合状態になっている.

     相違箇所がいったんこの状態になると, コマンド`a'や`b'に数引数を指
     定しない限り, 何もしない.

     この状態は, モード行では`comb'と表示される.



File: emacs-ja, Node: Merge Commands, Next: Exiting Emerge, Prev: State of Difference, Up: Emerge

併合コマンド
------------

ここでは, 高速モードの併合操作コマンドを示します.  編集モードでは, こ
れらのコマンドのまえに`C-c C-c'を付けます.

`p'
     まえの相違箇所を選択する.

`n'
     つぎの相違箇所を選択する.

`a'
     この相違箇所をA版にする（状態A）.

`b'
     この相違箇所をB版にする（状態B）.

`C-u N j'
     番号Nの相違箇所を選択する.

`.'
     ポイントを含む相違箇所を選択する.  このコマンドは, 併合バッファ,
     Aバッファ, Bバッファのいずれでも使える.

`q'
     終了する.  併合作業を完了.

`C-]'
     アボートする.  併合作業をやめ, 併合結果も保存しない.

`f'
     高速モードに移行する.  （編集モードでは, 実際には`C-c C-c f'コマ
     ンド. ）

`e'
     編集モードに移行する.

`l'
     3つのウィンドウすべてを（`C-l'のように）再表示する.

`-'
     数引数の一部を指定する.

`DIGIT'
     これも, 数引数の一部を指定する.

`d a'
     併合バッファのこれ以降では, A版を選ぶ（デフォルトA）.

`d b'
     併合バッファのこれ以降では, B版を選ぶ（デフォルトB）.

`c a'
     この相違箇所のA版のテキストをキルリングにコピーする.

`c b'
     この相違箇所のB版のテキストをキルリングにコピーする.

`i a'
     この相違箇所のA版のテキストをポイント位置に挿入する.

`i b'
     この相違箇所のB版のテキストをポイント位置に挿入する.

`m'
     相違箇所の周りにポイントとマークを設定する.

`^'
     3つのウィンドウすべてを（`M-v'のように）下にスクロールする.

`v'
     3つのウィンドウすべてを（`C-v'のように）上にスクロールする.

`<'
     3つのウィンドウすべてを（`C-x <'のように）左にスクロールする.

`>'
     3つのウィンドウすべてを（`C-x >'のように）右にスクロールする.

`|'
     3つのウィンドウすべてで, 水平方向のスクロール分をリセットする.

`x 1'
     併合バッファを表示しているウィンドウの高さを1行に縮小する.  （フ
     ルサイズに戻すには`C-u l'を使う. ）

`x c'
     この相違箇所の2つの版を混合する（*Note Combining in Emerge::）.

`x f'
     emergeで作業しているファイル／バッファの名前を, ヘルプ用ウィンド
     ウに表示する.  （ウィンドウをもとの状態に戻すには`C-u l'を使
     う. ）

`x j'
     この相違箇所を, つぎの相違箇所と結合する.  （`C-u x j'では, まえ
     の相違箇所と結合する. ）

`x s'
     この相違箇所を2つに分割する.  このコマンドを使うまえに, 3つのバッ
     ファそれぞれで, 相違箇所を分割したい位置にポイントを移動しておく.

`x t'
     相違箇所の先頭や末尾にある同じ行を取り去る.  このような行が現れる
     のは, A版とB版は一致しているが, 共通の祖先とは一致しない場合.



File: emacs-ja, Node: Exiting Emerge, Next: Combining in Emerge, Prev: Merge Commands, Up: Emerge

emergeの終了
------------

`q'コマンド（`emerge-quit'）は, 併合を終了し, 出力ファイルを指定してあ
れば, そこに結果を保存します.  AバッファとBバッファは正しい内容に復元
されますが, emergeがAバッファとBバッファを作成して, かつ, 編集されてい
なければ, それらをキルします.  さらに, 併合バッファでのemergeコマンド
を使用禁止にします.  というのは, これ以降に併合コマンドを実行するとさ
まざまなバッファが悪影響を受ける可能性があるからです.

`C-]'は, 併合作業をアボートします.  つまり, 出力ファイルに書き出さずに
終ります.  出力ファイルを指定していなければ, 併合作業をアボートしよう
が終了しようが, 何の違いもありません.

他のLispプログラムからemergeコマンドが呼び出された場合, 正しく終了する
と`t', アボートしたときは`nil'が返されます.



File: emacs-ja, Node: Combining in Emerge, Next: Fine Points of Emerge, Prev: Exiting Emerge, Up: Emerge

2つの版の混合
-------------

相違箇所によっては, *両方*の版を残したいこともあるでしょう.  そのよう
な場合には, `x c'を使います.  すると, 併合バッファはつぎのようになりま
す.

     #ifdef NEW
     VERSION FROM A BUFFER
     #else /* not NEW */
     VERSION FROM B BUFFER
     #endif /* not NEW */

この例では, 2つの版をCのプリプロセッサの条件節で分けていますが, 変数
`emerge-combine-versions-template'に好みの文字列を設定すれば, このコマ
ンドで使用する文字列を指定できます.  この文字列内では, A版のテキストを
置く箇所には`%a'を, B版のを置く箇所には`%b'を指定します.  上に示した結
果を生じるデフォルトの設定はつぎのとおりです.

     "#ifdef NEW\n%a#else /* not NEW */\n%b#endif /* not NEW */\n"



File: emacs-ja, Node: Fine Points of Emerge, Next: C Modes, Prev: Combining in Emerge, Up: Emerge

細かな注意点
------------

併合作業中には, AバッファやBバッファを勝手に編集してはいけません.
emergeは一時的にこれらのバッファの内容を変更しますが, 最終的にはもとの
状態に戻します.

複数の併合処理を同時に進めることもできますが, 別の併合処理の入力に同じ
バッファを使用してはいけません.  というのは, 一時的にせよ, 互いに異な
る複数の変更が1つのバッファに加えられてしまうからです.

入力ファイル全体を比較する必要があるため, emergeの開始にはしばらく時間
がかかる場合もあります.  また, `diff'コマンドが完了するまで, emergeは
何もできません.  たぶん, そのうち誰かがemergeを変更して, 入力ファイル
が大きいときにはバックグラウンドで比較を行うようにするでしょう.  そう
すれば, emergeがコマンドを受け付けるようになるまで, Emacsで他の作業を
続けられます.

フック`emerge-startup-hook'（*Note Hooks::）が, 併合処理の設定の最後に
実行されます.



File: emacs-ja, Node: C Modes, Next: Fortran, Prev: Emerge, Up: Programs

Cモードと関連するモード
=======================

本節では, C, C++, Objective-C, Java, CORBA IDL, Pike用の各モードで利用
可能な特別な機能について述べます.  『Cモードと関連するモード』と書いた
ときには, これらのモードを意味します.

* Menu:

* Motion in C::
* Electric C::
* Hungry Delete::
* Other C Commands::
* Comments in C::



File: emacs-ja, Node: Motion in C, Next: Electric C, Prev: C Modes, Up: C Modes

Cモードの移動コマンド
---------------------

本節では, Cモードとその関連モードでポイントを移動するコマンドについて
述べます.

`C-c C-u'
     マークをポイント位置に設定し, ポイントを含むプリプロセッサの条件
     節の先頭に後向きにポイントを戻す.  数引数は反復回数として働く. 
     負の引数を指定すると, 条件節の末尾に前向きにポイントを移動する. 
     後向きに戻る場合, `#elif'は, `#if'が続く`#else'のように扱われる. 
     前向きに進む場合, `#elif'は無視される (1) (*Note Motion in
     C-Footnotes::).

`C-c C-p'
     マークをポイント位置に設定し, プリプロセッサの条件節を横断して後
     向きにポイントを移動する.  数引数は反復回数として働く.  負の引数
     を指定すると, 前向きに移動する.

`C-c C-n'
     マークをポイント位置に設定し, プリプロセッサの条件節を横断して前
     向きにポイントを移動する.  数引数は反復回数として働く.  負の引数
     を指定すると, 後向きに移動する.

`M-a'
     もっとも内側のCの文の先頭にポイントを移動する
     （`c-beginning-of-statement'）.  すでに文の先頭にポイントがある場
     合, 直前の文の先頭に移動する.  数引数Nを指定すると, N-1だけまえの
     文に移動する.

     ポイントが, 文字列やコメントの内側, あるいは, コメントのうしろ
     （コメントのあいだに白文字がある場合のみ）にある場合, Cの文ではな
     く自然言語の文単位で移動する.

     プログラムから呼ばれるときには, この関数は, 3つの引数, つまり, 反
     復回数, （これよりも後向きには戻らない）移動限界, ポイントがコメ
     ントの内側にある場合に自然言語の文単位の移動をするかどうか, を取
     るが, これらは省略できる.

`M-e'
     もっとも内側のCの文の末尾にポイントを移動する.  `M-a'と同じだが, 
     移動方向が逆（`c-end-of-statement'）.

`M-x c-backward-into-nomenclature'
     C++の命名語法の部分や単語の先頭に後向きにポイントを移動する.  数
     引数Nを指定すると, N回移動する.  Nが負ならば, 前向きに移動する.
     C++の命名語法とは, NamingSymbolsWithMixedCaseAndNoUnderlinesのよ
     うな形のシンボル名のこと（つまり, 大文字で始めた単語を連結したも
     の）.  各大文字が部分や単語の先頭となる.

     GNUプロジェクトでは, CやC++の識別子は, 大文字小文字で区別するので
     はなく, 単語を下線で区切ることを推奨する.

`M-x c-forward-into-nomenclature'
     C++の命名語法の部分や単語の末尾に前向きにポイントを移動する.  数
     引数Nを指定すると, N回移動する.


File: emacs-ja  Node: Motion in C-Footnotes, Up: Motion in C

(1) 【訳注】`#elif'のところで止まってしまう.



File: emacs-ja, Node: Electric C, Next: Hungry Delete, Prev: Motion in C, Up: C Modes

エレクトリックC文字
-------------------

Cモードとその関連モードでは, ある種の印字文字は『エレクトリック』です. 
つまり, その文字自身を挿入することに加えて, 現在行を字下げし直したり, 
改行も挿入することさえあります.  この機能は, 変数`c-auto-newline'で制
御されます.  『エレクトリック』文字は, `{', `}', `:', `#', `;', `,',
`<', `>', `/', `*', `(', `)'です.

"自動改行"（auto-newline）機能がオン（モード行のモード名のあとに`/a'と
表示される）の場合に限り, エレクトリック文字は改行を挿入します.  この
機能は, 変数`c-auto-newline'で制御されます.  コマンド`C-c C-a'でこの機
能をオン／オフできます.

`C-c C-a'
     自動改行機能をオン／オフする（`c-toggle-auto-state'）.  数引数を
     指定した場合, 正ならば自動改行機能をオンにし, 負ならばオフにする.

コロン`:'はエレクトリックです.  なぜなら, 単独のコロンの入力の解釈とし
てはそれが適切だからです.  しかし, C++で2つの連続するコロンを挿入する
場合, コロンのエレクトリックな動作は不便です.  `C-c :'と打てば, 字下げ
も改行の挿入も行わずにコロンを2つ挿入できます.

`C-c :'
     行の字下げも改行の挿入もせずに, スコープ演算子を表すコロン2つをポ
     イント位置に挿入する（`c-scope-operator'）.

エレクトリックキー`#'は, プリプロセッサ指令の始まりと思われる位置では, 
行を字下げし直します.  変数`c-electric-pound-behavior'の値が
`(alignleft)'のときには, このようになります.  この機能をオフにするには,
`c-electric-pound-behavior'に`nil'を設定します.

変数`c-hanging-braces-alist'は, 挿入された中括弧の前／後への改行の挿入
を制御します.  これは, `(SYNTACTIC-SYMBOL . NL-LIST)'の形の要素から成
る連想リストです.  `c-offsets-alist'に現れるほとんどの構文シンボルは, 
ここでも意味を持ちます.

リストNL-LISTは, シンボル`before'か`after'のいずれか, あるいはその両方, 
もしくは`nil'を含みます.  中括弧が挿入されるときには, その中括弧が定義
する構文上の文脈を`c-hanging-braces-alist'から探します.  みつかれば,
NL-LISTを使って中括弧の前／後／前後のどこに改行を挿入するか決定します. 
みつからなければ, デフォルトとして中括弧の前後に改行を挿入します.

変数`c-hanging-colons-alist'は, 挿入されたコロンの前／後への改行の挿入
を制御します.  これは, `(SYNTACTIC-SYMBOL . NL-LIST)'の形の要素から成
る連想リストです.  リストNL-LISTは, シンボル`before'か`after'のいずれ
か, あるいはその両方, もしくは`nil'を含みます.

コロンが挿入されるときには, そのコロンが定義する構文シンボルをこの連想
リストから探します.  みつかれば, NL-LISTを使ってコロンの前／後のどこに
改行を挿入するか決定します.  みつからなければ, 改行を挿入しません.

自動改行機能がオンのときには, エレクトリック文字は自動的に改行を削除し
ます.  この機能により, 改行が不要だと思われるもっとも一般的な場面で改
行を削除するので, 自動改行機能をユーザーにより受け入れやすくしています.
Emacsは改行を削除することが望ましいいくつかの場面を認識できますが, 変
数`c-cleanup-list'を設定すれば, *どの*場面で行うか指定できます.  この
変数の値はシンボルのリストです.  各要素は, 改行を削除してよい場面を1つ
指定します.  以下に指定できるシンボルとその意味を示します.

`brace-catch-brace'
     `} catch (CONDITION) {'の構造全体を1行に再配置する.  `catch'や
     CONDITION以外に中括弧のあいだになにもないときに`{'を打つと再配置
     する.

`brace-else-brace'
     `} else {'の構造全体を1行に再配置する.  `else'に続けて`{'を打った
     ときに再配置するが, 中括弧と`else'のあいだに空白以外の文字がない
     場合に限る.

`brace-elseif-brace'
     `} else if (...) {'の構造全体を1行に配置する.  `{'を打ったときに
     再配置するが, キーワードと`if'の条件式を除いて, `}'と`{'のあいだ
     に空白以外の文字がない場合に限る.

`empty-defun-braces'
     空の関数定義の中括弧, `{'と`}'を同じ行に再配置する.  閉じ中括弧
     `}'を打ったときに再配置する.

`defun-close-semi'
     `struct'や同様の型宣言のあとのセミコロンを閉じ中括弧と同じ行に再
     配置する.  セミコロンを打ったときに再配置する.

`list-close-comma'
     配列／合成体の初期化式の中の閉じ中括弧とそれに続くコンマを同じ行
     に再配置する.  コンマを打ったときに再配置する.

`scope-operator'
     C++のスコープ演算子を表している可能性がある2つのコロンを一緒にす
     る.  2つめのコロンを打ったときに一緒にするが, コロンのあいだに白
     文字以外の文字がない場合に限る.



File: emacs-ja, Node: Hungry Delete, Next: Other C Commands, Prev: Electric C, Up: C Modes

Cの欲張りな削除機能
-------------------

"欲張りな削除"機能をオン（モード行のモード名のあとに`/h'か`/ah'で表示
される）にすると, 1つのDELコマンドで, 直前の空白1つだけでなく, 白文字
すべてを削除します.  この機能をオン／オフにするには, `C-c C-d'を使いま
す.

`C-c C-d'
     欲張り削除機能（`c-toggle-hungry-state'）をオン／オフする.  数引
     数を指定した場合, 正ならば欲張り削除機能をオンにし, 負ならばオフ
     にする.

`C-c C-t'
     自動改行機能と欲張り削除機能を同時にオン／オフする 
     （`c-toggle-auto-hungry-state'）.

変数`c-hungry-delete-key'は, 欲張り削除機能がオンかオフかを制御します.



File: emacs-ja, Node: Other C Commands, Next: Comments in C, Prev: Hungry Delete, Up: C Modes

Cモードのその他のコマンド
-------------------------

`C-M-h'
     関数定義の末尾にマークを設定し, 先頭にポイントを置く
     （`c-mark-function'）.

`M-q'
     CやC++のコメントを考慮して, 段落を詰め込む（`c-fill-paragraph'）. 
     現在行にコメントがあったり, 現在行がコメントの内側なら, コメント
     の字下げとコメント区切りを保存したまま, ポイント位置のコメントや
     段落を詰め込む.

`C-c C-e'
     リージョン内のテキストに対してCプリプロセッサを実行し, マクロ呼び
     出しを展開した結果を表示する（`c-macro-expand'）.  リージョンのま
     えにあるテキストにマクロ定義があることもあるので, それらもプリプ
     ロセッサに渡されるが, その部分の出力は表示しない.

     マクロを用いたCのコードをデバッグするとき, どのようにマクロが展開
     されるか正確に理解するのが難しいことがある.  このコマンドを使えば, 
     マクロ展開のことを考える必要はない.  展開結果を目にすることができ
     る.

`C-c C-\'
     リージョン内の行末に`\'文字を挿入したり, 行末の`\'の位置揃えを行
     う（`c-backslash-region'）.  Cのマクロ定義を書いたり編集したあと
     に便利なコマンド.

     行末がすでに`\'で終っているなら, そのまえに置く白文字の個数を調整
     する.  そうでなければ, 新たに`\'を挿入する.  ただし, リージョン内
     の最後の行は特別扱いする.  その行に`\'を挿入することはなく, また,
     `\'がある場合には削除する.

`M-x cpp-highlight-buffer'
     プリプロセッサ指令の条件節に従って, テキストの一部を強調表示する. 
     このコマンドは`*CPP Edit*'という名前のバッファを表示する.  このバッ
     ファは, 特定のプリプロセッサ条件とその内容をどのように表示するか
     を選択するグラフィックメニュー.  さまざま設定を変更したあとで,
     `[A]pply these settings'をクリックする（あるいは, そのバッファへ
     移動して`a'と打つ）と, 設定に応じてCモードのバッファを強調表示し
     直す.

`C-c C-s'
     現在のソース行に関する構文上の情報を表示する
     （`c-show-syntactic-information'）.  この情報は行の字下げを指示す
     る.



File: emacs-ja, Node: Comments in C, Next: Fortran, Prev: Other C Commands, Up: C Modes

Cモードのコメント
-----------------

Cモードとその関連モードでは, コメントの整形にいくつかの変数を使います.

`c-comment-only-line-offset'
     コメント開始部分だけを含んだ行に与える余分のオフセット.  この変数
     の値は整数, あるいは`(NON-ANCHORED-OFFSET . ANCHORED-OFFSET)'の形
     のコンスセルのどちらでもかまわない.  ここで, NON-ANCHORED-OFFSET
     は, 1桁目以降から始まるコメントに与えるオフセット.
     ANCHORED-OFFSETは, 0桁目から始まるコメントに与えるオフセット.  整
     数値だけの場合は, `(VAL . 0)'と等価.

`c-comment-start-regexp'
     コメント開始の識別方法を指定するバッファにローカルな変数.

`c-hanging-comment-ender-p'
     この変数が`nil'であると, `c-fill-paragraph'は, ブロックコメントの
     コメント終了区切りだけの行を作る.  デフォルト値は`t'で, コメント
     終了区切り`*/'をコメントの最後の行の末尾に置く.

`c-hanging-comment-starter-p'
     この変数が`nil'であると, `c-fill-paragraph'は, ブロックコメントの
     コメント開始区切りだけの行を作る.  デフォルト値は`t'で, コメント
     開始区切り`/*'をコメントの最初の行の先頭に置く.



File: emacs-ja, Node: Fortran, Next: Asm Mode, Prev: C Modes, Up: Programs

Fortranモード
=============

Fortranモードには, Fortranの文と副プログラム向けの特別な移動コマンド,
Fortranの入れ子, 行番号と継続文の約束事に従う字下げコマンドがあります.
Fortranモードには, 長い行を適切なFortranの継続行に分ける専用の自動詰め
込み（fortran-auto-fill）モードがあります.

Fortranのコメントは他の言語のコメントとは異なっているので, コメントに
対する特別なコマンドもあります.  Fortranのキーワードを入力するときの打
鍵量を減らせる, 組み込みの略語もあります.

Fortran用のメジャーモードに切り替えるには, `M-x fortran-mode'を使いま
す.  このコマンドは, フック`fortran-mode-hook'を実行します（*Note
Hooks::）.

* Menu:

* Motion: Fortran Motion.	 Moving point by statements or subprograms.
* Indent: Fortran Indent.	 Indentation commands for Fortran.
* Comments: Fortran Comments.	 Inserting and aligning comments.
* Autofill: Fortran Autofill.	 Auto fill minor mode for Fortran.
* Columns: Fortran Columns.	 Measuring columns for valid Fortran.
* Abbrev: Fortran Abbrev.	 Built-in abbrevs for Fortran keywords.
* Misc: Fortran Misc.            Other Fortran mode features.



File: emacs-ja, Node: Fortran Motion, Next: Fortran Indent, Prev: Fortran, Up: Fortran

移動コマンド
------------

Fortran モードには, 副プログラム（関数やサブルーチン）や文を単位とて移
動するための特別なコマンドがあります.  また, 副プログラムを囲むリージョ
ンを設定するコマンドもあり, 副プログラムをキルしたり移動したりするのに
便利です.


`C-M-a'
     副プログラムの先頭に移動する（`beginning-of-fortran-subprogram'）.
`C-M-e'
     副プログラムの末尾に移動する（`end-of-fortran-subprogram'）.
`C-M-h'
     副プログラムの先頭にポイントを置き, 末尾にマークを設定する
     （`mark-fortran-subprogram'）.
`C-c C-n'
     現在の文かつぎの文の先頭に移動する（`fortran-next-statement'）.
`C-c C-p'
     現在の文かまえの文の先頭に移動する（`fortran-previous-statement'）.



File: emacs-ja, Node: Fortran Indent, Next: Fortran Comments, Prev: Fortran Motion, Up: Fortran

Fortranの字下げ
---------------

Fortranのコードでは, 構文上の各種要素（行番号, コメント行指示子, 継続
マーク）は標準Fortranが要求する桁に現れるようにしなくてはいけないので, 
字下げに関する特別なコマンドと機能が必要です.

* Menu:

* Commands: ForIndent Commands.  Commands for indenting Fortran.
* Contline: ForIndent Cont.      How continuation lines indent.
* Numbers:  ForIndent Num.       How line numbers auto-indent.
* Conv:     ForIndent Conv.      Conventions you must obey to avoid trouble.
* Vars:     ForIndent Vars.      Variables controlling Fortran indent style.



File: emacs-ja, Node: ForIndent Commands, Next: ForIndent Cont, Prev: Fortran Indent, Up: Fortran Indent

Fortranの字下げコマンド
.......................

`TAB'
     現在行を字下げする（`fortran-indent-line'）.
`C-j'
     現在行を字下げしてから, 字下げした新たな行を始める
     （`fortran-indent-new-line'）.
`C-M-j'
     ポイント位置で現在行を分割し, 継続行を設定する.
`M-^'
     現在行と直前の行を繋げる.
`C-M-q'
     ポイントを含む副プログラムの行をすべて字下げする
     （`fortran-indent-subprogram'）.

Fortranモードでは, Fortranの行を字下げするようにTABを再定義します
（`fortran-indent-line'）.  このコマンドは, 行番号と継続マークを要求さ
れる桁位置に字下げしたうえ, それとは独立にプログラム中の入れ子に基づい
て文本体を字下げします.

キー`C-j'は`fortran-indent-new-line'を実行します.  これは, 現在行を字
下げしてから, 新たな行を作成して字下げします.  新たな行を始めるまえに,
`do'ループやその他のブロックを閉じる文を字下げし直すのに便利です.

キー`C-M-q'は, ポイントを含むFortranの副プログラム（関数やサブルーチン）
の行すべてを字下げするコマンド`fortran-indent-subprogram'を実行します.

キー`C-M-j'は, 適切な方法でFortranの行を分割するコマンド
`fortran-split-line'を実行します.  コメント行でなければ, 後半部を継続
行にし, それに応じて字下げします.  コメント行ならば, 前後半部分とも独
立したコメント行になります.

`M-^'は, `fortran-split-line'の逆操作を行うコマンド`fortran-join-line'
を実行します.  現在行と直前の行を, Fortranコードとして適切に繋げます.



File: emacs-ja, Node: ForIndent Cont, Next: ForIndent Num, Prev: ForIndent Commands, Up: Fortran Indent

継続行
......

近代的なほとんどのFortranコンパイラには, 継続行の記述方法が2つ用意され
ています.  ある行の空白でない最初の文字が5桁目にあれば, 先行する行の継
続行です.  このスタイルを"固定フォーマット"と呼びます.  （GNU Emacsで
は, 桁位置はつねに0から数える. ）変数`fortran-continuation-string'は,
5桁目に置く文字を指定します.  タブ文字で始まり`0'以外の数字が続く行も
継続行です.  このスタイルを"タブフォーマット"と呼びます.

Fortranモードではどちらのスタイルの継続行も利用できますが, 希望するほ
うを指定する必要があります.  変数`indent-tabs-mode'の値で希望を指定し
ます.  `nil'ならば固定フォーマット, `nil'以外ならばタブフォーマットに
なります.  モード行に文字列`Tab'があるかどうかで, 現在使用しているスタ
イルがわかります.

Fortranモードでは, テキストが慣用的なFortranの継続マーク`$'で始まる, 
あるいは, 5桁目から白文字以外の文字で始まる場合には, その行を継続行と
して扱います.  TABで継続行を字下げすると, 選択されている継続行のスタイ
ルに変換します.  `C-M-j'でFortranの文を分割すると, 継続行のスタイルに
応じて新たな行には継続マークを付けます.

継続行のスタイルは, Fortranモードでの編集に関わるその他の側面にも影響
します.  固定フォーマットでは, 文本体を置く最小桁位置は6になります.
Fortranのブロックの内側にある行を7桁目以降に字下げするときには, 白文字
には空白文字を使います.  一方, タブフォーマットでは, 文本体を置く最小
桁位置は8で, 8桁目よりまえの白文字はつねにタブ文字です.

既存のファイルに対してFortranモードに入ると, その内容から自動的に適切
な継続行のスタイルを推測しようとします.  タブ文字か空白6個で始まる最初
の行でスタイルを判断します.  変数`fortran-analyze-depth'で, （ファイル
の先頭から）何行分をスタイル判断に使用するか指定します.  この範囲内に
スタイルを示すような行がみつからなければ, 変数
`fortran-tab-mode-default'がスタイルを指定します.  `nil'なら固定フォー
マット, `nil'以外ならタブフォーマットです.



File: emacs-ja, Node: ForIndent Num, Next: ForIndent Conv, Prev: ForIndent Cont, Up: Fortran Indent

行番号
......

ある行の白文字以外の最初の文字が数字であれば, Fortranの字下げではそれ
を行番号とみなして0桁目から4桁目のあいだに移動します.  （GNU Emacsでは, 
桁位置はつねに0から始まる. ）

通常, 4桁以下の行番号は空白1個で字下げします.  変数
`fortran-line-number-indent'でこの字下げ幅を制御します.  この変数の値
は, 行番号の最大字下げ幅を表します.  最大字下げ幅まで字下げできなくな
ると, 行番号の最後の桁が4桁目になるように右揃えで字下げします.  この変
数のデフォルト値は1です.

これらの規則に従って行番号を字下げするには, 行番号を挿入するだけで十分
です.  行番号の各桁が挿入されるたびに, 字下げ幅を再計算します.  この機
能をオフにするには, 変数`fortran-electric-line-number'に`nil'を設定し
ます.  こうすると, 行番号の挿入はその他の文字の挿入と同様に行われます.



File: emacs-ja, Node: ForIndent Conv, Next: ForIndent Vars, Prev: ForIndent Num, Up: Fortran Indent

構文上の規約
............

Fortranモードでは, 適切な字下げをするためのFortranプログラムの解釈を簡
単にするために, 以下の規約に従っているものと仮定します.

   * 2つの入れ子になった`do'ループは, けっして`continue'文を共有しない.

   * `if', `else', `then', `do'といったFortranのキーワードは, あいだに
     空白があったり, 途中で行分けされない.

     一般にFortranコンパイラは文字列定数の外側にある空白を無視するが,
     Fortranモードは途中に空白が入っているキーワードを認識しない.
     `else if'や`end do'のような書き方は許されるが, 2つの単語を同じ行
     に置いた場合に限る.  継続行に分かれていると認識しない.

以上の規約に従っていない場合には, 行を美しく字下げできないこともありま
す.  しかしながら, たとえ規約に従っていなくても, 正しいFortranプログラ
ムであれば字下げによって意味が変わることはありません.



File: emacs-ja, Node: ForIndent Vars, Next: Fortran Comments, Prev: ForIndent Conv, Up: Fortran Indent

Fortranの字下げのための変数
...........................

Fortranの字下げ動作に影響する変数がいくつかあります.

`fortran-do-indent'
     `do'文の各レベルごとに追加する字下げ幅（デフォルトは3）.

`fortran-if-indent'
     `if'文の各レベルごとに追加する字下げ幅（デフォルトは3）.  この値
     は, Fortran 90の`where'文の字下げにも使われる.

`fortran-structure-indent'
     `structure', `union', `map'の各文の各レベルごとに追加する字下げ幅
     （デフォルトは3）.

`fortran-continuation-indent'
     継続行の文本体に追加する字下げ幅（デフォルトは5）.

`fortran-check-all-num-for-matching-do'
     この変数が`nil'なら, 字下げ処理では, `do'文は`continue'文で終って
     いると仮定する.  こうすると, `continue'以外の文の字下げを計算する
     ときに, 当該文が`do'文を終えるかどうか検査しなくてよいので, 時間
     を節約できる.  この変数が`nil'以外であれば, 行番号が付いた文の字
     下げを計算するときには, 当該文が`do'文を終えるかどうか検査する必
     要がある.  デフォルト値は`nil'.

`fortran-blink-matching-if'
     この変数が`t'なら, `endif'文の字下げを行うときに, 対応する`if'文
     を示すために一時的にカーソルを移動する.  デフォルト値は`nil'.

`fortran-minimum-statement-indent-fixed'
     固定フォーマットの継続行スタイルを採用したときの, 文に対する最小
     字下げ幅.  文本体の字下げ幅がこの値より小さくなることはない.  デ
     フォルト値は6.

`fortran-minimum-statement-indent-tab'
     タブフォーマットの継続行スタイルを採用したときの, 文に対する最小
     字下げ幅.  文本体の字下げ幅がこの値より小さくなることはない.  デ
     フォルト値は8.



File: emacs-ja, Node: Fortran Comments, Next: Fortran Autofill, Prev: Fortran Indent, Up: Fortran

Fortranのコメント
-----------------

Emacsの通常のコメント用コマンドは, コメントをコードのあとにも置けると
仮定します.  Fortranでは, 標準的なコメントの構文は, 1つの行全体を必要
とします.  そのため, Fortranモードでは, Emacsの通常のコメント用コマン
ドを置き換え, 新たな変数をいくつか定義しています.

Fortranモードでは, 文字`!'で始まり他のテキストのあとにも置ける非標準的
なコメントの構文も扱えます.  しかし, この構文を受け付けるFortranコンパ
イラは限られるため, まえもって指定しておかない限り, Fortranモードは非
標準のコメントを使いません.  このスタイルのコメントを使うには, 変数
`comment-start'に`"!"'を設定します（*Note Variables::）.

`M-;'
     コメントの位置を揃えたり, 新たなコメントを挿入する
     （`fortran-indent-comment'）.

`C-x ;'
     非標準の`!'コメントだけに作用する.

`C-c ;'
     リージョン内のすべての行をコメントにする.  あるいは, （引数を指定
     すると）コメントをコードに戻す（`fortran-comment-region'）.

Fortranモードの`M-;'は, コマンド`fortran-indent-comment'に再定義されて
います.  通常の`M-;'と同じく, 既存のコメントを認識して, そのテキストの
桁位置を揃えます.  コメントがなければ, コメントを挿入して桁位置を揃え
ます.  しかし, Fortranモードのコメントの挿入と揃え方は, 他のモードと同
じではありません.

新たにコメントを挿入する場合, 現在行が空行のときは（1行全体を占める）
行コメントを挿入します.  空行でないとき, 非標準のコメントを使うように
指定してあれば非標準の`!'コメントを挿入します.  いずれでもないときには, 
現在行のまえに行コメントを挿入します.

非標準の`!'コメントは他の言語のコメントと同じように揃えられますが, 行
コメントの場合はようすが異なります.  標準の行コメントでは, コメント区
切りはつねに0桁目にある必要があります.  コメント内部のテキストだけを揃
えます.  `fortran-comment-indent-style'を設定して, 3種類の揃え方を選べ
ます.

`fixed'
     `fortran-comment-line-extra-indent'と文に対する最小字下げ幅を合計
     した桁位置にテキストを揃える.  デフォルトはこれ.

     文の最小字下げ幅は, 固定フォーマットの継続行スタイルの場合には
     `fortran-minimum-statement-indent-fixed'の値, タブフォーマットの
     場合には`fortran-minimum-statement-indent-tab'の値.

`relative'
     コード行であるかのように揃えるが,
     `fortran-comment-line-extra-indent'だけ余計に桁をずらす.

`nil'
     行コメントのテキストを勝手に動かさない.

また, 行コメントの字下げ文字を変更したければ, 変数
`fortran-comment-indent-char'に好みの1文字を設定してください.

Fortranモードには, `comment-line-start'と`comment-line-start-skip'の2
つの変数が新たに導入されています.  これらは, コードのあとに置く通常の
コメントに対する`comment-start'と`comment-start-skip'と同様の役割を, 
行コメントに対して果たします.  どちらもFortranモードが適切に設定するの
で, 変更する必要はありません.

Emacsの通常のコメント用コマンド`C-x ;'は, 再定義されていません.  この
コマンドは`!'コメントを扱えます.  `!'コメントを使っていない場合には, 
このコマンドはFortranモードでは役に立ちません.

コマンド`C-c ;'（`fortran-comment-region'）は, リージョン内のすべての
行の先頭に`C$$$'を挿入してコメントに変えます.  数引数を指定すると, 行
の先頭から`C$$$'を削除して, リージョンを生きたコードに戻します.  これ
らのコメントに使う文字列は, 変数`fortran-comment-region'の設定で制御で
きます.  ところで, ここではコマンドと変数に同じ名前が使われています.
LispやEmacsにおいては, 使用される文脈からコマンドと変数をつねに区別で
きるので, このような名前の使い方が問題を起こすことはありません.



File: emacs-ja, Node: Fortran Autofill, Next: Fortran Columns, Prev: Fortran Comments, Up: Fortran

Fortran専用自動詰め込み（fortran-auto-fill）モード
--------------------------------------------------

Fortran専用自動詰め込み（fortran-auto-fill）モードは, 挿入したFortran
の文が長くなりすぎると自動的に文を分割するマイナモードです.  文を分割
するには, `fortran-continuation-string'（*Note ForIndent Cont::）を用
いて継続行を作ります.  SPC, RET, TABを打ったときや, 字下げコマンドを使っ
たときに分割されます.

`M-x fortran-auto-fill-mode'は, Fortran専用自動詰め込み
（fortran-auto-fill）モードがオンならばオフにし, オフならばオンにしま
す.  このコマンドは, 通常の自動詰め込み（auto-fill）モード（*Note
Filling::）である`M-x auto-fill-mode'が行うのと同じように働きます.  正
の数引数を指定すると, Fortran専用自動詰め込み（fortran-auto-fill）モー
ドをオンにし, 負であればオフにします.  このモードのオン／オフは, モー
ド行の括弧の中に`Fill'があるかどうかで判断できます.  Fortran専用自動詰
め込み（fortran-auto-fill）モードはマイナモードなので, 各バッファごと
に独立にオン／オフにできます.  *Note Minor Modes::.

Fortran専用自動詰め込み（fortran-auto-fill）モードは, 行の長さが規定の
幅（`fill-column'の値）を越えると, 空白や区切りの位置で行を分割します.
Fortran専用自動詰め込み（fortran-auto-fill）が分割する区切りは, `,',
`'', `+', `-', `/', `*', `=', `)'です.  変数
`fortran-break-before-delimiters'が`nil'の場合には, 区切りのうしろで分
割します.  それ以外（デフォルトでもある）では, 区切りのまえで分割しま
す.

デフォルトではFortran専用自動詰め込み（fortran-auto-fill）モードはオフ
です.  この機能を恒常的に使いたければ, `(fortran-auto-fill-mode 1)'を
実行するフック関数を`fortran-mode-hook'に追加してください.  *Note
Hooks::.



File: emacs-ja, Node: Fortran Columns, Next: Fortran Abbrev, Prev: Fortran Autofill, Up: Fortran

桁位置の確認
------------

`C-c C-r'
     現在行の上にしばらくのあいだ『桁定規』を表示する
     （`fortran-column-ruler'）.
`C-c C-w'
     現在のウィンドウを一時的に分割して幅を72桁にする.  一部のFortran
     コンパイラは1行を72文字以内に制限しているので, このコマンドを使用
     すれば1行が長くなりすぎることを防げる
     （`fortran-window-create-momentarily'）.

コマンド`C-c C-r'（`fortran-column-ruler'）は, 桁定規をしばらくのあい
だ, 現在行の上に表示します.  桁定規は, Fortranプログラムにおいて特別な
意味をもつ桁位置を表す2行のテキストです.  2行目の角括弧と中括弧で, そ
れぞれ, 行番号と文の本体の範囲を表します.  桁番号は（それらの上の）1行
目に表示されます.

GNU Emacsでは桁番号をつねに0から数えることに注意してください.  その結
果, 桁定規に示される桁番号は, 慣れ親しんだものより1だけ小さくなります. 
しかし, それらが表す位置はFortranの標準に従ったものです.

桁定規の表示に用いるテキストは, 変数`indent-tabs-mode'の値に依存します. 
この変数の値が`nil'ならば, 変数`fortran-column-ruler-fixed'の値を桁定
規の表示に使います.  `nil'以外であれば, 変数`fortran-column-ruler-tab'
の内容を表示に使います.  これらの変数の内容を変更すれば, 桁定規の表示
を変更できます.

さらに桁合わせを支援するために, `C-c C-w'（`fortran-window-create'）は, 
現在のウィンドウを幅が72桁になるように横位置で分割します.  このウィン
ドウで編集すれば, 正しいFortranのプログラムとしては長すぎる行を即座に
発見できます.



File: emacs-ja, Node: Fortran Abbrev, Next: Fortran Misc, Prev: Fortran Columns, Up: Fortran

Fortranのキーワードの略語
-------------------------

Fortranモードには, 一般的なキーワードや宣言に対する数多くの組み込み略
語があります.  これらは, ユーザー自身が定義できる略語と同じ種類のもの
です.  それらを使うには, 略語（abbrev）モードをオンにします.  *Note
Abbrevs::.

組み込み略語は他の略語と1つの点で変わっています.  すべてセミコロンで始
まります.  通常は略語にはセミコロンを使えませんが, Fortranモードでは, 
セミコロンの構文上の意味を『単語を構成する文字』に変更することで, これ
を可能にしています.

たとえば, `continue'に対する組み込みFortran略語は`;c'です.  略語
（abbrev）モードがオンのときに, `;c'を挿入してから空白や改行といった句
読点文字を挿入すると, `;c'は自動的に`continue'と展開されます.

組み込みFortran略語とその展開形の一覧を表示するには, `;?'あるいは
`;C-h'と打ちます.



File: emacs-ja, Node: Fortran Misc, Next: Asm Mode, Prev: Fortran Abbrev, Up: Fortran

Fortranモードのその他のコマンド
-------------------------------

`C-x n d'
     現在のFortranの副プログラムにナロイングする.

Fortranモードでは, キー`C-x n d'はコマンド
`fortran-narrow-to-subprogram'を実行するように再定義しています.  この
コマンドは, キーの通常の定義をFrotran風にしたものです.  バッファをポイ
ントを含む副プログラムにナロイングします.



File: emacs-ja, Node: Asm Mode, Next: Building, Prev: Fortran, Up: Programs

asmモード
=========

asmモードは, アセンブリコードのファイルを編集するためのメジャーモード
です.  つぎのコマンドが定義されています.

`TAB'
     `tab-to-tab-stop'.
`C-j'
     改行を挿入し, `tab-to-tab-stop'で字下げする.
`:'
     コロンを挿入し, コロンに先行するラベルのまえの字下げを取り除く. 
     そして, `tab-to-tab-stop'を行う.
`;'
     コメントの挿入／位置揃えを行う.

変数`asm-comment-char'は, アセンブラ構文でコメントを開始する文字を指定
します.


File: emacs-ja, Node: Building, Next: Abbrevs, Prev: Programs, Up: Top

プログラムのコンパイルとテスト
******************************

前章ではプログラムの変更に便利なEmacsコマンドを説明しました.  本章では
プログラムの大規模な開発や保守を助けるコマンドを説明します.

* Menu:

* Compilation::         Compiling programs in languages other
                          than Lisp (C, Pascal, etc.).
* Grep Searching::      Running grep as if it were a compiler.
* Compilation Mode::    The mode for visiting compiler errors.
* Compilation Shell::   Customizing your shell properly
                          for use in the compilation buffer.
* Debuggers::	        Running symbolic debuggers for non-Lisp programs. 
* Executing Lisp::      Various modes for editing Lisp programs, 
                          with different facilities for running
                          the Lisp programs. 
* Libraries: Lisp Libraries.      Creating Lisp programs to run in Emacs.
* Interaction: Lisp Interaction.  Executing Lisp in an Emacs buffer.
* Eval: Lisp Eval.      Executing a single Lisp expression in Emacs.
* External Lisp::         Communicating through Emacs with a separate Lisp. 



File: emacs-ja, Node: Compilation, Next: Grep Searching, Prev: Building, Up: Building

Emacs下でのコンパイラの実行
===========================

EmacsはCやFortranのような非対話的な言語のコンパイラを下位プロセスとし
て実行でき, そのエラーログをEmacsバッファに取り込めます.  また, エラー
メッセージを解析して, コンパイルエラーを起こしたソース行を提示すること
もできます.

`M-x compile'
     Emacs下でコンパイラを非同期に実行し, エラーメッセージを
     `*compilation*'バッファに取り込む.
`M-x grep'
     Emacs下で`grep'を非同期に実行し, 一致した行を`*grep*'バッファに取
     り込む.
`M-x grep-find'
     指定した引数で`find'と`grep'を実行し, 出力を`*grep*'バッファに取
     り込む.
`M-x kill-compilation'
`M-x kill-grep'
     実行中のコンパイラや`grep'のサブプロセスを停止させる.

`make'や他のコンパイルコマンドを実行するには, `M-x compile'と打ちます. 
このコマンドは, ミニバッファでシェルコマンドを読み取り, そのコマンドを
下位シェルで実行し, 出力結果を`*compilation*'という名のバッファに取り
込みます.  カレントバッファのデフォルトディレクトリをシェルコマンド実
行時の作業ディレクトリとして用います.  そのため, 通常はこのディレクト
リにあるものをコンパイルします.

シェルコマンド行を読み取るとき, ミニバッファにはデフォルトのシェルコマ
ンド行が表示されますが, これは前回`M-x compile'を使ったときのコマンド
です.  単にRETだけを打鍵すると, 同じシェルコマンド行を再使用します. 
最初の`M-x compile'では, デフォルトは`make -k'です.  デフォルトのコン
パイルコマンドは変数`compile-command'から取ります.  適切なコンパイルコ
マンドが他にある場合には, ファイルでこの変数のローカルな値を指定すると
便利でしょう（*Note File Variables::）.

コンパイルが始まると, バッファ`*compilation*'は別のウィンドウに表示さ
れますが, 選択されるわけではありません.  このバッファのモード行では, 
括弧の中に単語`run'か`exit'を表示してコンパイルが終了したかどうか示し
ます.  このバッファを見えるようにしておく必要はありません.  いずれにし
ても, コンパイルは継続されます.  コンパイル中は, すべてのウィンドウの
モード行に文字列`Compiling'が表示されます.  この文字列が消えれば, コン
パイルは終了しています.

コンパイルの進行状況を見たい場合には, `*compilation*'バッファに切り替
えてポイントをバッファの末尾に移動します.  ポイントがバッファの末尾に
あると, 新らたなコンパイル出力はポイントのまえに挿入されポイントは末尾
に留まります.  ポイントがバッファの末尾にないと, コンパイル出力はバッ
ファの末尾に追加されますがポイントは途中の場所に留まったままです.

変数`compilation-scroll-output'に`nil'以外の値を設定すると, 出力が到着
するたびに出力に追従するようにコンパイルバッファをつねにスクロールしま
す.

コンパイルプロセスを止めるには, `M-x kill-compilation'を実行します. 
コンパイルプロセスが終了すると, `*compilation*'バッファのモード行の表
示が`run'から`signal'に変わります.  一度に実行可能なコンパイルは1つだ
けなので, 新しくコンパイルを始めると実行中のコンパイルは停止させられま
す.  しかし, `M-x compile'は, 実行中のコンパイルを実際に停止させるかど
うか聞いてきます.



File: emacs-ja, Node: Grep Searching, Next: Compilation Mode, Prev: Compilation, Up: Building

Emacs下でのgrepによる探索
=========================

Emacsからコンパイラを実行し, コンパイルエラーを起こした行を訪れること
ができるように, `grep'を実行して一致した行を訪れることができます.  こ
れは, `grep'が報告した一致を『エラー』として扱うことで行います.

それには, `M-x grep'と打鍵してから, `grep'をどのように実行するかを指定
するコマンド行を入力します.  普通に`grep'を実行するときに指定する引数
と同じものを使います.  つまり, `grep'流の（普通, シェルの特殊文字をクォー
トするためにシングルクォートで囲んだ）正規表現に続けて, ワイルドカード
などを用いたファイル名を指定します.  `grep'の出力は`*grep*'バッファに
入ります.  ファイル内の対応する行を探すには, コンパイルエラーの場合と
同様に, `C-x `'とRETを使います.

`M-x grep'に前置引数を指定すると, ポイントの周りから（探すべき）タグを
推測してデフォルトの`grep'コマンドにそれを含めます.

`M-x grep-find'は`M-x grep'コマンドと同様ですが, シェルコマンドに与え
る最初のデフォルトが違います.  `find'と`grep'の両方を実行して, ディレ
クトリ木構造下の各ファイルを探索します.  *Note Dired and Find::の
`find-grep-dired'コマンドも参照してください.



File: emacs-ja, Node: Compilation Mode, Next: Compilation Shell, Prev: Grep Searching, Up: Building

コンパイルモード
================

`*compilation*'バッファは, コンパイル（compilation）モードと呼ばれる特
別なメジャーモードになります.  このモードの主な機能は, エラーが起きた
ソース行を簡単に参照できることです.

`C-x `'
     つぎのコンパイルエラーや`grep'のつぎの一致に対応する箇所を訪れる.
`RET'
     ポイントが位置するエラーメッセージに対応する箇所を訪れる.  このコ
     マンドは, コンパイルバッファで使う.
`Mouse-2'
     マウスでクリックしたエラーメッセージに対応する箇所を訪れる.

`*compilation*'でエラーメッセージにポイントを持っていってRET
（`compile-goto-error'）を打鍵すれば, そのエラーの原因となったソースを
訪問できます.  あるいは, エラーメッセージを`Mouse-2'でクリックしますが, 
このときは, あらかじめ`*compilation*'バッファに切り替えておく必要はあ
りません.

コンパイラのエラーメッセージを順番に解析するには, `C-x `'
（`next-error'）と打鍵します.  `C-x'に続く文字は, シングルクォートでは
なくバッククォート, すなわち, 『アクサングレーブ』です.  このコマンド
は`*compilation*'だけでなく, すべてのバッファで使用可能です.  このコマ
ンドは, 一方のウィンドウの先頭にエラーメッセージを表示し, 別のウィンド
ウにエラーとなったソースコードを表示します.

コンパイル開始後に最初に`C-x `'を使うと, 最初のエラー箇所に移動します. 
続けて`C-x `'を実行すると, 次々にエラー箇所に移動していきます.  RETや
`Mouse-2'で特定のエラー箇所に移動したあとに`C-x `'コマンドを実行すると, 
その場所のつぎのエラー箇所に移動します.  バッファの末尾に到達してもう
エラーメッセージがないと, `C-x `'コマンドは失敗し, エラーを通知します.

`C-u C-x `'は, コンパイルバッファの先頭から解析を始めます.  コンパイル
をやり直さずに一連のエラーの解析をもう一度行う方法の1つです.

コンパイル（compilation）モードでは, SPCキーとDELキーを1画面分のスクロー
ルに, `M-n'と`M-p'を1つつぎ／まえのエラーメッセージへの移動に再定義し
ます.  また, 別のソースファイルのエラーメッセージへの移動には, `M-{'と
`M-}'コマンドを使えます.

コンパイル（compilation）モードの機能は, コンパイルマイナ
（compilation-minor）モードと呼ばれるマイナモードでも使えます.  これに
より, 普通のコンパイルバッファだけでなく任意のバッファ内のエラーメッセー
ジを解析できます.  このマイナモードをオンにするには, `M-x
compilation-minor-mode'と打鍵します.  すると, メジャーモードのコンパイ
ル（compilation）モードと同様にRETキーと`Mouse-2'を定義します.

バッファの内容が認識できる形式である限り, コンパイルマイナ
（compilation-minor）モードは任意のバッファで動作します.  rloginバッファ
（*Note Remote Host::）では, コンパイルマイナ（compilation-minor）モー
ドはリモートのソースファイルをFTPで自動的に取ってきます（*Note File
Names::）.



File: emacs-ja, Node: Compilation Shell, Next: Debuggers, Prev: Compilation Mode, Up: Building

コンパイルのためのサブシェル
============================

Emacsはシェルを使ってコンパイルコマンドを実行しますが, 非対話的なシェ
ルになるようなオプションを指定します.  つまり, シェルはプロンプトを出
さずに実行を開始するはずです.  `*compilation*'バッファに通常のシェルプ
ロンプトがぶざまに現れる場合は, 個人のシェル初期化ファイルでプロンプト
を無条件に設定していることを意味します.  （シェル初期化ファイルの名前
は, `.bashrc', `.profile', `.cshrc', `.shrc'などだが, 使っているシェル
によってさまざまな場合がある. ）シェル初期化ファイルでは, プロンプトが
すでに設定されているときだけプロンプトを再設定するべきです.  たとえば,
`csh'では以下のようにします.

     if ($?prompt) set prompt = ...

bashでは以下のようにします.

     if [ "${PS1+set}" = set ]
     then PS1=...
     fi

読者のシェル初期化ファイルには, 対話的なシェルに対してだけ本来は設定す
るべきことがまだあるかもしれません.  同じ方法を用いて, それらを状況に
応じて設定するようにできます.

MS-DOS『オペレーティングシステム』では, 非同期のサブプロセスを使えませ
ん.  対応策として, MS-DOSでは`M-x compile'はコンパイルコマンドを同期的
に実行します.  その結果, Emacs上で他の作業を行うには, コンパイルコマン
ドの終了を待つ必要があります.  *Note MS-DOS::.



File: emacs-ja, Node: Debuggers, Next: Executing Lisp, Prev: Compilation Shell, Up: Building

Emacs下でのデバッガの実行
=========================

GUD（Grand Unified Debugger, 大統一デバッガ）ライブラリは, Emacsからさ
まざまなデバッガへのインターフェイスを提供します.  フリーソフトウェア
であるGDBをお勧めしますが, DBX, SDB, XDBを持っているならばそれらを使う
こともできます.  GUDは, Perlのデバッグモード, PythonのデバッガPDB,
JavaデバッガJDBに対するインターフェイスにもなります.

* Menu:

* Starting GUD::	How to start a debugger subprocess.
* Debugger Operation::	Connection between the debugger and source buffers.
* Commands of GUD::	Key bindings for common commands.
* GUD Customization::	Defining your own commands for GUD.



File: emacs-ja, Node: Starting GUD, Next: Debugger Operation, Prev: Debuggers, Up: Debuggers

GUDの起動
---------

デバッガを開始するコマンドはいくつかあり, それぞれ, 特定のデバッガに対
応しています.

`M-x gdb RET FILE RET'
     EmacsのサブプロセスとしてGDBを実行する.  このコマンドは, GDBへの
     入出力用のバッファを新たに作り, そのバッファへ切り替える.  GDBバッ
     ファが既存の場合は, そのバッファへ切り替えるだけ.

`M-x dbx RET FILE RET'
     同様に, GDBのかわりにDBXを実行する.

`M-x xdb RET FILE RET'
     同様に, GDBのかわりにXDBを実行する.  ソースファイルを探索するディ
     レクトリ群を指定するには, 変数`gud-xdb-directories'を使う.

`M-x sdb RET FILE RET'
     同様に, GDBのかわりにSDBを実行する.

     SDBのバージョンによっては, メッセージにソースファイル名を含めない
     ものがある.  そのようなSDBを使う場合には, GUDがソースコードから関
     数を探せるように正しいタグテーブル（*Note Tags::）が必要である. 
     タグテーブルを訪問していなかったり, タグテーブルに当該関数がなかっ
     たりすると, `The sdb support requires a valid tag table to work'
     というメッセージが表示される.  このような場合には, 作業ディレクト
     リに正しいタグファイルを生成してからやり直す.

`M-x perldb RET FILE RET'
     PerlプログラムFILEをデバッグするためにPerlインタープリタをデバッ
     グモードで実行する.

`M-x jdb RET FILE RET'
     FILEをデバッグするためにJavaデバッガを実行する.

`M-x pdb RET FILE RET'
     FILEをデバッグするためにPythonデバッガを実行する.

これらのコマンドは引数を1つ, つまり, デバッガを起動するコマンド行を取
ります.  もっとも単純な場合は, デバッグしたい実行ファイルの名前を指定
します.  デバッガに指定できるオプションを使うこともできます.  しかし, 
シェルのワイルドカードや変数名は使えません.  GUDは, `-'で始まらない最
初の引数をデバッグする実行ファイル名であると仮定します.

Emacsはデバッガプロセスを一度に1つだけ実行できます.



File: emacs-ja, Node: Debugger Operation, Next: Commands of GUD, Prev: Starting GUD, Up: Debuggers

デバッガの操作
--------------

GUDの下でデバッガを実行すると, デバッガは通常の入出力にEmacsバッファを
使います.  このバッファをGUDバッファと呼びます.  デバッガはEmacsバッファ
でファイルを訪問して, プログラムのソースファイルを表示します.  このよ
うなバッファの1つに矢印（`=>'）が表示され, 現在実行している行を表示し
ます.  このバッファでポイントを動かしても矢印は動きません.

ソースファイルを表示したバッファでは, いつでもソースファイルを編集でき
ます.  矢印はファイルのテキストの一部ではなく, 画面上に表示されている
だけです.  ソースファイルを変更するとき, 行を挿入／削除すると矢印の表
示位置情報が失われることに注意してください.  GUDには, 変更前のデバッガ
メッセージから変更後の対応する行番号を知る術はありません.  また, デバッ
ガにソースの変更を反映するには, プログラムを再コンパイルしてから再実行
する必要があります.

お好みならば, シェル（shell）モードの変形を用いたデバッガバッファを介
して, デバッガプロセスを完全に制御することもできます.  こうすれば, デ
バッガのすべてのコマンドを利用でき, シェル（shell）モードの履歴機能を
用いてコマンドを繰り返し実行できます.  *Note Shell Mode::.



File: emacs-ja, Node: Commands of GUD, Next: GUD Customization, Prev: Debugger Operation, Up: Debuggers

GUDのコマンド
-------------

GUD対話バッファはシェル（shell）モードの変形を使うので, シェル（shell）
モードのコマンドを使えます（*Note Shell Mode::）.  GUDモードでは, ブレー
クポイントの設定と解除, スタックフレームの選択, プログラムのステップ実
行などのコマンドもあります.  これらのコマンドはGUDバッファでもそれ以外
でも使えますが, キーバインドは異なります.

ブレークポイントコマンドは, 普通, ソースファイルのバッファで使います. 
というのは, ソース上でブレークポイントを設定／解除するのが自然だからで
す.  以下はブレークポイントを設定するグローバルコマンドです.

`C-x SPC'
     ポイントがあるソース行にブレークポイントを設定する.

以下はその他のGUDモード特有のコマンドです.  `C-c'で始まるキー列は, GUD
対話バッファだけで使えます.  `C-x C-a'で始まるキー列は, GUD対話バッファ
とソースファイル（のバッファ）の両方で使えます.

`C-c C-l'
`C-x C-a C-l'
     GUDバッファで参照した最後の行を別のウィンドウに表示する（つまり, 
     最新の実行位置メッセージが指す行を表示する）.  これは, コマンド
     `gud-refresh'を実行する.

`C-c C-s'
`C-x C-a C-s'
     ソースコード1行分を実行する（`gud-step'）.  その行に関数呼び出し
     が含まれる場合は, 呼び出された関数に入ってから停止する.

`C-c C-n'
`C-x C-a C-n'
     ソースコード1行分を実行し, 関数呼び出しでも停止せずにフルスピード
     で実行する（`gud-next'）.

`C-c C-i'
`C-x C-a C-i'
     機械語1命令を実行する（`gud-stepi'）.

`C-c C-r'
`C-x C-a C-r'
     停止位置を指定せずに実行を継続する.  プログラムの実行は, ブレーク
     ポイントに出会う, プログラムが終了する, デバッガが監視しているシ
     グナルを受け取るまで実行を継続する.

`C-c C-d'
`C-x C-a C-d'
     現在のソース行にブレークポイントがあるならばそれを削除する
     （`gud-remove'）.  GUD対話バッファでこのコマンドを使うと, プログ
     ラムが最後に停止した行に適用される.

`C-c C-t'
`C-x C-a C-t'
     現在のソース行に一時的なブレークポイントを設定する.  GUD対話バッ
     ファでこのコマンドを使うと, プログラムが最後に停止した行に適用さ
     れる.

上にあげたコマンドは, （GUDから使える）すべてのデバッガに共通です.
GDBやDBX（のあるバージョン）では, さらに以下のコマンドも使えます.

`C-c <'
`C-x C-a <'
     1つ外側のスタックフレームを選択する（`gud-up'）.  これは`up'コマ
     ンドと等価.

`C-c >'
`C-x C-a >'
     1つ内側のスタックフレームを選択する（`gud-down'）.  これは`down'
     コマンドと等価.

GDBを使う場合には以下のコマンドも使用できます.

`TAB'
     GDBでは, シンボル名を補完する（`gud-gdb-complete-command'）.  こ
     のキーはGUDの対話バッファでだけ使える.  また, GDBのバージョンは
     4.13以降であること.

`C-c C-f'
`C-x C-a C-f'
     あらかじめ選択したスタックフレームから戻る（あるいは, 他の理由で
     停止する）までプログラムを実行する.

これらのコマンドは, 意味がある場合には数引数を反復回数として解釈します.

TABは, 補完コマンドとして働くため, GDBでデバッグしているプログラムへの
タブの入力には使えません.  タブを入力するには`C-q TAB'と打鍵します.



File: emacs-ja, Node: GUD Customization, Next: Executing Lisp, Prev: Commands of GUD, Up: Debuggers

GUDのカスタマイズ
-----------------

GUDが実行を開始すると, GDBの場合は`gdb-mode-hook', DBXの場合は
`dbx-mode-hook', SDBの場合は`sdb-mode-hook', XDBの場合は
`xdb-mode-hook', Perlのデバッグモードの場合は`perldb-mode-hook', PDBの
場合は`pdb-mode-hook', JDBの場合は`jdb-mode-hook'のフックを実行します. 
これらのフックを使って, デバッガの対話バッファ用に自前のキーバインドを
定義できます.  *Note Hooks::.

以下は, 特定のコマンド文字列をデバッガに送るコマンドを定義し, かつ, そ
のコマンドに対するキーバインドをデバッガの対話バッファに設定する便利な
方法です.

     (gud-def FUNCTION CMDSTRING BINDING DOCSTRING)

これは, デバッガプロセスにCMDSTRINGを送るFUNCTIONという名前のコマンド
を定義し, そのコマンドの説明文字列をDOCSTRINGとします.  このように定義
したコマンドは, どのバッファでも使えます.  BINDINGが`nil'以外の場合,
`gud-def'はGUDバッファのモードに対してはこのコマンドを`C-c BINDING'に
バインドし, それ以外に対しては`C-x C-a BINDING'にバインドします.

コマンド文字列CMDSTRINGには, FUNCTIONが呼び出されたときにデータが埋め
込まれる`%'系列を含めることもできます.

`%f'
     現在のソースファイルの名前.  カレントバッファがGUDバッファだった
     場合には, 『現在のソースファイル』とはプログラムが停止した箇所に
     対応するソースファイル.

`%l'
     現在のソース行番号.  カレントバッファがGUDバッファだった場合には, 
     『現在のソース行番号』とはプログラムが停止した箇所に対応するソー
     スファイルの行番号.

`%e'
     ポイント位置あるいはポイントに隣接するCの左辺値か関数呼び出し式.

`%a'
     ポイント位置あるいはポイントに隣接する箇所の16進数表記アドレス.

`%p'
     FUNCTIONを呼ぶときに指定された数引数を10進値表記したもの.  数引数
     なしで呼ばれた場合, `%p'は空文字列.

     CMDSTRINGで`%p'を使用しなければ, 定義しようとしているFUNCTIONは数
     引数を無視する.



