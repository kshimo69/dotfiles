Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja  Node: Sunrise/Sunset-Footnotes, Up: Sunrise/Sunset

(1) 【訳注】グリニッジ標準時と呼称していたものに相当.



File: emacs-ja, Node: Lunar Phases, Next: Other Calendars, Prev: Sunrise/Sunset, Up: Calendar/Diary

朔弦望（新月, 上弦, 満月, 下弦）
================================

以下のコマンドは, 朔弦望（新月, 上弦, 満月, 下弦）の日付と時刻を表示し
ます.  これらの機能は, 『朔弦望に依存する』問題をデバッグするときに重
宝します.

`M'
     表示してある3か月間の朔弦望の日付／時刻の一覧を表示する
     （`calendar-phases-of-moon'）.
`M-x phases-of-moon'
     今日を中央にした3か月間の朔弦望の日付／時刻の一覧を表示する.

カレンダー内で`M'コマンドを使うと, 現在の3か月間の朔弦望の日付／時刻を
別のバッファに表示します.  一覧内の日付／時刻は数分以内の精度です.

カレンダーの外からでも, `M-x phases-of-moon'コマンドを使って, 今月を中
央月として前後1か月の朔弦望の日付／時刻を表示できます.  別の期間に関し
て調べるには`C-u M-x phases-of-moon'を使います.  すると, 月と年を聞い
てきます.

朔弦望の日付／時刻は（必要ならば夏時間を補正して）地方時で与えられます. 
しかし, 変数`calendar-time-zone'が設定されていなければ, 協定世界時（グ
リニッジ標準時）が使われます.  *Note Daylight Savings::.



File: emacs-ja, Node: Other Calendars, Next: Diary, Prev: Lunar Phases, Up: Calendar/Diary

他の暦との相互変換
==================

Emacsのカレンダーは*つねに* グレゴリオ暦（Gregorian calendar）で表示し
ます.  この暦は『新暦』とも呼ばれ, 今日では世界の大部分で使われていま
す.  しかし, この暦は16世紀以前には存在せず, 18世紀になるまでは普及し
ていませんでした.  ユリウス暦（Julian calendar）に置き替って世界的に受
け入れられたのは20世紀初頭になってからです.  Emacsのカレンダーは西暦1
年1月以降の任意のカレンダーを表示できますが, グレゴリオ暦が存在しなかっ
た時代に関してもグレゴリオ暦に基づいた暦を表示します.

Emacsは他の暦を表示することはできませんが, 指定した日付と他の暦の日付
とを相互に変換できます.

* Menu:

* Calendar Systems::	   The calendars Emacs understands
			     (aside from Gregorian).
* To Other Calendar::	   Converting the selected date to various calendars.
* From Other Calendar::	   Moving to a date specified in another calendar.
* Mayan Calendar::	   Moving to a date specified in a Mayan calendar.



File: emacs-ja, Node: Calendar Systems, Next: To Other Calendar, Prev: Other Calendars, Up: Other Calendars

参照可能な暦
------------

ISO商用暦はヨーロッパで広く使われています.

ユリウス暦は, ジュリアス・シーザー（ユリウス・カエサル, Julius Caesar）
に因んで命名されたもので, 中世から19世紀にかけてヨーロッパ中で使われて
いました.

天文学者は, ユリウス暦紀元前4713年1月1日月曜の正午からの経過日数を使い
ます.  この経過日数を*ユリウス日*（Julian day number）とか*天文通算日*
（Astronomical day number）と呼びます.

ヘブライ暦は昔からユダヤ教で使われてきました.  Emacsのカレンダープログ
ラムは, ユダヤの祝祭日がどの日付かを決定するのにヘブライ暦を使います. 
ヘブライ暦では1日は日没から始まり日没で終ります. (1) (*Note Calendar
Systems-Footnotes::)

イスラム暦は多くのイスラム教の国々で使われています.  Emacsはイスラム暦
を用いてイスラム教の祝祭日を決定します.  イスラムの世界ではカレンダー
についての世界的な取り決めが存在しません.  Emacsは広く受け入れられてい
るものを使用していますが, イスラム教の祝祭日の正確な日付は, 計算によっ
てではなく宗教上の権威筋の布告によってしばしば決定されます.  そのため, 
実際の日付とEmacsが計算した日付には少々違いがあります.  イスラム暦の1
日は日没から始まり日没で終ります.

フランス革命暦は, 1789年の大革命以降にジャコバン党によって作成されまし
た.  より永続的で自然に準じて年周期を捉えることを目的に, 度量衡に類似
した合理的な尺度ということで1週間を10日にしています.  フランス政府は, 
この暦を1805年の終りに公式に放棄しました.

中央アメリカのマヤでは, 3種類の別だが重複している暦の体系, *ロングカウ
ント*（long count）, *ゾルキン*（tzolkin）, *ハアブ*（haab）を使ってい
ました.  Emacsはこれらの3つの暦をすべて知っています.  専門家はマヤ暦と
われわれの暦が正確にはどのように関連しているか議論している最中です.
Emacsは, グッドマン・マーチンス・トンプソンの関連付けを用いて計算しま
す.

コプト教徒は古代エジプト太陽暦に基づく暦を使っています.  この暦は, お
のおの30日からなる12個の月と, それに続く余分の5日間で構成されます.  4
年に一度, 余分の5日間に閏日（1日間）を付け加えて6日間とします.  エチオ
ピア暦は構造的にはコプト暦と同一ですが, コプト暦とは異なった年数と月の
名前を用いています.

ペルシア人はオマール・カイヤーム（Omar Khayyam） (2) (*Note Calendar
Systems-Footnotes::)が作った暦に基づいた太陽暦を使っています.  この暦
は, 12個の月から成り, 最初の6個の月は31日, つぎの5個の月は30日, 最後の
1個の月は平年は29日で閏年には30日となります.  閏年は4年か5年に一度入る
複雑なパターンで起こります.

中国暦は, 朔望月を太陽年に埋め込んだ複雑なものです.  年は60を単位とし
て一周し, 平年は12個の月ですが, 閏年は13個の月です.  各月は29日か30日
です.  年, 平月, 日は, 10の天の主節 (3) (*Note Calendar
Systems-Footnotes::)と12の地の副節 (4) (*Note Calendar
Systems-Footnotes::) に従って名付けられ, 60を周期として巡回します. (5)
(*Note Calendar Systems-Footnotes::)


File: emacs-ja  Node: Calendar Systems-Footnotes, Up: Calendar Systems

(1) 【訳注】蛇足ですが, クリスマスは本来ユダヤ教の祝祭日で, 12月24日の
日没から始まる.  これがクリスマスイブを祝う本当の理由.

(2) 【訳注】ペルシアの数学者・天文学者・詩人

(3) 【訳注】十干.  五行（木, 火, 土, 金, 水）に兄, 弟を付け加えた甲
（きのえ）, 乙（きのと）, 丙（ひのえ）, 丁（ひのと）, 戊（つちのえ）, 
己（つちのと）, 庚（かのえ）, 辛（かのと）, 壬（みずのえ）, 癸（みずの
と）からなる.

(4) 【訳注】十二支.  子（ね）, 丑（うし）, 寅（とら）, 卯（う）, 辰
（たつ）, 巳（み）, 午（うま）, 未（ひつじ）, 申（さる）, 酉（とり）, 
戌（いぬ）, 亥（い）からなる.

(5) 【訳注】甲子（きのえね）, 乙丑, 丙寅, …, 癸亥（みずのとい）までの
60通り（12と10の最小公倍数）になる.  辛亥革命の辛亥, 壬申の乱の壬申な
どは年を表している.



File: emacs-ja, Node: To Other Calendar, Next: From Other Calendar, Prev: Calendar Systems, Up: Other Calendars

他の暦への変換
--------------

以下のコマンドは選択した日（ポイントがある日）を他の暦で表示します.

`Mouse-2  Other Calendars'
     クリックした日が, 他のさまざまな暦ではどうなるかを表示する.
`p c'
     選択した日をISO商用暦の日付で表示する（`calendar-print-iso-date'）.
`p j'
     選択した日をユリウス暦の日付で表示する
     （`calendar-print-julian-date'）.
`p a'
     選択した日を天文通算日（ユリウス日）で表示する
     （`calendar-print-astro-day-number'）.
`p h'
     選択した日をヘブライ暦の日付で表示する
     （`calendar-print-hebrew-date'）.
`p i'
     選択した日をイスラム暦の日付で表示する
     （`calendar-print-islamic-date'）.
`p f'
     選択した日をフランス革命暦の日付で表示する
     （`calendar-print-french-date'）.
`p C'
     選択した日を中国暦の日付で表示する（`calendar-print-chinese-date'）.
`p k'
     選択した日をコプト暦の日付で表示する
     （`calendar-print-coptic-date'）.
`p e'
     選択した日をエチオピア暦の日付で表示する
     （`calendar-print-ethiopic-date'）.
`p p'
     選択した日をペルシア暦の日付で表示する
     （`calendar-print-persian-date'）.
`p m'
     選択した日をマヤ暦の日付で表示する（`calendar-print-mayan-date'）.

XウィンドウシステムでEmacsを使っている場合には, ある日付を他の暦での日
付に変換するいちばん簡単な方法は, その日付を`Mouse-2'でクリックし, 立
ち上がったメニューから`Other Calendars'を選びます.  対応する日付を
Emacsが知っているすべての暦でメニューに表示します.  （このメニューは単
なる表示用なので, 項目を選んでも何も起こらない. ）

グレゴリオ暦の目的の日付にポイントを動かして適切なキーを打ちます.  `p'
はprintの意味で, Emacsはその日を指定された暦でエコー領域に表示します.



File: emacs-ja, Node: From Other Calendar, Next: Mayan Calendar, Prev: To Other Calendar, Up: Other Calendars

他の暦からの変換
----------------

Emacsが扱える暦で日付を指定して, カレンダーの対応する日に移動できます. 
本節では, マヤ暦を除く暦でこれを行うコマンドを説明します.  マヤ暦につ
いては, これに続く節を参照してください.

`g c'
     ISO商用暦で指定した日付に移動する（`calendar-goto-iso-date'）.
`g j'
     ユリウス暦で指定した日付に移動する（`calendar-goto-julian-date'）.
`g a'
     天文通算日（ユリウス日）で指定した日付に移動する
     （`calendar-goto-astro-day-number'）.
`g h'
     ヘブライ暦で指定した日付に移動する（`calendar-goto-hebrew-date'）.
`g i'
     イスラム暦で指定した日付に移動する（`calendar-goto-islamic-date'）.
`g f'
     フランス革命暦で指定した日付に移動する
     （`calendar-goto-french-date'）.
`g C'
     中国暦で指定した日付に移動する（`calendar-goto-chinese-date'）.
`g p'
     ペルシア暦で指定した日付に移動する（`calendar-goto-persian-date'）.
`g k'
     コプト暦で指定した日付に移動する（`calendar-goto-coptic-date'）.
`g e'
     エチオピア暦で指定した日付に移動する
     （`calendar-goto-ethiopic-date'）.

これらのコマンドは, それぞれの暦での日付を聞いてきて, それに対応するグ
レゴリオ暦の日付にポイントを移動します.  また, エコー領域には指定した
暦の日付を表示します.  Emacsは月の名前をユーザーに聞くときに強い補完
（*Note Completion::）を使うので, ヘブライ暦／イスラム暦／フランス革命
暦などの月の名前の綴りを気にする必要はないでしょう.

ヘブライ暦で問題となるのが追悼記念祭『ヤールツァイト』（yahrzeit）と呼
ばれる命日の計算です.  Emacsのカレンダーにはその計算機能があります. 
カレンダー内にカーソルがあるときに`M-x list-yahrzeit-dates'コマンドを
実行すると年の範囲を聞いてきます.  そして, ポイントがある日付に対応し
た追悼記念祭の日付を指定した範囲の年について一覧表示します.  カレンダー
内にいないときにこのコマンドを使うと, まず死亡年月日を聞いてから年の範
囲を聞いてきます.  そして, 追悼記念祭の日付の一覧を表示します.



File: emacs-ja, Node: Mayan Calendar, Next: Diary, Prev: From Other Calendar, Up: Other Calendars

マヤ暦からの変換
----------------

以下はマヤ暦で日付を指定する方法です.

`g m l'
     ロングカウント暦で指定した日付に移動する
     （`calendar-goto-mayan-long-count-date'）.
`g m n t'
     ゾルキン暦のつぎの周期の日に進む（`calendar-next-tzolkin-date'）.
`g m p t'
     ゾルキン暦のまえの周期の日に戻る
     （`calendar-previous-tzolkin-date'）.
`g m n h'
     ハアブ暦のつぎの周期の日に進む（`calendar-next-haab-date'）.
`g m p h'
     ハアブ暦のまえの周期の日に戻る（`calendar-previous-haab-date'）.
`g m n c'
     マヤのカレンダーラウンドのつぎの周期の日に進む
     （`calendar-next-calendar-round-date'）.
`g m p c'
     マヤのカレンダーラウンドのまえの周期の日に戻る
     （`calendar-previous-calendar-round-date'）.

これらのコマンドを理解するには, マヤ暦を理解しておく必要があります.  "
ロングカウント"は以下の単位に基づいて日付を計算したものです.

     1キン（kin） = 1日   1ユイナル（uinal） = 20キン
     1タン（tun） = 18ユイナル   1カタン（katun） = 20タン
     1バクタン（baktun） = 20カタン

したがって, ロングカウントの12.16.11.16.6は, 12バクタン, 16カタン, 11 
タン, 16ユイナル, 6キンを表しています.  Emacsのカレンダーはマヤ暦ロン
グカウント7.17.18.13.1 (1) (*Note Mayan Calendar-Footnotes::) まで遡る
ことができますが, それ以前は扱えません.  `g m l'コマンドを使ってマヤ暦
ロングカウントの日付を入力するときには, バクタン, カタン, タン, ユイナ
ル, キンをピリオドで区切ってください.

マヤ暦ゾルキンは, 独立した13日と20日の周期からなる260日周期です.  この
周期が永遠に繰り返されるため, Emacsには, つぎの周期へ進んだりまえの周
期へ戻るコマンドがあります.  `g m p t'と打つと, ゾルキン暦のまえの周期
の日に戻ります.  このコマンドは, ゾルキン暦の日付を聞いてきて, その日
付のまえの周期の日にポイントを戻します.  同様に, `g m n t'は, ゾルキン
暦のつぎの周期の日に進めます.

マヤ暦ハアブは365日の周期で, 20日からなる18個の月と月に属さない5日間か
らなっています.  ゾルキン暦の周期と同様に, この周期が永遠に繰り返され
るため, Emacsにはつぎの周期の日へ進んだりまえの周期の日に戻るコマンド
があります.  `g m p h'と打つと, ハアブ暦のまえの周期に日に戻ります. 
このコマンドは, ハアブ暦の日付を聞いてきて, その日付のまえの周期の日に
ポイントを戻します.  同様に, `g m n h'は, ハアブ暦のつぎの周期の日に進
めます.

マヤではゾルキン暦とハアブ暦を組み合わせた暦も使われていました.  組み
合わせの1周期は約52年で*カレンダーラウンド*と呼ばれます.  `g m p c'と
打つと, Emacsはハアブ暦の日付とゾルキン暦の日付を聞いてきます.  そして, 
まえの組み合わせ周期の日にポイントを戻します.  つぎの組み合わせ周期の
日にポイントを進めるには`g m n c'を使います.  これらのコマンドは, 指定
したハアブ暦／ゾルキン暦の日付の組み合わせが不可能であるとエラーを通知
します.

Emacsはマヤ暦の名前の入力では強い補完（*Note Strict Completion::）を使
うので, 綴りを気にする必要はありません.


File: emacs-ja  Node: Mayan Calendar-Footnotes, Up: Mayan Calendar

(1) 【訳注】この日は西暦1年1月1日で, Emacsのカレンダーは紀元前を扱えな
い.



File: emacs-ja, Node: Diary, Next: Appointments, Prev: Other Calendars, Up: Calendar/Diary

日誌
====

Emacsの日誌機能は, カレンダーと連動して, 1日を単位に約束やその他の予定
を管理します.  日誌機能を使うには, 用事と日付を書き込んだ"日誌ファイル
"（diary file）をまず作っておく必要があります.  そうしておくと, Emacs
は自動的にこのファイルを取り込んで, 今日／数日先／指定した日付の予定を
表示します.

デフォルトでは, Emacsは日誌ファイルとして`~/diary'を使います.  これは
`calendar'プログラムが使うファイルと同じです.  以下に`~/diary'ファイル
の例を示します.

     12/22/1988  20回目の結婚記念日！
     &1/1.       新年おめでとう！
     10/22       ルースの誕生日
     * 21, *:    給料日
     Tuesday  10時から院生たちと週間ミーティング
              スポウイット, シェン, ビットナー, カポールと約束
     1/13/89     13日の金曜日！！
     &thu 4pm    ロイドとスカッシュをする
     mar 16      親父の誕生日
     April 15, 1989 所得税の納付期限
     &* 15       勤務表の提出期限

この例では, 大部分の予定の項目に余分な空白を入れて整列してありますが, 
これは純粋に好みの問題です.

日誌を手で作成しようとしているかもしれませんが, Emacsには, 日誌の項目
を眺めたり, 追加したり, 変更したりするコマンドが数多くあります.

* Menu:

* Diary Commands::         Viewing diary entries and associated calendar dates.
* Format of Diary File::   Entering events in your diary.
* Date Formats::	   Various ways you can specify dates.
* Adding to Diary::	   Commands to create diary entries.
* Special Diary Entries::  Anniversaries, blocks of dates, cyclic entries, etc.



File: emacs-ja, Node: Diary Commands, Next: Format of Diary File, Prev: Diary, Up: Diary

日誌項目の表示コマンド
----------------------

いったん`~/diary'ファイルを作成しておけば, カレンダーを使ってこれを眺
めることができます.  また, カレンダー（calendar）モードの外からでも, 
今日の予定を参照できます.

`d'
     選択した日付のすべての日誌項目を表示する（`view-diary-entries'）.
`Mouse-2 Diary'
     クリックした日付のすべての日誌項目を表示する.
`s'
     日誌ファイル全体を表示する（`show-all-diary-entries'）.
`m'
     日誌項目が登録されているすべての日付に印を付ける
     （`mark-diary-entries'）.
`u'
     カレンダーウィンドウの印を消す（`calendar-unmark'）.
`M-x print-diary-entries'
     現在表示している日誌項目をそのまま印刷する.
`M-x diary'
     今日の日付の日誌項目すべてを表示する.
`M-x diary-mail-entries'
     これからの予定を自分自身にメイルする.

`d'で日誌項目を表示すると, 別のウィンドウに選択した日付の日誌項目が表
示されます.  新しいウィンドウのモード行には, 日誌項目の日付とその日付
の祝祭日情報が表示されます.  `d'に数引数を指定すると, 指定した日数の期
間の日誌項目を表示します.  したがって, `2 d'は, 選択した日とそのつぎの
日のすべての項目を表示します.

ある日付の日誌項目を表示する別の方法として, 日付を`Mouse-2'でクリック
し, 立ち上がったメニューから項目`Diary'を選ぶことです.

日誌が記載されている日付を知るには`m'コマンドを使います.  このコマンド
は, 日誌が記載されている日付を別のフェイスで（複数のフェイスを使えなけ
れば, 日付のあとに`+'を付けて）表示します.  このコマンドは, 画面に見え
ている期間だけでなく, スクロールすると見えてくる期間にも適用されます. 
印を消してもとの状態に戻るには`u'コマンドを使いますが, 祝祭日の印も同
時に消えます.  （*Note Holidays::）.

日誌ファイル内の数項目ではなく全体を見るには, `s'コマンドを使います.

選択した日誌項目だけを表示するには, 選択表示機能を用いて他の項目を隠し
ます.

画面で見ている日誌用バッファは幻でしかありません.  そのため, 単純にバッ
ファを印刷しても画面に表示されているようには印刷できません.  画面に表
示されている日誌項目を*あるがまま*に印刷するには専用のコマンド`M-x
print-diary-entries'を使う必要があります.  このコマンドはデータをプリ
ンタに直接送ります.  `lpr-region'のようにカスタマイズできます（*Note
Hardcopy::）.

コマンド`M-x diary'は, 現在のカレンダー表示とは関係なしに, 場合によっ
ては数日後までを含めて今日の日誌を表示します.  変数
`number-of-diary-entries'には何日間まで含めるか指定します.  *Note カレ
ンダーと日誌のカスタマイズ: (elisp-ja)Calendar.。

個人の`.emacs'ファイルに`(diary)'と書けば, Emacsを実行すると自動的に当
日の日誌項目をウィンドウに表示します.  そのウィンドウのモード行には, 
日付と祝祭日情報が表示されます.

多くのユーザーは, 日誌に記載した予定を電子メイルで受け取ることを好みま
す.  自分自身にそのようなメイルを送るには, コマンド`M-x
diary-mail-entries'を使います.  数引数で（今日から始めて）何日間を含め
るか指定します.  数引数を指定しなければ, 変数`diary-mail-days'が日数を
指定します.



File: emacs-ja, Node: Format of Diary File, Next: Date Formats, Prev: Diary Commands, Up: Diary

日誌ファイル
------------

個人の日誌ファイルは, 用事と日付の対応付けを記録したファイルです.  日
誌ファイルの名前は, 変数`diary-file'で指定します.  デフォルトは
`~/diary'です.  `calendar'プログラムは, Emacsの日誌機能が扱う形式を部
分的に扱えます.  そのため, `calendar'プログラムでもそれなりに日誌ファ
イルを眺められますが, 正しく解釈されない項目もあるでしょう.

日誌ファイルの各項目は, 1つの用事を表し, 1行以上の行から成ります.  項
目はつねに行頭の日付指定で始まります.  項目の残りの部分は用事を説明す
る単なるテキストです.  項目が1行に収まらないときには, 後続行の行頭を白
文字で始めて直前の項目の続きであることを示します.  正しい日付指定で始
まらない行や直前の項目の続きの行でないものは無視されます.

カレンダーのウィンドウ内で特定の日誌項目に印を付けないようにできます. 
それには, 項目の日付指定のまえにアンパーサンド（`&'）を付けます.  これ
は, 日誌ウィンドウに項目を表示するのには影響ありません.  カレンダーウィ
ンドウの日付の印だけに影響します.  印付けを禁止した項目は一般的な項目
としては便利で, こうしないと印が付いた日が多くなりすぎます.

項目の最初の行が日付指定や曜日だけの場合には, 最初の行は日誌ウィンドウ
に表示されません.  後続の行だけが表示されます.  たとえば, つぎの項目は, 
日誌ウィンドウでは先頭に日付の行は表示されません.

     02/11/1989
          本日B. ビルがプリンストンに来る
          2pm 認知研究委員会の会合
          2:30-5:30 ローレンスビルにリズ
          4:00pm 歯医者予約
          7:30pm ジョージの所で夕食
          8:00-10:00pm コンサート

この流儀だと1日分の予定を表示する限りはきちんと見えるのですが, 2日分以
上の場合には混乱しかねません.

ウィンドウに表示された日誌項目は編集できますが, 表示されたバッファには
日誌ファイル*全体*が含まれていて, ある部分が隠されいるのだということを
忘れてはなりません.  たとえば, `C-f'（`forward-char'）コマンドで表示上
の行末にポイントを置けますが, 実際には隠された行の途中にいるのかもしれ
ません.

*日誌項目を編集するときには注意してください！*` ' 項目に余分な行を追加
したり見えている行の途中に文字を追加／削除しても問題は生じませんが, 行
末で編集すると予期しないことが起こる可能性があります.  行を削除すると
今は見えていない後続の他の項目を削除してしまうかもしれません.  日誌を
編集するまえには, `s'（`show-all-diary-entries'）でファイル全体を表示
させるのが最良です.



File: emacs-ja, Node: Date Formats, Next: Adding to Diary, Prev: Format of Diary File, Up: Diary

日付指定の形式
--------------

以下は日誌項目の例で, 使用可能ないくつかの日付指定形式を示しています. 
この例では日付をアメリカ形式（月, 日, 年）で指定していますが, カレンダー
（calendar）モードではオプションでヨーロッパ形式（日, 月, 年）も使用で
きます.

     4/20/93  新しい計算システムへ切換
     apr. 25  年ごとの計算開始 
     4/30     4月分の処理完了〆切
     */25     月ごとのサイクル完了
     Friday   ファイルのバックアップを忘れないこと

最初の項目は1993年4月20日に一度だけ表示されます.  2番目と3番目は毎年指
定した日付に表示され, 4番目は月の指定にワイルドカード（アスタリスク,
`*'）を使っているため, 毎月25日に表示されます.  最後の項目は毎週金曜日
に表示されます.

日付には, `MONTH/DAY'や`MONTH/DAY/YEAR'のように数字だけを使ってもかま
いません.  この場合, あとに続く文字は数字であってはいけません.  日付自
体のMONTH（月）とDAY（日）は1桁か2桁の数字です.  YEAR（年）は省いても
かまいませんが, これも数字で, 最後の2桁だけに省略してもかまいません. 
つまり, `11/12/1989'と書いても`11/12/89'と書いても同じです.

日付を, `MONTHNAME DAY'や`MONTHNAME DAY, YEAR'と書くこともできます. 
ここで, MONTHNAMEは英語の月の名前で3文字の省略形（ピリオドがあってもな
くてもよい）でもかまいません.  大文字小文字は区別しません.

日付の指定は"総称的"であってもかまいません.  つまり, 特定しない部分が
あってもかまいません.  そうすると, その指定に一致するすべての日付にそ
の項目が適用されます.  年を指定しなければ, それは総称的であり, その項
目は毎年に適用されます.  あるいは, MONTH, DAY, YEARのそれぞれに`*'を指
定できます.  これは, それぞれ, 任意の月, 任意の日, 任意の年に一致しま
す.  したがって, `3/*/*'という日誌項目は, 任意の年の3月のどの日にも一
致します.  `march *'も同じことです.

もし, 月のまえに日を書くヨーロッパ形式で日付を指定したいときには, カレ
ンダー中で`M-x european-calendar'と打ちます.  あるいは, カレンダー／日
誌コマンドを使う*まえ*に変数`european-calendar-style'に`t'を設定します. 
この状態では, 日誌の中のすべての日付指定をヨーロッパ形式で解釈します. 
また, 日誌の日付を表示するときもヨーロッパ形式です.  （ヨーロッパ形式
では, MONTHNAMEのあとにはコンマは付けない. ）（デフォルトの）アメリカ
形式の日付に戻るには, `M-x american-calendar'と打ちます.

ある曜日を指定する総称的な日付として曜日の名前を使えます.  曜日の名前
は英語で綴り, 3文字の省略形（ピリオドがあってもなくてもよい）でもかま
いません.  大文字小文字は問いません.



File: emacs-ja, Node: Adding to Diary, Next: Special Diary Entries, Prev: Date Formats, Up: Diary

日誌への追加コマンド
--------------------

カレンダー（calendar）モードの中には, 日誌の項目を作成するコマンドがい
くつかあります.

`i d'
     選択した日に日誌項目を追加する（`insert-diary-entry'）.
`i w'
     選択した曜日に日誌項目を追加する（`insert-weekly-diary-entry'）.
`i m'
     選択した月の日に日誌項目を追加する（`insert-monthly-diary-entry'）.
`i y'
     選択した年の日に日誌項目を追加する（`insert-yearly-diary-entry'）.

カレンダーウィンドウ内で日を選択して`i d'コマンドを打てば, 選択した日
に日誌項目を作成できます.  このコマンドは, 別のウィンドウに日誌ファイ
ルの末尾を表示し, 日付を挿入します.  そうしたら, 日誌項目の残りの部分
を打ち込みます.

特定の曜日に日誌項目を作成したい場合には, その曜日を選択して（どの場所
でもよい）`i w'と打ちます.  これで, 総称的な日付として曜日名が挿入され
ます.  そうしたら, 日誌項目の残りの部分を打ち込みます.  同様にして, 月
の特定の日を選択してから`i m'コマンドを打って, 項目の残りの部分を打ち
込みます.  同じように, `i y'コマンドで, 毎年の特定の日に項目を挿入でき
ます.

これらのコマンドはすべて, デフォルトでは印付けされる項目を作成します. 
印付け禁止の項目を作成するには, コマンドに数引数を指定します.  たとえ
ば, `C-u i w'は毎週の印付け禁止項目を作ります.

日誌ファイルを修正したときには, Emacsを終了するまえにファイルを必ず保
存してください.



File: emacs-ja, Node: Special Diary Entries, Next: Appointments, Prev: Adding to Diary, Up: Diary

特別な日誌項目
--------------

カレンダーの日付に基づいて項目を追加する以外に, 毎年の記念日などを表す
"S式項目"（sexp entries）を日誌ファイルに入れることができます.  これら
の項目は, Emacsが日誌ファイルを読み込むときにLisp式（S式, sexp）を評価
することに基づいています.  S式項目では日付のかわりに, `%%'に続けて括弧
で括ったLisp式があります.  Lisp式が項目を適用する日付を決定します.

カレンダー（calendar）モードには, よく使われるS式項目を追加するコマン
ドがあります.

`i a'
     指定した日付の毎年の記念日の日誌項目を追加する
     （`insert-anniversary-diary-entry'）.
`i b'
     カレントリージョンに対してブロック日誌項目を追加する
     （`insert-block-diary-entry'）.
`i c'
     指定した日から始まる定期的に巡ってくる日誌項目を追加する
     （`insert-cyclic-diary-entry'）.

ある特定の日を毎年の記念日に指定したい場合には, その日付にポイントを移
動してから`i a'コマンドを使います.  このコマンドは, 別のウィンドウに日
誌ファイルの末尾を表示し, 記念日を指定するS式を挿入します.  そうしたら, 
日誌項目の残りの部分を打ち込みます.  以下はその例です.

     %%(diary-anniversary 10 31 1948) アーサーの誕生日

この項目は, 1948年以降の毎年10月31日に適用されます.  `10 31 1948'は日
付を指定します.  （ヨーロッパ形式の日付を使っている場合には, `31'と
`10'が入れ替わる. ）この式に開始年が必要なのは, 日誌関数で経過年数の計
算に使うからです.

"ブロック"日誌項目は, 指定した期間に適用されます.  以下は, 1990年6月24
日から1990年7月10日までに適用されるブロック日誌項目の例です.

     %%(diary-block 6 24 1990 7 10 1990) 休暇

`6 24 1990'は開始日付を表し, `7 10 1990'は終了日付を表します.  （ヨー
ロッパ形式を使っている場合は, 月と日が入れ替わる. ）

ブロック項目を追加するには, ポイントとマークを期間の開始日付と終了日付
に設定してから`i b'と打ちます.  このコマンドは, 日誌ファイルの末尾を別
のウィンドウに表示して, ブロック項目指定を追加します.  そうしたら, 日
誌項目の残りの部分を打ち込みます.

"周期的"な日誌項目は, 一定間隔で繰り返します.  これを作るには, 開始日
を選択して`i c'コマンドを使います.  このコマンドは, 間隔を聞いてきます. 
そうしたら, 項目を挿入します.  以下のようになります.

     %%(diary-cyclic 50 3 1 1990) つぎの投薬

この項目は1990年3月1日から始まり, 50日ごとに適用されます.  `3 1 1990'
はこの開始日を指定しています（ヨーロッパ形式を使っている場合は, 月と日
が入れ替わる. ）

これら3つのコマンドはいずれも印付けされる項目を作成します.  印付け禁止
項目を挿入する場合には, コマンドに数引数を指定します.  たとえば, `C-u
i a'は, 印付け禁止の記念日の項目を作ります.

日誌のS式項目をカレンダーに印付けするのは*非常に*時間がかかります.  な
ぜなら, カレンダーのウィンドウに見えているすべての日付について1つ1つ調
べる必要があるからです.  したがって, S式項目を登録する際にはできる限り
（`&'を付けて）印付け禁止の日誌項目にするのがよいでしょう.

S式項目の別の利用方法には, "流動型"日誌項目があります.  これは毎年定期
に起きることがらを日数や週数や月数のオフセットで表したものです.  これ
は`cron'プログラムが解釈するcrontabの項目と互換性があります.  以下は, 
毎年11月の最終木曜日に印付け禁止の流動型日誌項目を指定する例です.

     &%%(diary-float 11 4 -1) アメリカの感謝祭

この11は11月を表し, 4は木曜（日曜を0として週の4番目の日）を表します. 
-1は『最後』を表します
（1は『最初』, 2は『2番目『, -2は『最後の1つまえ』などなど）.  月の指
定は1個の月でも月のリストでもかまいません.  たとえば, 上の11を`'(1 2
3)'に変更すると, 1月, 2月, 3月の最終木曜日に適用する項目になります. 
月の指定が`t'ならば, すべての月に適用されます.

もっとも一般的には, 日誌のS式項目は適用する日付を決定するために, どん
な計算でもできます.  *Note S式項目と装飾日誌表示: (elisp-ja)Sexp Diary
Entries.。



File: emacs-ja, Node: Appointments, Next: Daylight Savings, Prev: Diary, Up: Calendar/Diary

約束
====

日誌項目に約束が入っていて, Emacsが認識可能な形で時刻が指定されている
場合には, その予定の何分かまえに「約束がありますよ. 」と警告を出す機能
があります.  Emacsはモード行に約束がある旨の警告メッセージを表示します.

約束の警告表示を行わせるには, まずEmacsの時刻表示機能をオンにする必要
があります.  `M-x display-time'（*Note Mode Line::）と打ちます.  さら
に, 関数`appt-make-list'を以下のようにして`diary-hook'に追加する必要が
あります.

     (add-hook 'diary-hook 'appt-make-list)

個人の`.emacs'ファイルに以下のテキストを追加すれば, これまでのことを行
えます.

     (display-time)
     (add-hook 'diary-hook 'appt-make-list)
     (diary 0)

このように準備しておくと, （カレンダーのウィンドウで`d'コマンドを使う
か, `M-x diary'コマンドを使うかして）日誌を表示したときに, Emacsが認識
できる時刻指定のある約束をすべて取り込み, それらのおのおのについて指定
された時刻よりも少しまえに警告を表示します.

たとえば, 日誌ファイルに以下のような項目があるとします.

     Monday
       9:30am 休憩
      12:00pm 昼食

すると, 毎週月曜には, 日誌を表示していると午前9時20分にもうすぐ休憩だ
と表示を出し, 午前11時50分には昼食時間だと表示を出します.

時刻指定は, `9:00am'のようにam/pmスタイルでも（`12:00am'は夜中の12時,
`12:00pm'はお昼の12時を表す）, ヨーロッパや軍隊流の24時間制でもかまい
ません.  また, 一貫している必要もなく, 日誌ファイルにこれらが混在して
いてもかまいません.

Emacsはこれらの約束リストを夜中の12時過ぎに更新します.  変数
`appt-display-diary'に`nil'を設定していない限り, 日誌用バッファにつぎ
の日の予定を表示します.

約束の警告表示を目覚し時計として利用することもできます.  コマンド`M-x
appt-add'は, 個人の日誌ファイルを変更せずに約束リストに項目を追加しま
す.  `M-x appt-delete'は, 約束リストから項目を削除します.

変数`appt-issue-message'に`nil'を設定すれば, 約束の警告表示はいつでも
オフにできます.



File: emacs-ja, Node: Daylight Savings, Next: Gnus, Prev: Appointments, Up: Calendar/Diary

夏時間
======

Emacsは標準時と夏時間の違いを理解していて, 日出入, 夏至, 冬至, 春分, 
秋分, 朔弦望の時刻ではこれを補正しています.  夏時間の規則は, 地域によっ
ても, また, 歴史的にもさまざまです.  補正を正しく行うには, 使用する規
則をEmacsに与えておく必要があります.

オペレーティングシステムのなかには, その設置場所で適用する規則を記録し
ているものもあります.  このようなシステムでは, Emacsは自動的に必要な情
報をシステムから取得します.  情報の一部や全部が欠けている場合には, 現
在マサチューセッツ州ケンブリッジで使われている規則でEmacsは欠落部分を
補おうとします.  その結果が正しくないならば, 変数
`calendar-daylight-savings-starts'と`calendar-daylight-savings-ends'を
設定し, 規則をEmacsに与える必要があります.

これらの変数の値は, 変数`year'を参照するLisp式である必要があり, 評価す
ると, グレゴリオ暦での夏時間の開始日や終了日を表す`(MONTH DAY YEAR)'と
いう形のリストになる必要があります.  在住地方で夏時間を採用していない
場合には, これらの値は`nil'にしておきます.

Emacsはこれらの式を用いて夏時間の開始日を決定し, 祝祭日一覧や太陽や月
に関する計算の時刻補正に使います.

マサチューセッツ州ケンブリッジの値は以下のとおりです.

     (calendar-nth-named-day 1 0 4 year)
     (calendar-nth-named-day -1 0 10 year)

`year'で指定される年の4月の最初の日曜日（0番目）から始まり, その年の10
月の最後の月曜まで続くことを表します.  夏時間の開始日が10月1日に変更さ
れたならば, 変数`calendar-daylight-savings-starts'には以下のように設定
します.

     (list 10 1 year)

読者の地方で夏時間を採用していなかったり, すべての時刻を標準時で扱いた
い場合には, 変数`calendar-daylight-savings-starts'と変数
`calendar-daylight-savings-ends'には`nil'を設定してください.

変数`calendar-daylight-time-offset'は, 夏時間と標準時の差を分単位で指
定します.  マサチューセッツ州ケンブリッジでは60（分）です.

2つの変数`calendar-daylight-savings-starts-time'と変数
`calendar-daylight-savings-ends-time'は, 夏時間の開始／終了が地方時の
真夜中の0時から何分ずれるかを指定します.  マサチューセッツ州ケンブリッ
ジではどちらも120（分）です.


File: emacs-ja, Node: Gnus, Next: Shell, Prev: Calendar/Diary, Up: Top

gnus
====

gnusは主にネットニュースを読んだり投稿するためのEmacsパッケージです. 
電子メイル, リモートディレクトリ, ダイジェストなどのネットニュース以外
のメッセージを読んだりそれらに応答するのにも使えます.

以下ではgnusについて紹介し, いくつかの基本的な機能について説明します. 
詳しくは, *Note Gnus: (gnus)Top.を参照してください.

gnusを起動するには, `M-x gnus RET'と打ちます.

* Menu:

* Buffers of Gnus::	The group, summary, and article buffers.
* Gnus Startup::	What you should know about starting Gnus.
* Summary of Gnus::	A short description of the basic Gnus commands.



File: emacs-ja, Node: Buffers of Gnus, Next: Gnus Startup, Prev: Gnus, Up: Gnus

gnusのバッファ
--------------

ふつうのEmacsのパッケージと違って, gnusは多数の異なるバッファを使って
情報を提示したりユーザーのコマンドを受け取ります.  ユーザーがもっとも
多くの時間を使うことになるバッファは, "グループバッファ", "サマリバッ
ファ", "記事バッファ"の3つです.

"グループバッファ"はニュースグループの一覧です.  gnusが起動すると, ま
ずこのバッファが表示されます.  通常はユーザーが購読していて, かつ, 未
読記事が存在するグループだけが表示されます.  このバッファでグループを
選択します.

"サマリバッファ"は選択したグループ内の1つの記事につき1行の情報を表示し
ます.  デフォルトでは, 各記事の投稿者, 題目, 行数が表示されますが,
gnusのほとんどの表示内容と同様にこの表示内容はカスタマイズできます. 
グループバッファでグループを選択するとサマリバッファが作られ, グループ
から出ると削除されます.  サマリバッファを使って記事を選択します.

"記事バッファ"は記事を表示します.  gnusの普通の使い方では, このバッファ
を選択することはありません.  記事を操作対象とするコマンド群はサマリバッ
ファで動作します.  しかし, 望むなら, 記事バッファに切り替えて, そこで
gnusのコマンドを実行することも可能です.



File: emacs-ja, Node: Gnus Startup, Next: Summary of Gnus, Prev: Buffers of Gnus, Up: Gnus

gnusの起動時の動作
------------------

gnusが起動すると, 個人のニュース初期化ファイル`.newsrc'を読み込み, ニュー
ス記事を蓄えているローカルのニュースサーバーと通信しようとします.  ニュー
スサーバーは, ユーザーがログインしているマシンと同じである必要はありま
せん.

gnusを起動してニュースサーバーと通信したあとでもグループバッファにグルー
プが1つも表示されないときは, `L'や`A k'と打ってすべてのグループを表示
させます.  つぎに各グループの行で`u'と打って個々のグループの購読／非購
読を切り替えます.

初めてgnusを起動したときは, ごく少数の選ばれたグループのみが購読状態に
あります.  他のグループは"非購読グループ"（killed groups）になっていて,
`A k'を使うと表示されます.  最初の起動以後にニュースサーバー上に追加さ
れたグループはすべて, "ゾンビグループ"（zombie groups）になっていて,
`A z'を使うと表示されます.  `u'を使えばこれらのグループを購読状態にで
きます.

`q'でgnusを終了すると, 初期化ファイル`.newsrc'と`.newsrc.eld'にすべて
のグループの購読／非購読を自動的に記録します.  通常はこれらのファイル
を手で編集すべきではありませんが, やりかたがわかっているならかまいませ
ん.



File: emacs-ja, Node: Summary of Gnus, Next: Shell, Prev: Gnus Startup, Up: Gnus

gnusコマンドのまとめ
--------------------

ニュースを読むにはつぎの2つの段階を踏みます.

  1. グループバッファでグループを選択する.

  2. サマリバッファで記事を選択する.  記事を選択すると, サマリバッファ
     の小さなウィンドウの下の大きめのウィンドウの中の記事バッファに選
     択した記事が表示される.

gnusの各バッファにはそれぞれ独自のコマンドがあります.  しかし, gnusの
さまざまなバッファのどんなキーの意味も, 等価ではないにせよ, だいたい同
じです.  以下は, グループバッファとサマリバッファのコマンドです.

`q'
     グループバッファでは, 初期化ファイル`.newsrc'を更新してgnusを終了
     する.

     サマリバッファでは, カレントグループから抜け出てグループバッファ
     に戻る.  したがって, `q'を2回打つとgnusを終る.

`L'
     グループバッファでは, ニュースサーバーにある（非購読にしたもの以
     外の）すべてのグループを表示する.  すごく長いリストになるかもしれ
     ないので注意！

`l'
     グループバッファでは, 購読中で未読記事があるグループのみを表示す
     る.

`u'
     グループバッファでは, ポイントのある行のグループの購読／非購読を
     切り替える.  `q'でgnusを終ると, gnusはこの状態を`.newsrc'ファイル
     に記録する.  gnusは, 通常, 購読グループのみを表示するため, つぎに
     gnusを起動したときには非購読にしたグループは表示されない.

`C-k'
     グループバッファでは, ポイントのある行のグループを「抹消」する. 
     すなわち, そのグループは以後`.newsrc'にも現れなくなる.  このコマ
     ンドの効果は, 現在のgnusセッションだけでなく将来のgnusセッション
     にも影響する.

     `q'でgnusを終了すると, gnusはファイル`.newsrc'に抹消したグループ
     を除くすべてのグループの情報を書き出す.

`SPC'
     グループバッファでは, ポイントのある行に対応するグループを選択し, 
     そのグループの最初の未読記事を表示する.

     サマリバッファでは, つぎのようになる.

        * 選択されている記事がなければ, ポイントのある行の記事を選択す
          る.

        * （選択されている記事があれば）その記事のテキストを1画面分進
          める.

        * 選択されている記事の末尾にいる場合は, つぎの未読記事を選択す
          る.

     すなわち, 繰り返しSPCを打と, すべての記事を順に見ていくことができ
     る.

`DEL'
     グループバッファでは, ポイントを未読記事がある1つまえのグループに
     移動する.

     サマリバッファでは, 記事のテキストを1画面分戻す.

`n'
     ポイントをつぎの未読グループに進めるか, または, つぎの未読記事を
     選択する.

`p'
     ポイントをまえの未読グループへ戻すか, または, まえの未読記事を選
     択する.

`C-n'
`C-p'
     既読であってもポイントを1つあと／まえの項目に移動する.  ポイント
     がある行の記事やグループを選択することはしない.

`s'
     サマリバッファでは, 記事バッファに切り替えて`C-s'を打ったかのよう
     に, 記事バッファのテキストに対してインクリメンタルサーチを行う.

`M-s REGEXP RET'
     サマリバッファでは, REGEXPに一致する記事がみつかるまで前向きに探
     索する.





File: emacs-ja, Node: Shell, Next: Emacs Server, Prev: Gnus, Up: Top

Emacsからシェルコマンドを実行する
=================================

Emacsには, 1つのコマンド行を下位のシェルプロセスに渡して実行させる機能
があります.  また, 入出力を`*shell*'という名前のEmacsバッファに接続し
て対話的にシェルを実行する機能もあります.

`M-! CMD RET'
     シェルコマンドCMDを実行し, その結果を表示する（`shell-command'）.
`M-| CMD RET'
     リージョンの内容を入力としてシェルコマンドCMDを実行する.  場合に
     よっては, リージョンをシェルコマンドの出力で置き換える. 
     （`shell-command-on-region'）.
`M-x shell'
     入出力をEmacsバッファに接続してサブシェルを実行する.  すると, 対
     話的にコマンドを入力できる.

* Menu:

* Single Shell::           How to run one shell command and return.
* Interactive Shell::      Permanent shell taking input via Emacs.
* Shell Mode::             Special Emacs commands used with permanent shell.
* History: Shell History.  Repeating previous commands in a shell buffer.
* Options: Shell Options.  Options for customizing Shell mode.
* Remote Host::            Connecting to another computer.



File: emacs-ja, Node: Single Shell, Next: Interactive Shell, Prev: Shell, Up: Shell

単一のシェルコマンド
--------------------

`M-!'（`shell-command'）は, 新たに作ったサブシェルにて, ミニバッファで
読み取った1行のテキストをシェルコマンドとして実行します.  シェルコマン
ドの標準入力はnull装置（つまり空）です.  シェルコマンドの出力があれば,
`*Shell Command Output*'という名前のEmacsバッファに入れて別のウィンド
ウに表示しますが, （カレントバッファには）選択しません.  `M-1 M-!'のよ
うに数引数を指定すると, シェルコマンドの出力をカレントバッファに挿入し
ます.  その場合, ポイントは（挿入された）出力の先頭に置かれ, マークは
出力の末尾に置かれます.

シェルコマンドの末尾が`&'になっていると, シェルコマンドは非同期に実行
されます.  同期実行のシェルコマンドでは, Lispプログラムから呼ばれたと
きには, `shell-command'はコマンドの終了状態（0は成功を意味する）を返し
ます.

`M-|'（`shell-command-on-region'）は`M-!'と同様ですが, シェルコマンド
の標準入力は空ではなくリージョンの内容が引き渡されます.  数引数を指定
すると, それまでのリージョンは削除されシェルコマンドの出力で置き換わり
新たなリージョンになります.  このコマンドは, Lispプログラムから呼ばれ
たときには, コマンドの終了状態を返します.

`M-!'も`M-|'も, 使用するシェルは`shell-file-name'で指定します.  この変
数は, Emacs起動時の環境変数`SHELL'をもとに初期設定されます.  ファイル
名にディレクトリが指定されていなければ, `exec-path'に指定されているディ
レクトリ群を探索します.  `exec-path'の値は, Emacs起動時の環境変数
`PATH'をもとに初期設定されます.  個人のファイル`.emacs'でこれらの変数
の初期値を自由に変更してかまいません.

`M-!'も`M-|'もシェルコマンドの実行完了を待ち合わせます.  待つのをやめ
たい場合は, `C-g'で中断できます.  この場合, シェルコマンドはシグナル
`SIGINT'で終了させられます.  このシグナルは, シェルを使用中に`C-c'が普
通に送るシグナルと同じです.  Emacsはシェルコマンドが実際に終了するまで
待ちます.  シェルコマンドが（シグナル`SIGINT'を無視して）停止しない場
合は, 再度`C-g'を打ちます.  すると, 無視できないシグナル`SIGKILL'をシェ
ルコマンドに送ります.

`M-!'や`M-|'で使用するコーディングシステムを指定するには, これらのコマ
ンドの直前にコマンド`C-x RET c'を使います.  *Note Specify Coding::.

コマンドからのエラー出力は, 通常, 普通の出力と混ざり合ってしまいます. 
変数`shell-command-default-error-buffer'にバッファ名の文字列を設定する
と, その名前のバッファのポイント位置のまえにエラー出力が挿入されます.



File: emacs-ja, Node: Interactive Shell, Next: Shell Mode, Prev: Single Shell, Up: Shell

対話的な下位のシェル
--------------------

サブシェルを対話的に実行し, その対話記録をEmacsバッファに残すには,
`M-x shell'を使います.  このコマンドは, `*shell*'という名前のバッファ
を作成（または再使用）し, このバッファに入出力するサブシェルを実行しま
す.  つまり, サブシェルの『端末出力』はバッファに挿入されポイントを進
め, サブシェルの『端末入力』はバッファから取られます.  サブシェルに入
力を与えるには, バッファの末尾へ移動して入力を打ち込み最後にRETを打ち
ます.

Emacsはサブシェルが何かするのを待つことはしません.  シェルが待っていよ
うがシェルコマンドを実行していようが, ウィンドウやバッファを切り替えて
編集できます.  サブシェルからの出力は, Emacsがそれを取り込む処理を実行
できるまで待たされます.  取り込み処理は, Emacsがキーボード入力を待った
り, 時間待ちに入ったときに行われます.

複数のサブシェルを使うには, バッファ`*shell*'の名前をコマンド`M-x
rename-uniquely'で別のものに変更します.  そうしてから, 再度`M-x shell'
と打ち込んで, 新しいサブシェルを持つバッファ`*shell*'を新たに作ります. 
このバッファの名前も同じように変えれば, さらに新しく作れます.  すべて
のサブシェルは独立かつ並行に実行されます.

サブシェルとして実行するファイル名は, 変数`explicit-shell-file-name' 
の値が`nil'以外ならば, この変数の値で指定します.  `nil'のときは, 環境
変数`ESHELL'の値が使われますが, これが存在しない場合は環境変数`SHELL'
の値が使われます.  指定されたファイル名が相対名の場合は, `exec-path'に
指定されているディレクトリ群を探索します.  変数`exec-path'は, Emacs起
動時の環境変数`PATH'をもとに初期設定されます.  個人のファイル`.emacs'
でこれらの変数を自由に変更してかまいません.

シェルに対するコーディングシステムを指定するには, `M-x shell'の直前に
コマンド`C-x RET c'を使います.  または, シェルを開始したあとにシェルバッ
ファで`C-x RET p'を使っても指定できます.  *Note Specify Coding::.

SHELLNAMEをシェルのファイル名として, ファイル`~/.emacs_SHELLNAME'が存
在すると, Emacsはサブシェルを実行開始した直後に初期設定のために, この
ファイルの内容をシェルへの入力として送り込みます.  たとえば, bashを使っ
ているのならファイル`~/.emacs_bash'の内容が送られます.

Emacsは, シェルコマンド, `cd', `pushd', `popd'がシェルへの入力として送
られるのを監視し, バッファ`*shell*'のデフォルトディレクトリとシェルの
カレントディレクトリが一致するようにします.  これらのシェルコマンドは, 
送られる入力行の文字列を構文的に調べて識別します.  これらのシェルコマ
ンドに別名を付けるのなら, Emacsにもその別名について教えておくことがで
きます.  たとえば, 変数`shell-pushd-regexp'の値がシェルへの入力行の先
頭に一致する場合は, その行は`pushd'コマンドであるとみなされます.
`pushd'に別名を付けたら, この変数の値を変更します.  同様に,
`shell-popd-regexp'と`shell-cd-regexp'は, `popd'と`cd'を識別するのに使
われます.  これらのコマンドはシェルへの入力行の先頭部分にあるときだけ
正しく認識されます.

Emacsは, `cd', `pushd', `popd'のシェルコマンドだと思われるものを処理中
にエラーに遭遇すると, フック`shell-set-directory-err-hook'を実行します
（*Note Hooks::）.

Emacsがサブシェルのカレントディレクトリを正しく追従できていない場合は, 
コマンド`M-x dirs'を使ってシェルにカレントディレクトリを問い合わせてく
ださい.  このコマンドは一般的なコマンドの構文を持つシェルでは動作しま
す.  ですが, とても変わったシェルでは動かないかもしれません.

`M-x dirtrack'を使うと, 別のもっと積極的なやり方でカレントディレクトリ
の変更に追従する（しない）ようにもできます.

Emacsは, サブシェルの環境変数`EMACS'に`t'を設定します.  シェルスクリプ
トでこの変数を検査すれば, Emacsのサブシェルとして動いているかどうか判
定できます.



File: emacs-ja, Node: Shell Mode, Next: Shell History, Prev: Interactive Shell, Up: Shell

シェルモード（Shellモード）
---------------------------

シェルバッファではシェル（shell）モードが使われ, プレフィックスキー
`C-c'を持つ特別なキーをいくつか定義しています.  これらは, まず`C-c'を
打つことを除けば, Emacsの外でシェルを使うときの通常のコマンド行編集や
ジョブ制御のキーに似せて定義してあります.  以下は, シェル（shell）モー
ドでの特別なバインディングの一覧です.

`RET'
     バッファの末尾で打つと, 1行分を入力としてシェルに送る.  バッファ
     の末尾以外では, 現在行をバッファの末尾にコピーしてから, それを入
     力としてシェルに送る（`comint-send-input'）.  行をコピーするとき, 
     行の先頭部分の文字列で変数`shell-prompt-pattern'に一致する部分は
     コピーしない.  この変数の値は, ユーザーのシェルがプロンプトとして
     用いる文字列に一致する正規表現であること.

`TAB'
     シェルバッファでポイントの直前にあるコマンド名やファイル名を補完
     する（`comint-dynamic-complete'）.  TABは, 履歴参照（*Note
     History References::）や環境変数名も補完できる.

     変数`shell-completion-fignore'には, シェル（shell）モードでの補完
     において無視したいファイル名の拡張子のリストを指定する.  デフォル
     トの設定では, 名前が, `~', `#', `%'で終るファイルを無視する.  関
     連する他のcomintモードではかわりに変数`comint-completion-fignore'
     を使う.

`M-?'
     シェルバッファのポイントの直前にあるファイル名の可能な補完内容を
     一時的に表示する（`comint-dynamic-list-filename-completions'）.

`C-d'
     文字を削除するか, または, EOFを送る
     （`comint-delchar-or-maybe-eof'）.  シェルバッファの末尾で`C-d'を
     打つとサブシェルにEOFを送る.  バッファのそれ以外の位置では, `C-d'
     を打つと通常どおり1文字削除する.

`C-c C-a'
     行の先頭に行く.  ただし, プロンプトがある場合にはプロンプトの直後
     に行く（`comint-bol'）.  同じ行でこのコマンドを2回繰り返すと, 2回
     目ではプロセスマークへ戻る.  プロセスマークとは, サブシェルへまだ
     送っていない入力の開始位置のこと.  （通常, これは同じ場所であり, 
     プロセスマークはその行のプロンプトの終りにある.  ただし, `C-c
     SPC'のあとでは, プロセスマークはまえの行にあるかもしれない. ）

`C-c SPC'
     複数の入力行を溜めておき, まとめて送る.  このコマンドは, ポイント
     のまえに改行を挿入するが, 少なくともまだ, その行を入力としてサブ
     シェルへ送らない.  RETを打つと, 改行のまえの1行とあとの1行を（区
     切りの改行を含めて）まとめて送る.

`C-c C-u'
     バッファの末尾にある, まだシェルに送っていないテキストをすべてキ
     ルする（`comint-kill-input'）.

`C-c C-w'
     ポイントの直前の1語をキルする（`backward-kill-word'）.

`C-c C-c'
     シェル, または, あればサブジョブに割り込む
     （`comint-interrupt-subjob'）.  また, このコマンドはシェルバッファ
     内のまだシェルに送っていないテキストもキルする.

`C-c C-z'
     シェル, または, あればサブジョブを中断する（`comint-stop-subjob'）. 
     また, このコマンドはシェルバッファ内のまだシェルに送っていないテ
     キストもキルする.

`C-c C-\'
     シェル, または, あればサブジョブにシグナルQUITを送る
     （`comint-quit-subjob'）.  また, このコマンドはシェルバッファ内の
     まだシェルに送っていないテキストもキルする.

`C-c C-o'
     直前のシェルコマンドからのひとまとまりの出力をキルする
     （`comint-kill-output'）.  シェルコマンドが大量の出力を出してしまっ
     たときなどに有効.

`C-c C-r'
`C-M-l'
     直前のひとまとまりの出力がウィンドウの先頭にくるようにスクロール
     する.  また, ポイントもそこへ動かす（`comint-show-output'）.

`C-c C-e'
     バッファの末尾がウィンドウの下端にくるようにスクロールする
     （`comint-show-maximum-output'）.

`C-c C-f'
     シェルコマンド1つ分だけ先へ進めるが, 現在行の末尾より先へはいかな
     い（`shell-forward-command'）.  変数`shell-command-regexp'には, 
     シェルコマンドの終りの探し方（正規表現）を指定する.

`C-c C-b'
     シェルコマンド1つ分だけ手前へ戻るが, 現在行の先頭よりまえへはいか
     ない（`shell-backward-command'）.

`C-c C-l'
     バッファのシェルコマンド履歴を別のウィンドウに表示する
     （`comint-dynamic-list-input-ring'）.

`M-x dirs'
     シェルにカレントディレクトリを問い合わせ, Emacs側のものをシェルに
     合わせる.

`M-x send-invisible RET TEXT RET'
     TEXTをエコーバックせずに読み取り, 入力としてシェルへ送る.  パスワー
     ドを問い合わせるようなプログラムを起動するシェルコマンドで役立つ.

     かわりに, つぎのようにして, Emacsにパスワードプロンプトを認識させ
     てエコーバックを抑制する方法もある.

          (add-hook 'comint-output-filter-functions
                    'comint-watch-for-password-prompt)

`M-x comint-continue-subjob'
     シェルプロセスを継続させる.  これはまちがってシェルプロセスを休止
     させてしまった場合に役立つ. (1) (*Note Shell Mode-Footnotes::)

`M-x comint-strip-ctrl-m'
     現在の一群のシェルの出力から復帰（コントロールM）文字を削除する. 
     このコマンドのもっとも便利な使い方の1つは, サブシェルの出力を受け
     取ると自動的にこのコマンドが実行されるように設定しておくことであ
     る.  そのためには, つぎのLisp式を評価すればよい.

          (add-hook 'comint-output-filter-functions
                    'comint-strip-ctrl-m)

`M-x comint-truncate-buffer'
     このコマンドは, 変数`comint-buffer-maximum-size'で指定した大きさ
     にシェルバッファの行数を切り詰める.  サブシェルから出力を受け取る
     たびにこれを自動的に行うにはつぎのようにする.

          (add-hook 'comint-output-filter-functions
                    'comint-truncate-buffer)

シェル（shell）モードでは段落コマンドにも修正を加えてあり, シェルプロ
ンプトでのみ新しい段落が始まるようになっています.  つまり, シェルバッ
ファでは, 1つの段落はシェルコマンドとその出力から成るのです.

シェル（shell）モードは, 対話的なサブプロセスと通信するための汎用モー
ドであるcomintモードからの派生です.  ここまでにあげてきたコマンドの名
前からもわかるように, シェル（shell）モードの数多くの機能は, 実は,
comintモードからきています.  シェル（shell）モードに固有な特別な機能は, 
正規表現に基づくプロンプトの認識, カレントディレクトリの追跡, および, 
少数のユーザーコマンドに限られます.

comintモードから派生したEmacsのほかの機能としては, GUD（*Note
Debuggers::）と`M-x run-lisp'（*Note External Lisp::）があります.

`M-x comint-run'を使うと, シェル（shell）モード固有の機能を持たない
comintモードで, 任意のプログラムをサブプロセスとして実行できます.


File: emacs-ja  Node: Shell Mode-Footnotes, Up: Shell Mode

(1) シェルプロセスを休止すべきではない.  シェルのサブジョブを休止
するのとはまったく別のことであり, こちらは普通に行ってよい.  ただ
し, 休止したサブジョブはシェルで再開させる必要がある.  このコマン
ドでは再開できない.



File: emacs-ja, Node: Shell History, Next: Shell Options, Prev: Shell Mode, Up: Shell

シェルコマンド履歴
------------------

シェルバッファでは, 以前に使ったシェルコマンドを再実行する方法が3つあ
ります.  1つめは, ミニバッファと同じキーを使う方法です.  すなわち, ミ
ニバッファの場合と同様に, ポイントはつねにバッファの末尾にある状態で, 
以前に使ったシェルコマンドをバッファに挿入できます.  2つめは, バッファ
内で以前のシェルコマンドの箇所に移動して, それをそのまま再実行するかバッ
ファの末尾にコピーします.  3つめは, `!'形式の履歴参照を使うことです.

* Menu:

* Ring: Shell Ring.             Fetching commands from the history list.
* Copy: Shell History Copying.  Moving to a command and then copying it.
* History References::          Expanding `!'-style history references.



File: emacs-ja, Node: Shell Ring, Next: Shell History Copying, Prev: Shell History, Up: Shell History

シェル履歴リング
................

`M-p'
     今のものより1つまえの古いシェルコマンドを持ってくる.

`M-n'
     今のものより1つあとの古いシェルコマンドを持ってくる.

`M-r REGEXP RET'
`M-s REGEXP RET'
     REGEXPに一致する古いシェルコマンドを後向きまたは前向きに探索する.

`C-c C-x (Shell mode)'
     履歴からつぎのコマンドを持ってくる.

シェルバッファには, それまでに入力したシェルコマンドの履歴があります. 
この履歴からシェルコマンドを再利用するには, 編集コマンド, `M-p',
`M-n', `M-r', `M-s'を使います.  これらはミニバッファの履歴コマンドと同
様に働きますが, （普通はシェルに送るテキストを挿入する）シェルバッファ
の末尾にあるテキストに作用する点が異なります.

`M-p'は, 1つまえのシェルコマンドをシェルバッファの末尾に持ってきます.
`M-p'を連続して使うと, 次々にそれよりまえに実行したシェルコマンドを持っ
てきて, それまでのシェルへの入力用テキストを置き換えます.  `M-n'も同様
ですが, 次々にそれよりあとのシェルコマンドを持ってくる点が異なります.

履歴探索コマンド`M-r'と`M-s'は, 正規表現を読み取り, それに一致するシェ
ルコマンドを履歴の中から探します.  どのシェルコマンドを持ってくるかと
いう点を除けば, それらの働きは`M-p'や`M-n'と同じです.  正規表現として
空文字列を入力すると, 直前に使用した正規表現を再使用します.

再使用したいシェルコマンドを探したならば, RETを打ってそのシェルコマン
ドを再実行するか, 必要なら編集してから実行します.

以前に連続して実行した一連のシェルコマンドをまとめて再実行できると便利
なことがあります.  それには, まず, 一連のシェルコマンドの最初のものを
探して再実行します.  そうしてから`C-c C-x'と打ちます.  これは, 直前に
再実行したシェルコマンドの（履歴内で）つぎにあるシェルコマンドを持って
きます.  RETと打って再実行します.  このように, `C-c C-x RET'を繰り返し
打てば一連のシェルコマンドを再実行できます.

これらのコマンドは過去に実行したシェルコマンドを専用の履歴リストから持っ
てくるのであって, シェルバッファからとってくるのではありません.  した
がって, シェルバッファを編集したり, その大部分をキルしたとしても, これ
らのコマンドが参照する履歴には影響しません.

いくつかのシェルは, コマンド履歴をファイルに保管して以前のセッションの
履歴を引き継げるようになっています.  Emacsは, 自分の履歴リストを初期設
定するために, ユーザーが使うシェルの履歴ファイルを読み込みます.  ファ
イル名は, bashであれば`~/.bash_history', kshであれば`~/.sh_history', 
その他のシェルであれば`~/.history'です.



File: emacs-ja, Node: Shell History Copying, Next: History References, Prev: Shell Ring, Up: Shell History

シェル履歴のコピー
..................

`C-c C-p'
     ポイントを1つまえのプロンプトへ移動する（`comint-previous-prompt'）.

`C-c C-n'
     ポイントを1つあとのプロンプトへ移動する（`comint-next-prompt'）.

`C-c RET'
     ポイントがあるところの入力コマンドをバッファの末尾にコピーする
     （`comint-copy-old-input'）.  このコマンドはポイントを古いシェル
     コマンドへ移動したときに役立つ.  シェルコマンドをコピーしたら,
     RETでそれを（シェルへ）送る.  必要ならシェルコマンドを修正してか
     ら送ってもよい.

ポイントをまえの入力箇所に移動してから`C-c RET'でコピーしても, `M-p'を
必要な回数使って履歴リストからまえのコマンドを持ってきたのと（バッファ
の内容が同じという意味で）同じ結果になります.  ただし, `C-c RET'はバッ
ファからテキストをコピーするので, シェルへ送ったあとでそれをバッファ上
で編集した場合には, 履歴リストにあるものとは異なることもあります.



File: emacs-ja, Node: History References, Next: Shell Options, Prev: Shell History Copying, Up: Shell History

シェル履歴の参照
................

cshやbashをはじめ多くのシェルは, `!'や`^'で始まる"履歴参照"の機能を提
供しています.  シェル（shell）モードでもこれらの指定を理解し, 履歴置換
を行えます.  履歴参照を入力してTABを打つと, 履歴リストから一致するシェ
ルコマンドを探し, 必要なら置換を行い, 履歴参照をその結果で置き換えます. 
たとえば, `mv'で始まるいちばん最近のシェルコマンドを持ってくるには`! m
v TAB'と打ちます.  必要ならシェルコマンドを編集し, RETと打ってシェルへ
送ります.

履歴参照は, シェルプロンプトのあとでのみ効果を持ちます.  変数
`shell-prompt-pattern'でシェルプロンプトと認識するものを指定します.
comintモード一般には, 変数`comint-promt-regexp'でプロンプトの探し方を
指定します.  シェル（shell）モードでは, `shell-prompt-pattern'を使って
`comint-prompt-regexp'のローカルな値を設定します.

シェル（shell）モードでは, シェルに送る際にバッファ内で履歴参照を展開
するようにも指定できます.  それには, 変数`compint-input-autoexpand'に
`input'を設定します.

SPCをコマンド`comint-magic-space'にバインドすれば, SPCで履歴展開が行え
るようになります.



File: emacs-ja, Node: Shell Options, Next: Remote Host, Prev: Shell History, Up: Shell

シェルモードのオプション
------------------------

変数`comint-scroll-to-bottom-on-input'が`nil'以外の場合には, 挿入およ
びヤンクコマンドは, 選択されているウィンドウを末尾までスクロールしてか
ら挿入します.

`comint-scroll-show-maximum-output'が`nil'以外の場合, 出力に伴うスクロー
ルでは, 最後の行ができるだけウィンドウのいちばん下にくるようにし, なる
べく多くの有用なテキストが見えるようにします（これは多くの端末のスクロー
ル動作の真似）.  デフォルトは`nil'です.

`comint-scroll-to-bottom-on-output'を設定すると, ポイントがどこにあろ
うと, 出力が到着するたびにバッファの末尾へポイントがジャンプするように
設定できます.  この変数の値が`this'であれば, ポイントは選択されたウィ
ンドウでジャンプします.  値が`all'であれば, comintバッファを表示してい
る各ウィンドウでポイントはジャンプします.  値が`other'であれば, カレン
トバッファを表示しているすべての選択されていないウィンドウでポイントは
ジャンプします.  デフォルトは`nil'ですから, ポイントはジャンプしません.

変数`comint-input-ignoredups'は, 連続する同一の入力を履歴に格納するか
どうかを制御します.  値が`nil'以外のときは, 直前の入力と同じ入力は履歴
に格納しません.  デフォルトは`nil'ですから, 直前と同じ入力でもすべて履
歴に格納します.

3つの変数でファイル名の補完をカスタマイズします.  変数
`comint-completion-addsuffix'は, ファイル名やディレクトリ名を補完する
とき, 名前を完全に補完できたことを示すために末尾に空白やスラッシュを挿
入するかどうかを指定します（`nil'以外のとき, 空白やスラッシュを挿入）.
`comint-completion-recexact'は, その値が`nil'以外の場合, Emacsの通常の
補完アルゴリズムで1文字も追加できないときにはTABで可能なもっとも短い補
完文字列を挿入するようにします.  `comint-completion-autolist'は, その
値が`nil'以外の場合, 補完が完全でないときに可能な補完候補の一覧を表示
することを指定します.

コマンド`comint-dynamic-complete-variable'は, Emacs中で設定されている
環境変数を用いて変数名の補完を行います.  ファイル名の補完を制御する上
述の変数群も変数名の補完を制御します.  このコマンドは, 通常, メニュー
バーから使えます.

コマンド補完は, 通常, 実行可能なファイルだけを対象とします.
`shell-command-execonly'を`nil'にすると, 実行可能でないファイルも対象
となります.

`pushd'の動作をカスタマイズできます.  引数が与えられないと`cd'と同様に
ふるまう（`shell-pushd-tohome'）, 数引数を指定すると`pop'ではなく巡回
する（`shell-pushd-dextract'）, ディレクトリスタックにないディレクトリ
だけをディレクトリスタックに加える（`shell-pushd-dunique'）を制御でき
ます.  これらの値は当然, 使っているシェルの動作と一致するように設定す
べきです.



File: emacs-ja, Node: Remote Host, Next: Emacs Server, Prev: Shell Options, Up: Shell

リモートホストのシェル
----------------------

Emacsには, 他のホストにログインしてEmacsバッファ経由で通信するコマンド
が2つあります.

`M-x telnet RET HOSTNAME RET'
     ホストHOSTNAMEにtelnet経由で接続する.
`M-x rlogin RET HOSTNAME RET'
     ホストHOSTNAMEにrlogin経由で接続する.

他のホストにtelnet経由で接続するには, `M-x telnet'を使います（telnetは
リモートログイン用のInternetの標準プロトコル）.  このコマンドは, 接続
先のホスト名を引数としてミニバッファで読みます.  いったん接続が確立す
ると, 他のホストとのやりとりはサブシェルとのやりとりと同様にして行えま
す.  通常のEmacsコマンドで入力を編集でき, RETで相手側に送信します.  相
手側からの出力は（同じ）Telnetバッファに挿入されます.

rlogin接続を行うには, `M-x rlogin'を使います.  rloginは本質的には
telnetプロトコルとよく似たリモートログイン用の通信プロトコルですが,
telnetとの互換性はなく, ある種のシステムでだけ使えます.  rloginの利点
は, 2つのマシン間で頻繁に通信する場合にユーザー名やパスワードを毎回打
ち込まないですむように設定できることと, 8ビットを透過的に使う接続が可
能なことです.  （Emacsでこれを行うには, rloginを開始するまえに
`rlogin-explicit-args'に`("-8")'を設定する. ）

`M-x rlogin'は, 相手側とFTP経由でファイルをやりとりするためにEmacsバッ
ファのデフォルトディレクトリを設定し（*Note File Names::）, シェル
（shell）モードと同様にカレントディレクトリを変更するシェルコマンドを
監視します.

rloginバッファでディレクトリを追跡する方法は2つあります.  リモートディ
レクトリ名`/HOST:DIR/'を使うか, ローカルファイル名を使います.  （後者
は『相手側のホスト』がローカルホストとファイルシステムを共有している場
合にのみ使える）.  コマンド`rlogin-directory-tracking-mode'を使って, 
これらの2つのモードを相互に切り替えられます.  引数なしではリモートディ
レクトリ名を使う状態にし, 正の数を引数にするとローカル名を使う状態にし
ます.  負の数を引数にするとディレクトリの追跡機能を止めます.



File: emacs-ja, Node: Emacs Server, Next: Hardcopy, Prev: Shell, Up: Top

Emacsをサーバーとして使う
=========================

`mail'を始めとする多くのプログラムは, 送信メッセージなどのテキストを編
集するためにユーザーが指定したエディタを起動します.  これらのプログラ
ムは, 習慣として, 環境変数`EDITOR'で指定されたエディタを起動します.
`EDITOR'に`emacs'を設定しておけばEmacsが起動しますが, 新たに別のEmacs
プロセスが開始されるので不便です.  というのは, 新しいEmacsプロセスは既
存のEmacsプロセスとバッファを共有しないからです.

EmacsクライアントとEmacsサーバーを用いて, `mail'などのプログラムが既存
のEmacsプロセスをエディタとして使うようにできます.  以下のようにします.

まずは準備です.  Emacsの中で関数`server-start'を呼び出します.  （個人
のファイル`.emacs'に式`(server-start)'を書いておけば, これを自動的に行
える. ）つぎに, Emacsの外で環境変数`EDITOR'に`emacsclient'を設定します. 
（プログラムによっては別の環境変数を使う.  たとえば, TeXに
`emacsclient'を使わせるには, 環境変数`TEXEDIT'に`emacsclient +%d %s'と
設定する. ）

こうすると, どのプログラムが`EDITOR'に指定されたプログラムをエディタと
して起動しても, 結果としては, 訪れるべきファイルを伝えるメッセージが現
在動いているEmacsに送られます.  （これが`emacsclient'の役割. ）Emacsは
ただちにバッファを表示し, ユーザーはすぐに編集を開始できます.

そのバッファの編集が終ったら, `C-x #'と打ちます（`server-edit'）.  こ
れにより, ファイルが保存され, 終了せよとのメッセージを`emacslient'に送
り返します.  `EDITOR'を参照したプログラムは『エディタ』（実際には
`emacsclient'）が終了するのを待ちます.  `C-x #'は複数のファイルに対す
る外部からの編集要求で他に残っているものがないかどうかも検査し, もしあ
ればつぎのファイルを訪問します.

望むなら手でサーバーバッファに切り替えてもかまいません.  必ず`C-x #'を
使わなければならないということはありません.  ただし, `C-x #'はサーバー
バッファの編集が終ったということを告げる唯一の方法です.

変数`server-window'にウィンドウやフレームを設定してあれば, `C-x #'はサー
バーバッファをそのウィンドウやフレームに表示します.

`mail'やその他のアプリケーションが`emacsclient'の終了を待っているあい
だ, `emacsclient'は端末入力を読みません.  したがって, `mail'が使ってい
る端末は, そのあいだ実質的にブロックされた状態にあります.  サーバーと
して使うEmacsで編集をするためには, その（ブロックしている）端末を使わ
ずに行う必要があります.  それには2つの方法があります.

   * ウィンドウシステムを使い, `mail'とEmacsとを別のウィンドウで動かす.
     `mail'が`emacsclient'を待っているあいだ, `mail'が動いてるウィンド
     ウはブロックされるが, 他のウィンドウに切り替えればEmacsを使える.

   * Emacsのシェル（shell）モードを使って`mail'などのプログラムを動か
     す.  こうすれば, `emacsclient'はEmacsの下で動いているサブシェルの
     みをブロックするので, Emacsを使ってファイルを編集するのは通常どお
     り行える.

プログラムによっては, エディタで編集するための作業ファイルを作成します. 
ユーザーが作業ファイルを編集し終ると, プログラムはそのファイルを読み込
んでから消去します.  Emacsサーバーがあとで同じ名前のファイルを編集する
ように告げられた場合, それはたまたまファイル名が一致しただけで, 内容は
まえのファイルと何ら関係ないものと考えなければなりません.  このため, 
サーバーはファイルを編集し終ると作業ファイルのバッファを削除します. 
変数`server-temp-file-regexp'を使って, どのようなファイルがここでいう
意味での作業ファイルであるか指定します.  この変数の値は, 作業ファイル
であるようなファイルの名前に一致する正規表現である必要があります.

オプション`--no-wait'を指定して`emacsclient'を起動すると, Emacs上でバッ
ファを編集し終るのを待たずにただちに終了します.



File: emacs-ja, Node: Hardcopy, Next: Postscript, Prev: Emacs Server, Up: Top

印刷
====

印刷用のEmacsコマンドには, バッファ全体ないしその一部を, ページヘッダ
付き／なしのどちらででも出力する機能があります.  dired（*Note Misc
File Ops::）とdiary（*Note Diary Commands::）の印刷機能についても参照
してください.

`M-x print-buffer'
     カレントバッファの内容を, ファイル名とページ番号を記したページヘッ
     ダ付きで印刷する.
`M-x lpr-buffer'
     カレントバッファの内容を, ページヘッダなしで印刷する.
`M-x print-region'
     `print-buffer'と同様だが, 現在のリージョンのみを印刷する.
`M-x lpr-region'
     `lpr-buffer'と同様だが, 現在のリージョンのみを印刷.

（Postscriptコマンドを除く）印刷コマンドは, `lpr-switches'の値をもとに
追加オプションを`lpr'に渡します.  この変数の値は文字列のリストであり, 
各文字列は`-'で始まるオプションである必要があります.  たとえば, Emacs
から行う印刷で1行を80文字に設定するには, `lpr-switches'をつぎのように
設定します.

     (setq lpr-switches '("-w80"))

変数`printer-name'を設定すれば, 使うプリンタを指定できます.

変数`lpr-command'は, 実行すべきプリンタプログラムを指定します.  デフォ
ルトの値はオペレーティングシステムに依存します.  多くのシステムでは, 
デフォルトは`"lpr"'です.  変数`lpr-headers-switches'も同様に, ページヘッ
ダを作るための追加オプションを指定します.  変数`lpr-add-switches'は, 
プリンタプログラムに（`lpr'には適した）オプション`-T'とオプション`-J'
を指定するかどうか制御します.  この変数の値が`nil'ならこれらのオプショ
ンを指定しません.  プリンタプログラムが`lpr'と互換性がないなら, 変数
`lpr-add-switches'は`nil'にすべきです.



File: emacs-ja, Node: Postscript, Next: Postscript Variables, Prev: Hardcopy, Up: Top

Postscriptの印刷
================

これらのコマンドは, バッファの内容をPostscriptに変換し, プリンタへ送る
か他のEmacsバッファに入れます.

`M-x ps-print-buffer'
     カレントバッファをPostscript形式で印刷する.
`M-x ps-print-region'
     現在のリージョンをPostscript形式で印刷する.
`M-x ps-print-buffer-with-faces'
     カレントバッファをPostscript形式で印刷するが, テキストで用いてい
     るフェイスをPostscriptの機能で表示する.
`M-x ps-print-region-with-faces'
     現在のリージョンをPostscript形式で印刷するが, テキストで用いてい
     るフェイスも表示する.
`M-x ps-spool-buffer'
     カレントバッファのテキストをPostscriptに変換する.
`M-x ps-spool-region'
     現在のリージョンをPostscriptに変換する.  カレントバッファを
     Postscriptに変換するが, 使われているフェイスも表示する.
`M-x ps-spool-region-with-faces'
     現在のリージョンをPostscriptに変換するが, 使われているフェイスも
     表示する.

Postscriptコマンド`ps-print-buffer'および`ps-print-region'はバッファの
内容をPostscript形式で出力します.  前者はバッファ全体を出力しますが, 
後者はリージョンのみです.  これらに対応した`-with-faces'コマンドである
`ps-print-buffer-with-faces'および`ps-print-region-with-faces'は, 出力
するテキストのテキスト属性のフェイス（フォントと表示色）をPostscriptの
機能を用いて再現します.

カラーディスプレイを使っている場合, バッファでフォントロック
（font-lock）モードを使って色付けしたプログラムコードを
`ps-print-buffer-with-faces'で（そのまま）印刷できます.

コマンド名が`print'のかわりに`spool'であるものは, 変換したPostscript出
力をプリンタに送るかわりにEmacsバッファに置きます.

つぎの節では, これらのコマンドをカスタマイズする変数について説明します.



File: emacs-ja, Node: Postscript Variables, Next: Sorting, Prev: Postscript, Up: Top

Postscriptの印刷を制御する変数
==============================

すべてのPostscriptの印刷コマンドは, 出力をどのように印刷するかを変数
`ps-lpr-command'と`ps-lpr-switches'で指定できます.  `ps-lpr-command'に
は印刷のため実行するシェルコマンド, `ps-lpr-switches'にはそのシェルコ
マンドに指定するオプション, `ps-printer-name'にはプリンタを指定します. 
始めの2つの変数を設定しなかった場合は, `lpr-command'と`lpr-switches'に
基づいて初期値が設定されます.  `ps-printer-name'が`nil'だと
`printer-name'を使います.

変数`ps-print-header'は, これらのコマンドが各ページにヘッダをつけるか
どうかを制御します.  `nil'だとヘッダを付けません.  `ps-print-color-p'
を`nil'にするとカラー処理を行いません.

変数`ps-paper-type'は, 印刷用紙サイズを指定します.  指定できる値は,
`a4', `a3', `a4small', `b4', `b5', `executive', `ledger', `legal',
`letter', `letter-small', `statement', `tabloid'です.  デフォルトは
`letter'です.  変数`ps-page-dimensions-database'を変更すれば別の用紙サ
イズを定義できます.

変数`ps-landscape-mode'は用紙の向きを指定します.  デフォルトは`nil'で, 
『縦づかい』（ポートレート）です.  `nil'以外の値を指定すると『横づかい』
（ランドスケープ）です.

変数`ps-number-of-columns'は段数を指定します.  縦づかいでも横づかいで
も有効で, デフォルトは1です.

変数`ps-font-family'は, 通常のテキストの印刷に使うフォントファミリを指
定します.  指定できる値は, `Courier', `Helvetica', `NewCenturySchlbk',
`Palatino', `Times'です.  変数`ps-font-size'は, 通常のテキスト印刷に使
うフォントのサイズを指定します.  デフォルトは8.5ポイント (1) (*Note
Postscript Variables-Footnotes::)です.

これらのコマンドには他にも多くのカスタマイズ可能な変数があり, それらは
Lispファイル`ps-print.el'で定義されています.


File: emacs-ja  Node: Postscript Variables-Footnotes, Up: Postscript Variables

(1) 【訳注】印刷機の長さの単位.  1ポイントは約1/72インチ（0.35mm）



File: emacs-ja, Node: Sorting, Next: Narrowing, Prev: Postscript Variables, Up: Top

テキストのソート
================

Emacsには, バッファ中のテキストをソートするコマンドがいくつかあります. 
すべてはリージョン（ポイントとマークのあいだのテキスト）に働きます. 
これらのコマンドは, リージョン中のテキストを多数の"ソートレコード"にわ
け, 各レコードについて"ソートキー"を識別し, 一連のレコードをソートキー
によって定まる順序に並べ替えます.  レコードはキーのアルファベット（辞
書）順にも, また数値に基づく数値順にも並べられます.  アルファベット順
の場合は, ASCII文字の順序に基づいてすべての大文字「A」〜「Z」は小文字
「a」よりまえにきます.

各種のソートコマンドの違いは, テキストをソートレコードに分ける方法と, 
各レコードのどの部分をソートキーに使うかです.  ほとんどのコマンドは各
行をソートレコードとして扱いますが, 段落やページをソートレコードとして
扱うコマンドもあります.  ほとんどのソートコマンドは各ソートレコード全
体をそれ自身のソートキーとして扱いますが, ソートレコードの一部分だけを
ソートキーとして扱うコマンドもあります.

`M-x sort-lines'
     リージョンを行の並びとみなし, 行全体のテキストを比較して（昇順に）
     ソートする.  数引数を指定すると降順にソートする.

`M-x sort-paragraphs'
     リージョンを段落の並びとみなし, （先頭の空行を除く）段落全体のテ
     キストを比較して（昇順に）ソートする.  数引数を指定すると降順にソー
     トする.

`M-x sort-pages'
     リージョンをページの並びとみなし, （先頭の空行を除く）ページ全体
     のテキストを比較して（昇順に）ソートする.  数引数を指定すると降順
     にソートする.

`M-x sort-fields'
     リージョンを行の並びとみなし, 行の1つの欄を比較して（昇順に）ソー
     トする.  欄は白文字で区切られる.  つまり, 行の始めにある白文字で
     ない文字の並びが第1欄, そのつぎの空白でない文字の並びが第2欄, と
     いうようになる.

     どの欄をキーとしてソートするかは, 1を指定すれば第1欄, というよう
     に数引数で指定する.  負の値を指定したときは左からでなく右から欄を
     数える.  つまり, -1は最後の欄でソートする.  複数の行において欄の
     値が同一の場合, バッファ上のもとの順序が保存される.

`M-x sort-numeric-fields'
     `M-x sort-fields'と同様だが, 指定した欄を行ごとに数値に変換し, そ
     の数値同士を比較する.  `10'はアルファベット順では`2'よりまえにく
     るが, 数値として見れば`2'よりあとにくる.

`M-x sort-columns'
     `M-x sort-fields'と同様だが, 行の比較に使うテキストは固定文字位置
     からとる.  以下の説明を参照のこと.

`M-x reverse-region'
     リージョン内の行の順番を逆にする.  欄や文字位置でソートするコマン
     ドは降順にはソートできないので, 昇順にソートしたあと降順に並べ替
     えるのに役立つ.

たとえば, バッファにつぎのような内容が入っていたとします.

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

バッファ全体に`M-x sort-lines'を適用すると, つぎのようになります.

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

ここで, `O'は大文字なのですべての小文字よりまえにきます.  上記のかわり
に`C-u 2 M-x sort-filelds'を使ったとすると, 結果はつぎのようになります.

     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

この例ではソートキーは, `Emacs', `If', `buffer', `systems', `the'だっ
たわけです.

`M-x sort-columns'には少々説明が必要です.  文字位置の範囲を指定するに
は, ポイントを文字位置の一方に, マークを他方の文字位置に置きます.  こ
のため, ポイントやマークをソートしたい最初の行の先頭に置くことができま
せんから, このコマンドでは変わった「リージョン」の定義を用います.  ポ
イントがある行全体はリージョンに含まれ, 同様に, マークがある行全体もリー
ジョンに含まれ, この2つの行のあいだにある行はすべてリージョンに含まれ
るとみなすのです.

たとえば, ある表を10文字目から15文字目までの情報をもとにソートする場合, 
表の最初の行の10文字目にマークを置き, 表の最後の行の15文字目にポイント
を置き, そして`sort-column'を実行します.  あるいは, マークを最初の行の
15文字目, ポイントを最後の行の10文字目に置いても同じことです.

これは, ポイントとマークで指定された矩形領域をソートするものと考えられ
ます.  ただし, 矩形領域の右側や左側にある各行のテキストも一緒に移動し
ます.

`sort-fold-case'が`nil'以外の場合, ソートコマンドのほとんどは比較に際
して大文字小文字を区別しません.



File: emacs-ja, Node: Narrowing, Next: Two-Column, Prev: Sorting, Up: Top

ナロイング
==========

"ナロイング"（narrowing）とは, バッファのある部分だけに焦点を当て, 残
りの部分を一時的に参照できなくすることです.  扱える部分のことを"参照可
能範囲"と呼びます.  ナロイングを取り消して, バッファ全体を参照できるよ
うに戻すことを"ワイドニング"（widening）と呼びます.

ナロイングすると, 他の部分に煩わされることなく, 1つのサブルーチンや段
落などに集中できます.  また, 置換コマンドやキーボードマクロの適用範囲
を制限するのにも利用できます.

`C-x n n'
     ポイントとマークのあいだにナロイングする（`narrow-to-region'）.
`C-x n w'
     再度バッファ全体を参照可能にする（`widen'）.
`C-x n p'
     現在のページにナロイングする（`narrow-to-page'）.
`C-x n d'
     現在の関数定義にナロイングする（`narrow-to-defun'）.

バッファの一部分へナロイングすると, その部分だけしかないように見えます. 
残りの部分は見えませんし, そこへポイントを移動することもできません（移
動コマンドは参照可能範囲から外へ出られない）し, 見えない部分はどのよう
にしても変更できません.  しかし, その部分がなくなったわけではないので, 
ファイルに保存すれば参照できないテキストも保存されます.  ナロイングし
ているあいだは, モード行に`Narrow'と表示されます.

主要なナロイングコマンドは`C-x n n'（`narrow-to-region'）です.  現在の
リージョンだけが参照可能で, その前後のテキストは参照できないようにカレ
ントバッファに制限を課します.  ポイントとマークは変化しません.

別のやり方として, `C-x n p'（`narrow-to-page'）は現在のページだけが見
えるようにナロイングします.  ページの定義については, *Note Pages::.
`C-x n d'（`narrow-to-defun'）はポイントを含む関数定義の範囲にナロイン
グします（*Note Defuns::）.

ナロイングを取り消すには, `C-x n w'でワイドニングします.  これによって
バッファ中の全テキストが再度参照可能になります.

バッファ中のどの部分にナロイングしているかは, コマンド`C-x ='で調べる
ことができます.  *Note Position Info::.

ナロイングは, それについて知らないユーザーを簡単に混乱させますので,
`narrow-to-region'は, 通常, 使用禁止コマンドになっています.  このコマ
ンドを使おうとすると, Emacsは確認を求めてきて, コマンドを使えるように
するかどうか問い合わせてきます.  コマンドを利用可能にすると, それ以後
は確認は必要なくなります.  *Note Disabling::.



