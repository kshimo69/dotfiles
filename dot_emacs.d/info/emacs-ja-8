Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja  Node: Nroff Mode-Footnotes, Up: Nroff Mode

(1) 【訳注】実際には`C-j'.



File: emacs-ja, Node: Formatted Text, Next: Programs, Prev: Nroff Mode, Up: Text

整形済みテキストの編集
======================

"エンリッチ（enriched）モード"は, ワープロのようにWYSIWYG方式で, 整形
済みテキストを含むファイルの編集を行うためのマイナモードです.  現在の
ところ, エンリッチ（enriched）モードの整形済みテキストには, フォント, 
表示色, 下線, 左右端, 詰め込みと幅揃えの種類を指定できます.  将来的に
は, その他の整形機能も実装しようと計画しています.

エンリッチ（enriched）モードはマイナモードです（*Note Minor Modes::）. 
通常は, テキスト（text）モードと一緒に使います（*Note Text Mode::）. 
しかしながら, アウトライン（outline）モードや段落字下げ型テキスト
（paragraph-indent-text）モードのような他のメジャーモードと一緒に使う
ことも可能です.

Emacsは能力的には整形済みテキストのファイルをさまざまなファイル形式で
格納することができす.  現在のところは, 1種類の形式のみ, つまり, MIMEプ
ロトコルで定義された"text/enriched"形式のみを実装してあります.  Emacs
がどのようにファイルの形式を識別し変換するかの詳細に関しては*Note ファ
イル書式変換: (elisp-ja)Format Conversion.。

Emacsの配布の中には, 実例として整形済みテキストファイル
`etc/enriched.doc'があります.  このファイルには, 本節で説明するすべて
の機能の実例が盛り込まれています.  また, 将来の拡張に関するアイデアも
述べてあります.

* Menu:

* Requesting Formatted Text::   Entering and exiting Enriched mode.
* Hard and Soft Newlines::      There are two different kinds of newlines.
* Editing Format Info::         How to edit text properties.
* Faces: Format Faces.          Bold, italic, underline, etc.
* Color: Format Colors.         Changing the color of text.
* Indent: Format Indentation.   Changing the left and right margins.
* Justification: Format Justification.
                                Centering, setting text flush with the 
                                  left or right margin, etc.
* Other: Format Properties.     The "special" text properties submenu.
* Forcing Enriched Mode::       How to force use of Enriched mode.



File: emacs-ja, Node: Requesting Formatted Text, Next: Hard and Soft Newlines, Prev: Formatted Text, Up: Formatted Text

整形済みテキストの編集
----------------------

text/enriched形式でEmacsが保存したファイルを訪れると, Emacsは自動的に
ファイル中の整形情報をEmacs自身の内部形式（テキスト属性）に変換し, エ
ンリッチ（enriched）モードをオンにします.

新たに整形済みテキストファイルを作成するには, まず, 存在しないファイル
を訪れてから, テキストを入力するまえに`M-x enriched-mode'と打ちます. 
このコマンドはエンリッチ（enriched）モードをオンにします.  入力される
テキストが正しく扱われることを保証するために, テキストを挿入するまえに
エンリッチ（enriched）モードをオンにしてください.

より一般的にいえば, コマンド`enriched-mode'は, エンリッチ（enriched）
モードがオフならオン, オンならオフにします.  数引数を指定すると, それ
が正であればエンリッチ（enriched）モードをオンにし, それ以外ではオフに
します.

エンリッチ（enriched）モードがオンのときにバッファを保存すると, Emacs
はテキストをファイルに書き出すときに自動的にtext/enriched形式へ変換し
ます.  ふたたびそのファイルを訪問すると, Emacsは自動的にその形式を認識
してテキストを変換し, エンリッチ（enriched）モードをオンにします.

通常, text/enriched形式のファイルを訪問すると, Emacsは各段落を指定され
た右端に納まるように詰め込みます.  この詰め込みをやめて時間を短縮する
ために, 変数`enriched-fill-after-visiting'に`nil'か`ask'を設定します.

しかし, エンリッチ（enriched）モードで保存したファイルを訪問するときに
は, Emacsは右端の設定をテキストと一緒に保存しているので, テキストを再
度詰め込む必要はありません.

通常はEmacsが保存しないテキスト属性に対する注記（annotation）も保存す
るようにするには, 変数`enriched-translations'に追加しておきます.
text/enriched規格では, 非標準の注記には, `x-read-only'のように`x-'で始
まる名前が必要なことに注目してください.  これによって, あとから追加さ
れる標準的な注記と名前が衝突しないことが保証されます.



File: emacs-ja, Node: Hard and Soft Newlines, Next: Editing Format Info, Prev: Requesting Formatted Text, Up: Formatted Text

ハード改行とソフト改行
----------------------

Emacsは整形済みテキスト中の改行を, "ハード"改行と"ソフト"改行の2種類に
区別します.

ハード改行は, 段落の区切り, リスト内の項目, 左右端に関係なく行分割がつ
ねに必要な箇所に用いられます.  RETコマンド（`newline'）と`C-o'
（`open-line'）はハード改行を挿入します.

ソフト改行は, テキストを左右端のあいだに納めるために使用されます.  自
動詰め込み（auto-fill）モードを含めたすべての詰め込みコマンドはソフト
改行を挿入し, ソフト改行だけを削除します.

ハード改行とソフト改行は見た目は同じですが, 違いを理解することは重要で
す.  詰め込んだ段落の途中で行に分割するときにRETを使ってはいけません. 
あとの詰め込みの妨げとなるハード改行を挿入してしまいます.  かわりに, 
自動詰め込み（auto-fill）モードに行分割を行わせて, テキストや左右端が
変化してもEmacsが適切に再度詰め込めるようにします.  *Note Auto Fill::.

一方, 表やリストのように, 入力したとおりの行にしておく必要がある場合に
は, RETで行を終えます.  これらの行では, 幅揃えのスタイルとして
`unfilled'を指定するのもよいかもしれません.  *Note Format
Justification::.



File: emacs-ja, Node: Editing Format Info, Next: Format Faces, Prev: Hard and Soft Newlines, Up: Formatted Text

整形情報の編集
--------------

整形済みテキストファイルの整形情報を変更するには, 2つの方法があります. 
キーボードコマンドを使うか, マウスを使います.

文書に属性を追加するもっとも簡単な方法は, Text Propertiesメニューを使
用することです.  このメニューを出すには2つの方法があります.  メニュー
バーのEditメニューから選択するか, `C-mouse-2'（CTRLキーを押し下げたま
まマウスの真中のボタンを押す）です.

Text Propertiesメニューのほとんどの項目には, 別のサブメニューがついて
います.  これらについては後述します.  コマンドを直接実行する項目もあり
ます.

`Remove Properties'
     Text Propertiesメニューで扱えるすべてのテキスト属性をリージョンか
     ら取り除く（`facemenu-remove-props'）.

`Remove All'
     *すべて*のテキスト属性をリージョンから取り除く
     （`facemenu-remove-all'）.

`List Properties'
     ポイント直後の文字のすべてのテキスト属性を表示する
     （`list-text-properties-at'）.

`Display Faces'
     定義済みフェイス一覧を表示する.

`Display Colors'
     定義済み表示色一覧を表示する.
            


File: emacs-ja, Node: Format Faces, Next: Format Colors, Prev: Editing Format Info, Up: Formatted Text

整形済みテキストのフェイス
--------------------------

Facesサブメニューには, `bold', `italic', `underline'といったEmacsで使
用できる各種フェイスが並んでいます.  その中から1つを選ぶと, リージョン
にフェイスを追加します.  *Note Faces::.  以下のキーボードコマンドでフェ
イスを指定することもできます.

`M-g d'
     リージョン, あるいは, つぎに挿入する文字のフェイスを`default'にす
     る（`facemenu-set-default'）.
`M-g b'
     リージョン, あるいは, つぎに挿入する文字のフェイスを`bold'にする
     （`facemenu-set-bold'）.
`M-g i'
     リージョン, あるいは, つぎに挿入する文字のフェイスを`italic'にす
     る（`facemenu-set-italic'）.
`M-g l'
     リージョン, あるいは, つぎに挿入する文字のフェイスを`bold-italic'
     にする（`facemenu-set-bold-italic'）.
`M-g u'
     リージョン, あるいは, つぎに挿入する文字のフェイスを`underline'に
     する（`facemenu-set-underline'）.
`M-g o FACE RET'
     リージョン, あるいは, つぎに挿入する文字のフェイスをFACEにする
     （`facemenu-set-face'）.

前置引数を指定してこれらのコマンドを使ったり, 暫定マーク
（transient-mark）モードでリージョンが選択されていなければ, これらのコ
マンドはつぎに入力する自己挿入文字だけに使うフェイスを指定します.
*Note Transient Mark::.  これはキーボードコマンドとメニューコマンドの
両方に通用します.

エンリッチ（enriched）モードには, `excerpt'と`fixed'の2つの追加フェイ
スが定義されています.  これらのフェイスは, text/enrichedファイル形式で
使用されるコードに対応しています.

`excerpt'フェイスは引用を表すためのものです.  カスタマイズしてなければ
`italic'と同じです（*Note Face Customization::）.

`fixed'フェイスは, 『この部分のテキストには固定幅フォントを使用する』
という意味です.  現在, Emacsは固定幅フォントにだけ対応しています.  し
たがって, `fixed'の注記は今のところ必要ありません.  しかしながら, 将来
のEmacsでは可変幅フォントに対応したり, 固定幅フォントをデフォルトとし
ないtext/enriched形式を表示可能な他のシステムを計画しています.  ですか
ら, 固定幅フォントをどうしても使いたい箇所には, その部分のテキストに
`fixed'を指定するべきです.

通常, `fixed'フェイスには, デフォルトと異なるフォントを使うように定義
されています.  ところが, システムごとにさまざまなフォントがありますか
ら, この定義をカスタマイズする必要があるかもしれません.

異なるフェイスを表示できない端末ではそれらの違いを目にすることはできま
せんが, それでも, さまざまなフェイスを含む文書の編集は行えます.  文書
にフェイスや表示色を追加することもできます.  それらを表示可能な端末で
見たときにフェイスや色を目にすることができます.



File: emacs-ja, Node: Format Colors, Next: Format Indentation, Prev: Format Faces, Up: Formatted Text

整形済みテキストの表示色
------------------------

テキストの部分ごとに前景色と背景色を指定できます.  前景色を指定するメ
ニューと背景色を指定するメニューがあります.  これらのメニューには, そ
のEmacsセッションのエンリッチ（enriched）モードで使っている表示色一覧
が表示されます.

前置引数とともに表示色を指定したり, 暫定マーク（transient-mark）モード
でリージョンが選択されていなければ, つぎに入力する自己挿入文字だけに作
用します.  *Note Transient Mark::.  そうでなければ, コマンドはリージョ
ンに作用します.

それぞれの表示色メニューにはもう1つ`Other'という項目があります.  この
項目は, メニューに表示されていない表示色を指定するために使います.  こ
れは, ミニバッファで表示色名称を読み取ります.  利用可能な表示色と名前
の一覧を表示するには, Text Propertiesメニューの`Display Colors'項目を
使います（*Note Editing Format Info::）.

このようにして指定した表示色や, 読み込んだ整形済みテキスト内で使われて
いる表示色は, そのEmacsセッション中は, 両方の表示色メニューに追加され
ます.

表示色を指定するためのキーバインディングはありませんが, 拡張コマンド
`M-x facemenu-set-foreground'や`M-x facemenu-set-background'を使えばで
きます.  どちらのコマンドもミニバッファで表示色名称を読み取ります.



File: emacs-ja, Node: Format Indentation, Next: Format Justification, Prev: Format Colors, Up: Formatted Text

整形済みテキストの字下げ
------------------------

整形済みテキストの編集では, 段落全体あるいは段落の一部に異なる左端と右
端の字下げを指定できます.  指定した左右端は, 自動的に詰め込みコマンド
（*Note Filling::）と行分割コマンドに反映されます

Indentationサブメニューは, これらの属性を指定するための便利なインター
フェイスです.  このサブメニューにはつぎの4つの項目があります.

`Indent More'
     リージョンを4桁分字下げする（`increase-left-margin'）.  エンリッ
     チ（enriched）モードでは, このコマンドは`C-x TAB'でも実行できる. 
     数引数を指定すると, 左端に加える桁数として扱う（負の値であれば桁
     を減らす）.

`Indent Less'
     リージョンから4桁分字下げを取り除く.

`Indent Right More'
     右端を4桁分字下げしてテキストの幅を狭める.

`Indent Right Less'
     右端から4桁分字下げを取り除く.

なお, これらのコマンドを繰り返せば, 字下げを増やしたり減らしたりできま
す.

これらのコマンドの一般的な使い方は, 段落全体の字下げを変更することです. 
しかし, それだけではありません.  任意の箇所で左右端を変更できます.  新
たに設定された値は, 行末（右端）やつぎの行の先頭（左端）に影響します.

それにより, "ぶら下がり字下げ"で段落を整形することができます.  ぶら下
がり字下げとは, 1行目の字下げ幅が2行目以降の字下げ幅より少ないものです. 
ぶら下がり字下げするには, 段落の最初の単語の直後から始まり段落の末尾ま
で続くリージョンの字下げ幅を増やします.

段落の1行目の字下げはもっと簡単です.  段落の本体があるべき位置に段落全
体に対する左右端を設定してから, 最初の行に追加の空白やタブを挿入すれば
よいのです.

編集の結果, 段落の詰め込みが汚くなってしまうことがあります.  たとえば, 
段落の一部が左端や右端からはみ出してしまうことです.  そうなったときに
は, `M-q'（`fill-paragraph'）を使って, 段落を詰め込み直します.

変数`standard-indent'は, これらのコマンドで増減する字下げ幅を指定しま
す.  デフォルト値は4です.  エンリッチ（Enriched）モード全体に対する右
端のデフォルトは, 通常どおり変数`fill-column'で制御します.

詰め込み接頭辞があれば, 指定した段落の字下げに追加されます.  `C-x .'は, 
詰め込み接頭辞として新たに指定された値には, 字下げの白文字を含めません. 
しかも, 詰め込みコマンドは各行の字下げのうしろにある詰め込み接頭辞を探
します.  *Note Fill Prefix::.



File: emacs-ja, Node: Format Justification, Next: Format Properties, Prev: Format Indentation, Up: Formatted Text

整形済みテキストの幅揃え
------------------------
            
整形済みテキストの編集では, 段落に対してさまざまなスタイルの揃え方を指
定できます.  指定したスタイルは自動的にEmacsの詰め込みコマンドに影響し
ます.

Justificationサブメニューは, スタイルを指定するための便利なインターフェ
イスです.  このサブメニューにはつぎの5項目があります.

`Flush Left'
     これは（少なくとも英語では）もっとも一般的な幅揃えスタイル.  行は
     左端に揃えられるが, 右側は不揃いのまま.

`Flush Right'
     右端に行を揃える.  必要に応じて左側に空白やタブを挿入して右側で行
     を揃える.

`Full'
     行ごとに左右両端を揃える.  このスタイルで揃えると空白を均等に挿入
     する.  印刷物では見栄えがたいへんよいが, 画面上の固定幅フォントで
     はそれほど美しくない.  たぶん, 将来のEmacsでは行内の空白量を調節
     できるようになり, エレガントな幅揃えが達成できるであろう.

`Center'
     各行を現在の左右端の中央に揃える.

`None' (1) (*Note Format Justification-Footnotes::)詰め込みをいっさい止める.  各行は入力したままになる.  つまり, こ
     の設定をしたテキストでは, 詰め込みコマンドも自動詰め込み機能も何
     の効果もない.  それでも, 左端を字下げすることは可能.  詰め込まな
     いリージョンでは, 改行はすべてハード改行として扱う（*Note Hard
     and Soft Newlines::）.

エンリッチ（enriched）モードでは, `M-j'プレフィックス文字を使ってキー
ボードで幅揃えを指定することもできます.

`M-j l'
     リージョンを左端揃えにする（`set-justification-left'）.
`M-j r'
     リージョンを右端揃えにする（`set-justification-right'）.
`M-j f'
     リージョンを左右端揃えにする（`set-justification-full'）.
`M-j c'
`M-S'
     リージョンを中央揃えにする（`set-justification-center'）.
`M-j u'
     リージョンでは詰め込まない（`set-justification-none'）.

揃え方のスタイルは段落全体に適用されます.  揃え方を変更するコマンドは, 
ポイントを含む段落に作用しますが, リージョンが設定されているときにはリー
ジョンと重なる段落すべてが対象になります.

揃え方のスタイルのデフォルトは, 変数`default-justification'で指定され
ます.  この値は, `left', `right', `full', `center', `none' (2) (*Note
Format Justification-Footnotes::) のいずれかのシンボルでなくてはいけま
せん.


File: emacs-ja  Node: Format Justification-Footnotes, Up: Format Justification

(1) 【訳注】メニューには`None'ではなく`Unfilled'が表示
される.

(2) 【訳注】詰め込まないことを指定するシンボルは
`none'. `Unfilled'ではない.
         


File: emacs-ja, Node: Format Properties, Next: Forcing Enriched Mode, Prev: Format Justification, Up: Formatted Text

他のテキスト属性の設定
----------------------

Other Propertiesメニュー (1) (*Note Format Properties-Footnotes::)には,
`read-only', `invisible', `intangible'といった有用なテキスト属性を追加／
削除する項目があります.  `intangible'属性はテキスト内にポイントを移動
できなくし, `invisible'属性はテキストを表示しないようにし, `read-only'
属性はテキストを変更できなくします.


これらの特別な属性には, リージョンに属性を付加するためのメニュー項目が
あります.  最後のメニュー項目`Remove Special'は, これらの特別な属性す
べてをリージョンから取り除きます.

現在のところ, `invisible'属性と`intangible'属性は, text/enriched形式に
保存され*ません*.  `read-only'属性は保存されますが, これは
text/enriched形式の標準的なものではないので, Emacs以外の他のエディタで
は使用されないかもしれません.


File: emacs-ja  Node: Format Properties-Footnotes, Up: Format Properties

(1) 【訳注】`Other Properties'ではなく, `Special Properties'
と表示される.



File: emacs-ja, Node: Forcing Enriched Mode, Next: Programs, Prev: Format Properties, Up: Formatted Text

エンリッチ（enriched）モードの強制
----------------------------------

普通は, Emacsは訪問したファイル内にある特別な注記を認識するので, 整形
済みテキストを編集中であることがわかります.  ところが, ファイルの内容
を変換するために特別な操作をしたり, 手動でエンリッチ（enriched）モード
をオンにする必要がある状況もあります.

   * 他のエディタで作成したtext/enriched形式のファイルを訪問すると,
     Emacsがそのファイルをtext/enriched形式であると認識しないかもしれ
     ない.  こういった場合, ファイルを訪れると, 整形済みテキストではな
     く整形コマンドを目にする.  `M-x format-decode-buffer'と打って形式
     を変換する.

   * ファイルを訪問したのではなく, バッファにファイルを*挿入*したとき.
     Emacsは挿入されたテキストに対しては必要な変換を行うが, エンリッチ
     （enriched）モードをオンにしない.  オンにしたければ, `M-x
     enriched-mode'と打つ.

コマンド`format-decode-buffer'は, さまざまな形式のテキストをEmacsの内
部形式に変換します.  このコマンドは, どの形式からの変換であるのかを尋
ねてきますが, 通常は単にRETを打てばEmacsが形式を推測します.

text/enriched形式のファイルをそのままの形, つまり, 整形済みテキストで
はなく文字列として見たいのであれば, `M-x find-file-literally'コマンド
を使います.  このコマンドは`find-file'のようにファイルを訪問しますが, 
形式変換を行いません.  文字コード変換（*Note Coding Systems::）と自動
展開（*Note Compressed Files::）も禁止します.  形式変換を禁止しても, 
適宜, 文字コード変換や自動展開を行わせたいのであれば, 適当な引数を指定
して`format-find-file'を使います.



File: emacs-ja, Node: Programs, Next: Building, Prev: Text, Up: Top

プログラムの編集
****************

Emacsには, LispやCといったプログラム言語の構文を理解するように設計され
たコマンドが数多くあります.  以下のことを行えます.

   * 釣り合った式や"S式"（*Note Lists::）を横断したりそれらをキルする.
   * トップレベルの式, つまり, Lispの"defun"やCの関数（*Note Defuns::）
     を横断したりそれらにマークを設定する.
   * 括弧の対応具合を表示する（*Note Matching::）.
   * コメントの挿入／キル／整列（*Note Comments::）.
   * 使用言語の慣用的な字下げを踏襲する（*Note Program Indent::）.

単語／文／段落を扱うコマンドは, 自然言語のテキストを編集するのが本来の
目的ですが, コードを編集する場合にもおおいに役立ちます.  なぜなら, た
いていのシンボルは単語ですし（*Note Words::）, 文は文字列やコメントの
中にも含まれるからです（*Note Sentences::）.  段落は本質的にはコードの
中には存在しませんが, プログラム言語向けのメジャーモードでは, 段落は空
行で始まり空行で終わると定義するので, 段落コマンドも役立ちます（*Note
Paragraphs::）.  空行をうまく使ってプログラムが整然と見えるようにする
と, 段落コマンドもうまく働きます.

選択的表示機能は, 関数の全体構成を眺めるのに便利です（*Note Selective
Display::）.  この機能は, 指定幅以内の字下げ幅の行だけを表示します.

* Menu:

* Program Modes::       Major modes for editing programs.
* Lists::	        Expressions with balanced parentheses.
* List Commands::       The commands for working with list and sexps.
* Defuns::	        Each program is made up of separate functions.
			  There are editing commands to operate on them.
* Program Indent::      Adjusting indentation to show the nesting.
* Matching::	        Insertion of a close-delimiter flashes matching open.
* Comments::	        Inserting, killing, and aligning comments.
* Balanced Editing::    Inserting two matching parentheses at once, etc.
* Symbol Completion::   Completion on symbol names of your program or language.
* Which Function::      Which Function mode shows which function you are in.
* Documentation::       Getting documentation of functions you plan to call.
* Change Log::	        Maintaining a change history for your program.
* Tags::	        Go direct to any function in your program in one
			  command.  Tags remembers which file it is in.
* Emerge::	        A convenient way of merging two versions of a program.
* C Modes::             Special commands of C, C++, Objective-C, 
                          Java, and Pike modes.
* Fortran::	        Fortran mode and its special features.
* Asm Mode::	        Asm mode and its special features.



File: emacs-ja, Node: Program Modes, Next: Lists, Prev: Programs, Up: Programs

プログラム言語向けメジャーモード
================================

Emacsには, Lisp, Scheme（Lispの方言の1つ）, Awk, C, C++, Fortran,
Icon, Java, Objective-C, Pascal, Perl, Pike, CORBA IDL, Tclといった各
種プログラム言語向けのメジャーモードがあります.  makefile用のメジャー
モード, makefileモードもあります.  Perl向けの別のモードとして, cperlモー
ドもあります.

理想的には, Emacsで編集する可能性のあるすべてのプログラム言語に対して, 
それぞれのメジャーモードを実装すべきです.  しかし, ある言語向けのモー
ドが, 構文的に類似した他の言語にも使えることがよくあります.  既存の言
語モード群は, 誰かがわざわざ書こうと決心したものです.

Lispモードにはいくつか変種がありますが, Lispを実行する際のインターフェ
イス方法が異なります.  *Note Executing Lisp::.

各プログラム言語向けメジャーモードでは, その言語の慣用的な字下げ方法を
理解し現在行をそのように字下げする関数を実行するようにTABキーを定義し
ます.  たとえば, Cモードでは, TABは`c-indent-line'にバインドされていま
す.  また, `C-j'は, RETに続けてTABを実行するように定義されています. 
つまり, モードに固有の字下げも行います.

多くのプログラム言語では, 行ごとに字下げ量が異なります.  そのため, そ
のような言語向けのメジャーモードでは, （コマンド
`backward-delete-char-untabify'を使って）タブ文字を等価な個数の空白と
同じに扱うようにDELを再定義しています.  その結果, 字下げが空白かタブの
どちらで構成されているのか気にせずに, 1度に1桁ずつ消去することが可能と
なります.  そのようなモードでは, ポイントの直前にあるタブ文字を削除す
るには`C-b C-d'を使います.

プログラム言語向けモードでは, 段落は空行で分割されると定義するので, 段
落コマンドも便利に使えます.  プログラム言語向けメジャーモードで自動詰
め込み（auto-fill）モードがオンのときには, 新たに行を作ると自動的に字
下げも行われます.

メジャーモードに入ると, "モードフック"（mode hook）と呼ばれるノーマル
フックが実行されます.  モードフックは, Lisp変数の値です.  各メジャーモー
ドにはモードフックがあり, フック名はつねにモードに入るためのコマンド名
に`-hook'を付加したものです.  たとえば, Cモードに入るとフック
`c-mode-hook'が実行され, Lispモードではフック`lisp-mode-hook'が実行さ
れます.  *Note Hooks::.



File: emacs-ja, Node: Lists, Next: List Commands, Prev: Program Modes, Up: Programs

リストとS式
===========

慣習として, 釣り合った式を扱うEmacsのキーは, 普通, コントロール・メタ
文字です.  これらは, コントロールやメタだけの対応したキーの機能に似せ
てあります.  これらは, プログラム言語の式だけに関係したコマンドだと考
えられがちですが, ある種の括弧が存在する（自然言語も含めた）任意の言語
に対しても有益なものです.

これらのコマンドは, 2つのグループに分けられます.  一方は（括弧でまとめ
た）"リスト"（list） (1) (*Note Lists-Footnotes::)だけを扱うもので, 丸
括弧, 角括弧, 中括弧（使用言語において対応が取れている必要がある括弧）
と, それらをクォートするエスケープ文字だけに注目するコマンド群です.


もう一方は, 式あるいは"S式"（sexp）を扱うコマンド群です.  「sexp」とい
う用語は, Lispの式を意味する古くからの用語"s-expression"に由来します.
Emacsでは「S式」の概念をLispに限定しません.  プログラムを記述した言語
が何であっても, その式をS式と呼びます.  各プログラム言語には独自のメ
ジャーモードがあり, そこでは, その言語の式をS式とみなすように構文テー
ブルを調整してあります.

一般にS式には, 丸括弧, 角括弧, 中括弧に囲まれた部分だけでなく, シンボ
ル, 数値, 文字列定数も含まれます.

Cのように前置演算子と中置演算子を使う言語では, すべての式をS式として扱
うことは不可能です.  たとえば, Cモードでは, `foo + bar'はCの式*です*が,
S式としては認識しません.  かわりに, `foo'と`bar'をそれぞれ1つのS式とし
て認識し, `+'はあいだにある句読点として認識します.  これは根本的に曖昧
なのです.  たとえば, ポイントが`f'にあるとき, 横断すべきS式としては,
`foo + bar'でも`foo'でも正当な選択肢です.  `(foo + bar)'は, Cモードに
おいて単一のS式であることに注意してください.

式の構文が曖昧なために, Emacsが正しく解釈できるようにしようなどとは誰
も思わない言語もあります.


File: emacs-ja  Node: Lists-Footnotes, Up: Lists

(1) 【訳注】ここでは, Lispの「リスト」ではなく, 単に括弧で括った一塊の
こと.



File: emacs-ja, Node: List Commands, Next: Defuns, Prev: Lists, Up: Programs

リストとS式に対するコマンド
===========================

`C-M-f'
     S式を横断して前向きに移動する（`forward-sexp'）.
`C-M-b'
     S式を横断して後向きに移動する（`backward-sexp'）.
`C-M-k'
     前向きにS式をキルする（`kill-sexp'）.
`C-M-DEL'
     後向きにS式をキルする（`backward-kill-sexp'）.
`C-M-u'
     リスト構造を1レベル上がって後向きに移動する（`backward-up-list'）.
`C-M-d'
     リスト構造を1レベル下がって前向きに移動する（`down-list'）.
`C-M-n'
     リストを横断して前向きに移動する（`forward-list'）.
`C-M-p'
     リストを横断して後向きに移動する（`backward-list'）.
`C-M-t'
     式を入れ替える（`transpose-sexps'）.
`C-M-@'
     つぎの式の直後にマークを設定する（`mark-sexp'）.

S式を横断して前向きに移動するには, `C-M-f'（`forward-sexp'）を使います. 
ポイントに続く最初の意味ある文字が開き区切り（Lisp では`(', Cでは`('や
`['や`{'）であれば, 対応する閉じ区切りのうしろに移動します.  シンボル, 
文字列, 数値を始める文字の場合には, それらを横断してその末尾に移動しま
す.

コマンド`C-M-b'（`backward-sexp'）は, S式を横断して後向きに移動します. 
移動の詳しい規則は上記の`C-M-f'と同様ですが, 方向は逆です.  S式のまえ
に接頭辞文字（Lispではシングルクォート, バッククォート, コンマ）がある
場合には, それらも横断します.  ほとんどのモードでは, S式コマンドはコメ
ントを空白であるかのように飛び越えます.

`C-M-f'や`C-M-b'に引数を指定すると, 指定された回数だけ動作を繰り返しま
す.  負の引数では, 逆向きに移動します.

1つのS式全体をキルするには, `C-M-k'（`kill-sexp'）や`C-M-DEL'
（`backward-kill-sexp'）で行います.  `C-M-k'は`C-M-f'で横断するだけの
文字をキルし, `C-M-DEL'は`C-M-b'で横断するだけの文字をキルします.

S式コマンドと同様に, "リストコマンド"はリストを横断しますが, リスト以
外のS式（シンボルや文字列など）は飛び越します.  これらのコマンドは,
`C-M-n'（`forward-list'）と`C-M-p'（`backward-list'）です.  これらのコ
マンドが便利である主な理由は, （コメントにはリストが何も含まれないのが
普通なので）コメントを無視するからです.

`C-M-n'と`C-M-p'は, 可能な限り同じレベルの括弧にとどまります.  1つ（あ
るいはNだけ）*上の*レベルに移動するには, `C-M-u'（`backward-up-list'）
を使います.  `C-M-u'は, 対応の取れていない開き区切りのまえへ後向きに移
動して, 1つレベルを上げます.  正の引数は反復回数になります.  負の引数
は, 移動を逆向きにしますが, やはり反復回数です.  つまり, 前向きに移動
して, 1つ以上レベルを上げます.

リスト構造中で*下*のレベルに移動するには, `C-M-d'（`down-list'）を使い
ます.  Lispモードでは, `('が唯一の開き区切りなので, このコマンドは`('
を探索するのとほとんど同じです.  引数は下がるべき括弧のレベルを指定し
ます.

本当は役に立つのに, 何の役に立つのだろうと思われるコマンドが`C-M-t'
（`transpose-sexps'）です.  これはポイントのまえにあるS式を, つぎにあ
るS式を越えて移動するコマンドです.  引数は反復回数となり, 負の引数では
後向きにS式を移動します（つまり正の引数を指定した`C-M-t'の効果を打ち消
せる）.  引数が0の場合は, 何もしないのではなくて, ポイントのあとにある
S式とマークのあとにあるS式を入れ替えます.

バッファ内でつぎにあるS式の周りにリージョンを設定するには, `C-M-@'
（`mark-sexp'）を使います.  このコマンドは, `C-M-f'による移動先にマー
クを設定します.  `C-M-@'は, `C-M-f'と同様に引数を取ります.  とりわけ, 
負の引数は, 直前のS式の先頭にマークを設定するのに便利です.

リストおよびS式コマンドが行う構文の解釈は, 構文テーブルに完全に支配さ
れます.  たとえば, 任意の文字を開き区切りとして宣言できて, そうすると
開き括弧のようにふるまうようになります.  *Note Syntax::.



File: emacs-ja, Node: Defuns, Next: Program Indent, Prev: List Commands, Up: Programs

関数定義（defun）
=================

Emacsでは, トップレベルの括弧でグループ化したものは"関数定義"（defun）
と呼ばれます.  この名前は, Lispファイルではトップレベルにあるリストの
大半がスペシャルフォーム`defun'であるという事実に由来します.  しかし, 
その中身が何であろうとも, また, 使用プログラム言語が何であろうとも,
Emacs流には, トップレベルの括弧でグループ化されたものはすべて関数定義
（defun）です.  たとえば, Cの関数定義の本体は関数定義（defun）です.

`C-M-a'
     現在の関数定義, あるいは, 直前の関数定義の先頭に移動する
     （`beginning-of-defun'）.
`C-M-e'
     現在の関数定義, あるいは, つぎの関数定義の末尾に移動する
     （`end-of-defun'）.
`C-M-h'
     現在の関数定義, あるいは, つぎの関数定義を囲むリージョンを設定す
     る（`mark-defun'）.

現在の関数定義の先頭や末尾に移動するコマンドは, `C-M-a'
（`beginning-of-defun'）と`C-M-e'（`end-of-defun'）です.

現在の関数定義を操作したいのであれば, `C-M-h'（`mark-defun'）を使って, 
現在の関数定義かつぎの関数定義の先頭にポイントを置き, その末尾にマーク
を設定します.  たとえば, 関数定義をテキストの別の位置に移動する準備を
するには, このコマンドを使うのがもっとも簡単な方法です.  Cモードでは,
`C-M-h'は`c-mark-function'を実行しますが, `mark-defun'とほとんど同じで
す.  違いは, 引数宣言, 関数名, 戻り値の型名と遡って, Cの関数全体をリー
ジョンに含めることです.  *Note Marking Objects::.

Emacsは, もっとも左の桁でみつけた任意の開き括弧を関数定義の始まりであ
ると仮定します.  したがって, *トップレベルのリストの始まりでない限り,
Lispファイルの中では左端に開き括弧を置いてはいけません.  また, 関数本
体の始まりを表すのでない限り, Cのコードの行頭に開き中括弧や開き区切り
を置いてはいけません. * もっとも起こりやすい場面は, 文字列の途中で, 行
頭に開き区切りを入れたい場合です.  トラブルを避けるために, 開き区切り
のまえにエスケープ文字（CやEmacs Lispでは `\', その他のLisp方言のいく
つかでは`/'）を入れてください.  これで文字列の内容が影響を受けることは
ありません.

大昔のもともとのEmacsでは, 関数定義を探すために, より上位レベルの括弧
がなくなるまで遡っていました.  この方法では, たとえ小さな関数であって
も, バッファの先頭まで遡って走査することがつねに必要でした.  これを高
速化するために, 左端内の任意の`(' （あるいは, 開き区切りと宣言された任
意の文字）が関数定義の始まりであると仮定するように, Emacsを変更しまし
た.  この発見的手法で, ほとんど正しく処理できて, 時間のかかる走査を回
避できます.  しかし, 上述の約束事は必要です.



File: emacs-ja, Node: Program Indent, Next: Matching, Prev: Defuns, Up: Programs

プログラムの字下げ
==================

正しく字下げされた状態にプログラムを保つ最良の方法は, 変更したらEmacs
に字下げをやり直させることです.  Emacsには, 1行の字下げ, 指定された行
数の字下げ, あるいは, 括弧でグループ化した内部のすべての行の字下げを行
うコマンドがあります.

* Menu:

* Basic Indent::	Indenting a single line.
* Multi-line Indent::   Commands to reindent many lines at once.
* Lisp Indent::		Specifying how each Lisp function should be indented.
* C Indent::		Extra features for indenting C and related modes.
* Custom C Indent::	Controlling indentation style for C and related modes.

Emacsでは, ライブラリ`pp'にLispのプリティプリンタ (1) (*Note Program
Indent-Footnotes::) もあります.  このプログラムは, 美しく見えるように
字下げを施してLispオブジェクトを清書するプログラムです.


File: emacs-ja  Node: Program Indent-Footnotes, Up: Program Indent

(1) 【訳注】プログラムのソースコードを美しく清書するプログラムを一般に
プリティプリンタ（pretty-printer）と呼ぶ.



File: emacs-ja, Node: Basic Indent, Next: Multi-line Indent, Prev: Program Indent, Up: Program Indent

プログラムの字下げ基本コマンド
------------------------------

`TAB'
     現在行の字下げを調整する.
`C-j'
     RETに続けてTABと打鍵するのと同じ（`newline-and-indent'）.

基本的な字下げコマンドはTABです.  直前の数行から判断した正しい字下げを
現在行に施します.  TABが実行する関数は, メジャーモードに依存します. 
たとえば, Lispモードでは`lisp-indent-line', Cモードでは`c-indent-line'
が実行されます.  これらの関数はそれぞれの言語の構文を解釈しますが, ど
れも同じことを行うためのものです.  プログラム言語向けメジャーモードに
おいては, TABは, 現在行のどこにポイントがあっても, 現在行の先頭に白文
字を挿入したり削除したりします.  ポイントが行頭の白文字の中にあったと
きは, TABは最後の白文字のうしろにポイントを置きます.  そうでなければ,
TABを打ったときの文字のところに留まります.

ポイント位置にタブを挿入するには, `C-q TAB'を使います.

新たにソースコード行を入力するときには, `C-j'（`newline-and-indent'）
を使ってください.  これは, RETに続けてTABを打鍵することと等価です.
`C-j'は, 空行を作ってから, その行で適切な字下げを行います.

括弧でグループにまとめたところでは, TABは, 2行目以降の行をそれぞれ直前
の行の真下にくるように字下げします.  したがって, ある行を非標準的な字
下げにすると, 以降の行もその字下げに従うことになります.  TABによる標準
的な字下げが, 特定の行では美しくないので無視したい場合には, 字下げのこ
のようなふるまいが便利です.

（字下げ処理を含めて）Emacsは, 左端にある, 開き丸括弧, 開き中括弧, お
よび, その他の開き区切りを関数の始まりと仮定することを覚えておきましょ
う.  たとえ文字列の中であっても, 関数の始まりでない開き区切りをけっし
て0桁目に置いてはいけません.  この制約は字下げコマンドを高速にするため
にきわめて重要です.  無条件で受け入れてください.  これに関してより詳し
くは, *Note Defuns::.



File: emacs-ja, Node: Multi-line Indent, Next: Lisp Indent, Prev: Basic Indent, Up: Program Indent

複数行の字下げ
--------------

変更した複数行や, リスト構造中の異なるレベル箇所へ移した複数の行を字下
げし直すには, いくつかのコマンドを利用できます.

`C-M-q'
     リスト内のすべての行を字下げし直す（`indent-sexp'）.
`C-u TAB'
     リストの最初の行が正しい字下げ位置にくるように, リストのすべての
     行を横にそのまま動かす.
`C-M-\'
     リージョン内のすべての行を字下げし直す（`indent-region'）.

1つのリストの中身を字下げし直すには, リストの始まり位置にポイントを置
いて`C-M-q'（Lispモードでは`indent-sexp', Cモードでは`c-indent-exp', 
他のモードでは適切なコマンドにバインドされている）と打ちます.  S式が始
まる行の字下げは変化しません.  つまり, リスト内の相対的な字下げが変化
するだけで, リストの位置は変わりません.  リストの開始位置も直すには,
`C-M-q'のまえにTABを打ってください.

リスト内の相対的な字下げは正しいけれども, リストの開始行の字下げが正し
くない場合には, その行に移動して`C-u TAB'と打ちます.  TABに数引数を指
定すると, 通常どおり現在行を字下げしてから, その行から始まるリスト内の
すべての行にも同じ量の字下げを加えます.  いいかえれば, グループ全体を
ひとまとめに字下げし直します.  ただし, このコマンドは賢くて, 文字列の
中の行は移動しませんし, Cモードではプリプロセッサ行を移動しません.

字下げし直す範囲を指定するには, リージョンを使うこともできます.  コマ
ンド`C-M-\'（`indent-region'）は, ポイントとマークのあいだに行の先頭文
字が含まれるすべての行についてTABを実行します.



File: emacs-ja, Node: Lisp Indent, Next: C Indent, Prev: Multi-line Indent, Up: Program Indent

Lispの字下げのカスタマイズ
--------------------------

Lisp式に対する字下げの仕方を, その式から呼ばれる関数と関係付けることが
できます.  各Lisp関数に対して, あらかじめ定義された字下げパターンの中
から選んだり, Lispプログラムで任意のものを定義したりできます.

字下げの標準パターンは, つぎのとおりです.  式の開始行に関数呼び出しの
引数がある場合は, 最初の引数の直下に2行目がくるように字下げします.  そ
れ以外の場合は, 関数名の直下に2行目がくるように字下げします.  続く各行
は, 入れ子の深さが同じである行の字下げと同じになります.

変数`lisp-indent-offset'が`nil'以外ならば, 式の2行目に対する通常の字下
げパターンを無効にして, 式の開始桁からつねに`lisp-indent-offset'だけ字
下げします.

標準パターンが使用されない関数もいくつかあります.  名前が`def'で始まる
関数に対しては, 式を開始する開き括弧の桁位置に`lisp-body-indent'を加え
た桁位置へ2行目がくるように字下げします.

関数名の属性`lisp-indent-function'を変更すれば, 各関数ごとに標準パター
ン以外の字下げを施せます.  この属性が取りえる値にはつぎの4つがあります.

`nil'
     属性がないのと同じ. 標準の字下げパターンを使用する.
`defun'
     名前が`def'で始まる関数に用いる字下げパターンを使用する.
数値 NUMBER
     関数の最初のNUMBER個の引数を"区別された"引数と呼び, 残りを式の"本
     体"と呼ぶ.  行の最初の引数が区別された引数かどうかによって, 各行
     の字下げが異なる.  引数が本体の一部ならば, それを含んだ式を開始す
     る開き括弧の桁位置に`lisp-body-indent'を加えた桁位置へ字下げする. 
     引数が区別された引数で最初か2番目ならば, `lisp-body-indent'の*2倍
     *を加えた桁位置へ字下げする.  引数が区別された引数であっても3番目
     以降ならば, 標準パターンを適用する.
シンボルSYMBOL
     SYMBOLは関数名であること.  この関数は, 当該式の字下げ幅を計算する. 
     この関数はつぎの2つの引数を受け取る.  STATE 当該行の先頭までを解
     析したときの`parse-partial-sexp' （字下げと入れ子の計算を行うLisp
     の基本的な関数）の戻り値.  POS 字下げ対象の行の開始位置.  この関
     数は, 当該行に対する字下げ幅の桁数, あるいは, リストのcarがそのよ
     うな数値であるリストを返す必要がある.  数値を返した場合は, 括弧の
     入れ子レベルが同じ行に対しては同じ字下げ幅を意味する.  リストを返
     した場合は, 後続の行に対しては字下げ幅が異なる可能性を意味する. 
     このような差異は, `C-M-q'で字下げを計算するときに現れる.  数値が
     返された場合, `C-M-q'は, リストの末尾に達するまでは, 字下げの再計
     算を行う必要がない.



File: emacs-ja, Node: C Indent, Next: Custom C Indent, Prev: Lisp Indent, Up: Program Indent

Cの字下げコマンド
-----------------

ここでは, Cモードとその関連モードにおける字下げコマンドを紹介します.

`C-c C-q'
     現在のトップレベルの関数定義, あるいは, 型宣言の集まりを字下げし
     直す（`c-indent-defun'）.

`C-M-q'
     ポイントのうしろにある釣り合った式の中の各行を字下げし直す
     （`c-indent-exp'）.  前置引数を指定すると, 不正な構文に対する検査
     をせずに, 警告メッセージも発しない.

`TAB'
     現在行を字下げし直すか, タブ文字を挿入する（`c-indent-command'）.

     `c-tab-always-indent'が`t'ならば, 現在行を字下げし直すだけで, 他
     には何もしない.  これがデフォルト.

     この変数が`nil'ならば, ポイントが左端か字下げの余白部分にある場合
     に限り, 字下げし直す.  さもなければ, タブ（あるいは,
     `indent-tabs-mode'が`nil'ならば, 等価な個数の空白）を挿入する.

     上記の（`nil'や`t'）以外の値であれば, 通常どおり字下げし直す.  た
     だし, コメント, 文字列, プリプロセッサ指令の内側では, タブを挿入
     する.

`C-u TAB'
     現在行の構文に従って現在行を字下げし直す.  なお, 現在行から始まる
     式を構成する行も同じ幅だけ字下げし直す.  *Note Multi-line
     Indent::.

カレントバッファ全体を字下げし直すには, `C-x h C-M-\'と打ちます.  これ
は, まず, バッファ全体をリージョンとしてから, そのリージョンを字下げし
直します.

カレントブロックを字下げし直すには, `C-M-u C-M-q'と打ちます.  これは, 
まず, ブロックの先頭に移動してから, ブロック全体を字下げし直します.



File: emacs-ja, Node: Custom C Indent, Next: Matching, Prev: C Indent, Up: Program Indent

Cの字下げのカスタマイズ
-----------------------

Cモードとその関連モードでは, 字下げのカスタマイズには, 単純ですが柔軟
性のある機構を用いています.  この機構は2段階で動作します.  まず, 行を
その内容と文脈から構文的に分類します.  つぎに, 構文構成要素の各種類に, 
カスタマイズ可能な字下げのオフセットを対応させます.

* Menu:

* Syntactic Analysis::
* Indentation Calculation::
* Changing Indent Style::
* Syntactic Symbols::
* Variables for C Indent::
* C Indent Styles::



File: emacs-ja, Node: Syntactic Analysis, Next: Indentation Calculation, Prev: Custom C Indent, Up: Custom C Indent

第1段階−−構文解析
...................

第1段階では, Cの字下げ機構は, 字下げしようとしているまえの行を調べて, 
その行を構成する構文上の構成要素を決定します.  つまり, "構文シンボル"
とバッファ内の相対位置を要素とする構文構成要素のリストを組み立てます. 
構文シンボルには, `statement'（文）や`substatement'（部分文）のように
文法要素を記述するものと, `class-open'（クラス開始）や`knr-argdecl'
（K&R版引数宣言）のように文法要素のあいだの位置を記述するものがありま
す.

概念的には, Cのコード行は, バッファ中でそれよりまえにあるいずれかの行
に対して必ず相対的に字下げされます.  これは構文構成要素リストの中にあ
るバッファ内位置として表現されます.

以下に例を示します.  つぎのコードが, C++モードのバッファに入っていると
しましょう（実際にバッファに行番号が表示されるわけではない）.

     1: void swap (int& a, int& b)
     2: {
     3:   int tmp = a;
     4:   a = b;
     5:   b = tmp;
     6: }

4行目で（`c-show-syntactic-information'を実行する）`C-c C-s'を打つと, 
その行に対する字下げ機構の結果が表示されます.

     ((statement . 32))

これは, その行が文であり, バッファ内位置32に対して相対的に字下げされて
いることを示します.  バッファ内位置32は, 3行目の`int'の`i'にあたります. 
カーソルを3行目に動かして`C-c C-s'と打つと, 今度はつぎのように表示され
ます.

     ((defun-block-intro . 28))

この結果は, `int'行がブロックの最初の文であり, バッファ内位置28に対し
て相対的に字下げされていることを示しています.  バッファ内位置28は, 関
数ヘッダの直後の中括弧にあたります.

別の例を見てみましょう.

     1: int add (int val, int incr, int doit)
     2: {
     3:   if (doit)
     4:     {
     5:       return (val + incr);
     6:     }
     7:   return (val);
     8: }

4行目で`C-c C-s'と打つと, つぎのように表示されます.

     ((substatement-open . 43))

これは, 中括弧が部分文のブロックを*始めて*いることを示しています.  と
ころで, "部分文"とは, `if', `else', `while', `do', `switch', `for',
`try', `catch', `finally', `synchronized'のあとの行を表します.

Cの字下げコマンドにおいては, 字下げのために行を構文解析し終えると, 変
数`c-syntactic-context'には解析結果を表すリストが入ります.  このリスト
の各要素は"構文構成要素"であり, 構文シンボルと（省かれるかもしれない）
対応するバッファ内位置のコンスセルです.  構文構成要素リストには, 複数
の要素が含まれることもあります.  また, 典型的には, バッファ内位置を持
つ要素は1つだけです.



File: emacs-ja, Node: Indentation Calculation, Next: Changing Indent Style, Prev: Syntactic Analysis, Up: Custom C Indent

第2段階−−字下げ計算
.....................

Cの字下げ機構は, 構文解析で得られた構文構成要素リスト
`c-syntactic-context'を使って, 現在行の字下げ幅を計算します.  このリス
トの各要素は, 構文シンボルを含むコンスセルですが, バッファ内位置を含ん
でいる場合もあります.

リストの各要素は, 最終的な総字下げ量に2つの方法で寄与します.  まず, 各
構文シンボルに字下げオフセットを対応付ける連想リスト`c-offsets-alist'
から要素を探すために構文シンボルが使われます.  各構文構成シンボルのオ
フセットを総字下げ量に加えます.  つぎに, リストの要素にバッファ内位置
が含まれていれば, その箇所の桁位置を字下げ量に加えます.  これらのオフ
セットと桁数をすべて加えることで, 総字下げ量が求まります.

以下の例でCの字下げ機構の動作を説明しましょう.

     1: void swap (int& a, int& b)
     2: {
     3:   int tmp = a;
     4:   a = b;
     5:   b = tmp;
     6: }

3行目にポイントがあって, そこでTABと打って字下げし直すとしましょう. 
上（*Note Syntactic Analysis::）でも説明しましたが, その行に対する構文
構成要素リストはつぎのようになります.

     ((defun-block-intro . 28))

ここでは, まず, 連想リスト`c-offsets-alist'から`defun-block-intro'を探
すことから始めます.  その結果が整数値2であったとしましょう.  この値を
計算中の合計（0で初期化されている）に加えて, 総字下げ量は空白2文字と更
新されます.

つぎの段階は, バッファ内位置28の桁位置を求めることです.  バッファ内位
置28の中括弧は0桁目にあるので, 0を計算中の合計に加えます.  3行目には構
文要素が1つしかないので, 総字下げ量は空白2文字となります.

     1: int add (int val, int incr, int doit)
     2: {
     3:   if (doit)
     4:     {
     5:       return(val + incr);
     6:     }
     7:   return(val);
     8: }

4行目でTABと打つと, 同じ過程を繰り返しますが, 異なる値を使って計算され
ます.  この行に対する構文構成要素リストはつぎのとおりです.

     ((substatement-open . 43))

まずは, シンボル`substatement-open'を連想リスト`c-offsets-alist'から探
します.  このシンボルに対するオフセットが2であったとしましょう.  この
時点で計算中の合計は2（0 + 2 = 2）です.  つぎに, バッファ内位置43（3行
目の`if'の`i'の位置）の桁位置2を加えます.  結果として, 空白4文字という
総字下げ量が求まります.

行を解析した結果, `c-offsets-alist'に現れない構文シンボルがみつかった
場合, そのシンボルは無視します.  しかし, 変数`c-strict-syntax-p'が
`nil'以外の値であれば, エラーを報告します.



File: emacs-ja, Node: Changing Indent Style, Next: Syntactic Symbols, Prev: Indentation Calculation, Up: Custom C Indent

字下げスタイルの変更
....................

C流のモードの字下げをカスタマイズする方法は2つあります.  1つは, あらか
じめ定義されているスタイルから選択する方法です.  それぞれのスタイルで
は, 各構文シンボルに対するオフセットが定められています.  もう1つはより
柔軟な方法で, 各構文シンボルの扱い方をカスタマイズできます.  定義され
ている構文シンボルの一覧については, *Note Syntactic Symbols::.

`M-x c-set-style RET STYLE RET'
     あらかじめ定義されている字下げスタイルSTYLEを選択する.  STYLEを入
     力する際に`?'と打てば, 定義済みのスタイル一覧を見ることができる. 
     スタイルの見栄えを調べるには, そのスタイルを選択して, 適当なCのコー
     ドを字下げし直してみる.

`C-c C-o SYMBOL RET OFFSET RET'
     構文シンボルSYMBOLに対する字下げのオフセットを設定する
     （`c-set-offset'）.  2番目の引数OFFSETで, 字下げのオフセットを指
     定する.

変数`c-offsets-alist'は, 各構文シンボルに与える字下げ量を制御します. 
この変数の値は連想リストであり, 各要素は`(SYNTACTIC-SYMBOL . OFFSET)'
の形をしています.  さまざまな構文シンボルに対するオフセットを変えるこ
とで, 字下げを細かくカスタマイズできます.  連想リストを変更するには,
`c-set-offset'を使います（下記参照）.

`c-offsets-alist'内の各オフセットには, 整数, 関数名や変数名, あるいは, 
変数`c-basic-offset'の値の正負の倍数を表すシンボルである`+', `-',
`++', `--', `*', `/'のいずれかを設定できます.  したがって, 基本の字下
げ幅を空白2文字から3文字に変更したければ, `c-basic-offset'に3を設定し
ます.

オフセットに関数を用いると, 字下げのカスタマイズに究極の柔軟性を持たせ
られます.  この関数は, 構文シンボルとバッファ内位置があればそれを
`cons'したものを引数として呼ばれます.  戻り値としては, 整数値のオフセッ
トを返す必要があります.
  
オフセットの値がリストの場合, 各要素は, `nil'以外の値がみつかるまで上
の規則にしたがって処理されます.  その後, その値は, 通常のように, 字下
げの総量に加えられます.  これは, 主に, 複数の関数の結果を組み合わせる
ために使われます.

対話的に設定するにしてもファイル`~/.emacs'で設定するにしても, オフセッ
トを設定するもっとも簡単な方法は, コマンド`C-c C-o'（`c-set-offset'）
を使うことです.  最初の引数は構文シンボル, 2番目の引数は希望のオフセッ
トです.  有効な構文シンボル名とその意味の一覧は, *Note Syntactic
Symbols::.



File: emacs-ja, Node: Syntactic Symbols, Next: Variables for C Indent, Prev: Changing Indent Style, Up: Custom C Indent

構文シンボル
............

Cモードや関連するモードの字下げに対して有効な構文シンボルを, 構文上の
意味とともに, 以下に示します.  これらのほとんどのシンボルには,
`c-offsets-alist'でオフセットが与えられています.

`string'
     複数行におよぶ文字列の内側.

`c'
     複数行におよぶCスタイルのブロックコメントの内側.

`defun-open'
     関数定義を開始する中括弧.

`defun-close'
     関数定義を終了する中括弧.

`defun-block-intro'
     トップレベルの関数定義の最初の行.

`class-open'
     クラス定義を開始する中括弧.

`class-close'
     クラス定義を終了する中括弧.

`inline-open'
     クラス内のインラインメソッドを開始する中括弧.

`inline-close'
     クラス内のインラインメソッドを終了する中括弧.

`extern-lang-open'
     外部言語ブロックを開始する中括弧.

`extern-lang-close'
     外部言語ブロックを終了する中括弧.

`func-decl-cont'
     関数定義の引数リストと関数定義の本体を開始する中括弧のあいだの領
     域.  ただし, K&R版の関数定義を除く.  Cでは, この部分に空文字やコ
     メント以外は置けない.  C++やJavaでは, `throws'宣言などを置ける.

`knr-argdecl-intro'
     K&R版Cの引数宣言の最初の行.

`knr-argdecl'
     K&R版Cの引数宣言の2行目以降.

`topmost-intro'
     最上位の言語構成要素の最初の行.

`topmost-intro-cont'
     最上位の言語構成要素の2行目以降.

`member-init-intro'
     （構造体の）メンバ初期化リストの最初の行.

`member-init-cont'
     （構造体の）メンバ初期化リストの2行目以降.

`inher-intro'
     多重継承リストの最初.

`inher-cont'
     多重継承リストの2行目以降.

`block-open'
     文ブロックを開始する中括弧.

`block-close'
     文ブロックを終了する中括弧.

`brace-list-open'
     `enum'のリストや静的配列の初期化リストを開始する中括弧.

`brace-list-close'
     `enum'のリストや静的配列の初期化リストを終了する中括弧.

`brace-list-intro'
     `enum'のリストや静的配列の初期化リストの最初の行.

`brace-list-entry'
     `enum'のリストや静的配列の初期化リストの2行目以降.

`brace-entry-open'
     行が開き中括弧で始まるときの, `enum'のリストや静的配列の初期化リ
     ストの2行目以降.

`statement'
     通常の文.

`statement-cont'
     文の継続行.

`statement-block-intro'
     新規文ブロックの最初の行.

`statement-case-intro'
     `case'ブロックの最初の行.

`statement-case-open'
     中括弧で始まる`case'ブロックの最初の行.

`inexpr-statement'
     式の内側にある文ブロック.  これは, C言語のGNU拡張や, 文ブロックを
     引数としてとるPikeの特殊関数に用いる.

`inexpr-class'
     式の内側にあるクラス定義.  これは, Javaの無名クラスや無名配列の初
     期化式に用いる.

`substatement'
     `if', `while', `for', `do', `else'の直後の最初の行

`substatement-open'
     substatementのブロックを開始する中括弧.

`case-label'
     `case'または`default'ラベルを表す.

`access-label'
     C++のアクセス指定子`private', `protected', `public'を表す.

`label'
     通常のラベル.

`do-while-closure'
     `do'-`while'文の`while'.

`else-clause'
     `if'-`else'文の`else'.

`catch-clause'
     C++やJavaの`try'...`catch'構成の`catch'行や`finally'行.

`comment-intro'
     コメントの導入部分だけを含んだ行.

`arglist-intro'
     引数リストの最初の行.

`arglist-cont'
     引数リストを開始する括弧の行に引数がない場合, 引数リストの2行目以
     降.

`arglist-cont-nonempty'
     引数リストを開始する括弧の行に少なくとも1つの引数がある場合, 引数
     リストの2行目以降.

`arglist-close'
     引数リストを終了する括弧.

`stream-op'
     ストリーム演算子を用いた式が継続する行.

`inclass'
     クラス定義の内側に入れ子になった言語構成要素.  字下げは, クラス定
     義の開き中括弧に相対である.

`inextern-lang'
     外部言語ブロックの内側に入れ子になった言語構成要素.

`inexpr-statement'
     式の内側の文ブロックの最初の行.  これは, 構文`({ ... })'を使うCに
     対するGCC拡張に用いる.  文ブロックを引数としてとるPikeの特殊関数
     にも用いる.

`inexpr-class'
     式の内側のクラス定義の最初の行.  これは, Javaの無名クラスや無名配
     列の初期化式に用いる.

`cpp-macro'
     cppマクロの開始.

`friend'
     C++の`friend'宣言.

`objc-method-intro'
     Objective-Cのメソッド定義の最初の行.

`objc-method-args-cont'
     Objective-Cのメソッド定義を継続する行.

`objc-method-call-cont'
     Objective-Cのメソッド呼び出しを継続する行.

`inlambda'
     `inclass'と同様だが, ラムダ（つまり, 無名）関数の内側に用いる.
     Pikeのみで用いる.

`lambda-intro-cont'
     キーワード`lambda'と関数本体のあいだの, ラムダ関数のヘッダーの継
     続行.  Pikeのみで用いる.



File: emacs-ja, Node: Variables for C Indent, Next: C Indent Styles, Prev: Syntactic Symbols, Up: Custom C Indent

Cの字下げのための変数
.....................

本節では, Cモードとその関連モードの字下げ動作を制御する, モードに固有
な変数について説明します.

`c-offsets-alist'
     構文シンボルとその字下げオフセットの連想リスト.  このリストに直接
     に値を設定するのではなく, `c-set-offset'を使うこと.  詳細について
     は, *Note Changing Indent Style::.

`c-style-alist'
     字下げスタイルを定義している変数.  下記参照.

`c-basic-offset'
     `c-offsets-alist'の中で, シンボル`+'や`-'が用いるオフセットの基本
     量.

`c-special-indent-hook'
     ユーザー定義の特別な字下げ調整用のフック.  このフックは, Cモード
     やその関連モードが行の字下げを終えたあとに呼ばれる.

変数`c-style-alist'は, あらかじめ定義された字下げスタイルを保持します. 
各要素は`(NAME VARIABLE-SETTING...)'の形をしていて, NAMEはスタイル名で
す.  また, 各VARIABLE-SETTINGは, `(VARIABLE . VALUE)'の形をしています.
VARIABLEには, Cモードが使用するカスタマイズ用変数の1つを指定します.
VALUEは, 選択されたスタイルが使われるときのVARIABLEの値です.

VARIABLEが`c-offsets-alist'である場合は, 特殊なケースです.
`c-offsets-alist'の値をVALUEの値で置き換えるのではなく,
`c-offsets-alist'の値の先頭にVALUEを追加します.  したがって, VALUEにす
べての構文シンボルを設定する必要はありません.  デフォルトと異なる構文
シンボルだけを単に設定すればよいのです.

コメントだけを含んだ行の字下げも, 変数`c-comment-only-line-offset' 
（*Note Comments in C::）に影響されます.



File: emacs-ja, Node: C Indent Styles, Next: Matching, Prev: Variables for C Indent, Up: Custom C Indent

Cの字下げスタイル
.................

"Cスタイル"とは, カスタマイズされた字下げスタイルの集合です.  Emacsに
は, Cモードや関連するモードのためにあらかじめ定義された, `gnu', `k&r',
`bsd', `stroustrup', `linux', `python', `java', `whitesmith',
`ellemtel', `cc-mode'といった字下げスタイルがあります.  デフォルトのス
タイルは`gnu'です.

望みのスタイルを選択するには, コマンド`M-x c-set-style'を使います.  引
数としてスタイル名を指定します（Cスタイル名では大文字小文字は区別しな
い）.  選択したスタイルは新たに訪問したバッファにだけ影響し, すでに編
集中のバッファには影響しません.  さまざまなメジャーモードのスタイルを
指定するために変数`c-default-style'を設定することもできます.  その値は
連想リストである必要があり, その各要素は, 1つのメジャーモードとそのモー
ドで使う字下げスタイルを指定します.  たとえば,

     (setq c-default-style
           '((java-mode . "java") (other . "gnu")))

は, Javaモードには対しては選択を明示し, 他のC流モードには`gnu'をデフォ
ルトとします.

Cの字下げスタイルを新たに定義するには, 関数`c-add-style'を呼びます.

     (c-add-style NAME VALUES USE-NOW)

ここで, NAMEは新しいスタイルの名前（文字列）, VALUESは要素が`(VARIABLE
. VALUE)'の形をした連想リストです.  VARIABLEには, *Note Variables for
C Indent::に書かれているものを指定してください.

USE-NOWが`nil'以外ならば, 新しいスタイルの定義後すぐにそれに切り替えま
す.



File: emacs-ja, Node: Matching, Next: Comments, Prev: Program Indent, Up: Programs

対応している括弧の自動表示
==========================

Emacsの括弧の対応付け機能は, テキスト中でどのように括弧が対応している
か自動的に表示するよう設計されています.  閉じ区切りである自己挿入文字
を打つと, それに対応する開き区切りが画面上にあれば, その箇所にほんのし
ばらくカーソルが移動します.  画面上になければ, エコー領域にその箇所の
近くにある文字列を表示します.  いずれにしても, 1つのまとまりが閉じたこ
とが判ります.

Lispでは, 括弧だけに対して自動的な対応付けを行います.  Cでは, 中括弧や
角括弧も対象となります.  Emacsは, メジャーモードが設定する構文テーブル
に基づいて, どの文字が対応関係にある区切りであるか判定します.  *Note
Syntax::.

`[x)'のように, 開き区切りと閉じ区切りが対応しない場合, エコー領域に警
告メッセージを表示します.  正しい対応関係は構文テーブルで指定します.

括弧の対応表示を制御する変数は3つあります.  `blink-maching-paren'は, 
対応表示機能をオンまたはオフにします.  `nil'を設定すると対応表示機能は
オフになりますが, デフォルトは`t'であり, 対応表示を行います.
`blink-matching-delay'は, 対応表示のために待つ秒数を指定します.  デフォ
ルトは1秒ですが, システムによっては何分の1秒のほうが便利かもしれません.
`blink-matching-paren-distance'は, 対応している開き区切りをみつけるた
めに, 何文字分まで戻って探索するか指定します.  その範囲内で対応するも
のがみつからなければ, 走査をやめて何も表示しません.  これは, 存在しも
しない対応する区切りを探すことに時間を浪費するのを防ぐためです.  デフォ
ルトは12,000です.

Xウィンドウシステムを使用している場合, 対応括弧表示（show-paren）モー
ドにすれば, より強力な括弧の対応表示を利用できます.  このモードは, 通
常の対応表示をオフにするかわりに, 対応する括弧同士を示すために強調表示
を行います.  ポイントが閉じ括弧の直後にあるときには, 閉じ括弧とそれに
対応する開き括弧の両方を強調表示します.  ポイントが開き括弧の直前にあ
るときには, 対応する閉じ括弧を強調表示します.  （ポイントの直後に開き
括弧があるときには, カーソルが開き括弧に重ねて表示されるので, 開き括弧
を強調表示する必要はない. ）このモードをオン／オフするには, コマンド
`M-x show-paren-mode'を使います.



File: emacs-ja, Node: Comments, Next: Balanced Editing, Prev: Matching, Up: Programs

コメントの操作
==============

コメントはプログラミングの重要な部分なので, Emacsにはコメントの編集や
挿入を行うための特別なコマンドがあります.

* Menu:

* Comment Commands::
* Multi-Line Comments::
* Options for Comments::



File: emacs-ja, Node: Comment Commands, Next: Multi-Line Comments, Prev: Comments, Up: Comments

コメント用コマンド
------------------


コメント用コマンドはコメントの挿入, 削除, および位置揃えを行います.

`M-;'
     コメントの挿入／位置揃えを行う（`indent-for-comment'）.
`C-x ;'
     コメントの桁位置を設定する（`set-comment-column'）.
`C-u - C-x ;'
     現在行のコメントをキルする（`kill-comment'）.
`C-M-j'
     RETに続けて, コメントの挿入／位置揃えを行う
     （`indent-new-comment-line'）.
`M-x comment-region'
     リージョン内の各行に対して, コメント区切りを追加／削除する.

コメントを挿入するコマンドは`M-;'（`indent-for-comment'）です.  行にコ
メントがなければ, 新規にコメントを作成して, "コメント桁位置"と呼ばれる
特定の桁に置きます.  コメントを作成する際には, Emacsが正しいと信じるコ
メント開始文字列（`comment-start'の値. 下記参照）を挿入します.  ポイン
トはその文字列の直後に置かれます.  コードのテキストがコメント桁位置を
越えているときには, 適当な境界に字下げします（通常は少なくとも空白1文
字）.  メジャーモードでコメント終了文字列が指定されていれば, 構文を正
しく保つために, ポイントの直後にその文字列を挿入します.

`M-;'は, 既存のコメントを位置揃えするためにも使えます.  行にコメント開
始文字列がすでに含まれていれば, その文字列の直後にポイントを移動してか
ら, 適切な位置に字下げします.  例外として, 0桁目から始まるコメントは動
かしません.

特定の文脈における, ある種のコメントの字下げには特殊な規則を持つメジャー
モードもあります.  たとえば, Lispのコードでは, セミコロン2つで始まるコ
メントは, コメント桁位置に揃えるのでなく, コードであるかのように字下げ
されます.  また, セミコロン3つで始まるコメントは左端に置くと仮定されま
す.  Emacsはこれらの慣習を理解していて, セミコロン2つのコメントはTABで
字下げし, セミコロン3つのコメントは字下げをまったく変更しません.

     ;; This function is just an example
     ;;; Here either two or three semicolons are appropriate.
     (defun foo (x)
     ;;; And now, the first part of the function:
       ;; The following line adds one.
       (1+ x))           ; This line adds one.

Cのコードでは, コメントのまえに白文字しかない場合には, そのコメントを
コードのように字下げします.

既存のコメントの位置が適切に揃えられている場合でも, コメント開始直後の
位置にすぐに移動するには`M-;'が便利です.

`C-u - C-x ;'（`kill-comment'）は, 現在行にコメントがあれば, それをキ
ルします.  コメント開始文字列のまえにある字下げもキルします.  コメント
と思われるものが何もなければ, 何もしません.  他の行にコメントを再挿入
するには, その行の末尾に移動してから`C-y'と打って, さらに, 位置を再調
整するために`M-;'と打ちます.  `C-u - C-x ;'はひとまとまりのキーではな
く, 負の引数を指定した`C-x ;'（`set-comment-column'）であることに注意
しましょう.  このコマンドは, 負の引数を受け取ると, `kill-comment'を呼
ぶようにプログラムされています.  `kill-comment'は, 望むならばキーに直
接バインドできる通常のコマンドです.



File: emacs-ja, Node: Multi-Line Comments, Next: Options for Comments, Prev: Comment Commands, Up: Comments

複数行にわたるコメント
----------------------

コメントを入力していて別の行に継続したければ, コマンド `C-M-j'
（`indent-new-comment-line'）を利用できます.  このコマンドは, 入力中の
コメントを終了して, そのつぎに空行を作り, 直前のコメントの直下にくるよ
うに字下げして新たなコメントを始めます.  自動詰め込み（auto-fill）モー
ドがオンならば, コメントを入力中に詰め込み桁を越えると, 同様にコメント
はつぎの行に継続されます.  `C-M-j'を打ったときにポイントが行末になけれ
ば, ポイント位置から行末までのテキストは新たなコメントの一部になります.

既存の行をコメントにするには, コマンド`M-x comment-region'を使います. 
このコマンドは, リージョン内で始まる各行にコメント区切り文字列を加えて
コメントにします.  負の引数を指定すると逆の操作, つまり, コメント区切
り文字列を削除します.

正の引数を指定すると, `comment-region'は, 追加するコメント開始文字列の
最後の文字を重複させます.  つまり, 引数は, その文字を何回重複させるか
を示します.  たとえば, Lispモードで`C-u 2 M-x commment-region'とすると, 
各行に`;;'を付加します.  コメント区切り文字を重複させるのは, コメント
に注意を引き付けるためです.  また, コメントの字下げにも影響します.
Lispでは, 適切な字下げになるように, 関数定義（defun）のあいだでは引数
として3を, 関数定義の内側では引数として2を指定すべきです.

変数`comment-padding'は, `comment-region'がコメント区切りと各行のもと
のテキストとのあいだに挿入する空白の個数を指定します.  デフォルトは1で
す.



File: emacs-ja, Node: Options for Comments, Next: Balanced Editing, Prev: Multi-Line Comments, Up: Comments

コメントを制御するオプション
----------------------------

コメント桁位置は, 変数`comment-column'に入っています.  この変数には明
示的に値を設定できます.  あるいは, コマンド `C-x ;'
（`set-comment-column'）を使って, ポイント位置の桁をコメント桁位置とし
て設定できます.  `C-u C-x ;'は, バッファ内で現在行よりまえにある最後の
コメントの桁位置をコメント桁位置としてから, `M-;'を行って現在行のコメ
ントをまえのコメントの直下にくるように位置を揃えます.  `C-u - C-x ;'は, 
前述のように関数`kill-comment'を実行することに注意してください.

変数`comment-column'は, バッファごとの変数です.  つまり, 通常の方法で
設定すると, カレントバッファだけに影響しますが, `setq-default'でデフォ
ルト値を変更できます.  *Note Locals::.  多くのメジャーモードでは, この
変数をカレントバッファ用に初期化します.

コメント用コマンドは, 変数`comment-start-skip'の正規表現に基づいてコメ
ントを認識します.  この正規表現が空文字列には一致しないようにしてくだ
さい.  厳密にはコメント開始文字列よりも長く一致するかもしれません.  た
とえば, Cモードではこの変数の値は`"/\\*+ *"'ですが, これは `/*'のうし
ろの余分なアスタリスクと空白に一致します.  （Lispの構文では, 文字列中
に`\'を含めるために`\\'とする必要がある.  この`\'は, 最初のアスタリス
クの正規表現における特別な意味を抑制するために必要.  *Note
Regexps::. ）

コメント用コマンドで新たなコメントを作ると, 
コメントを始めるために`comment-start'の値を挿入します. 
また, ポイントの直後には`comment-end'の値が挿入されて, 
これから入力するテキストのあとに続くことになります. 
Cモードでは, `comment-start'の値は`"/* "', 
`comment-end'の値は`" */"'です. 

変数`comment-multi-line'は, `C-M-j'（`indent-new-comment-line'）がコメ
ントの内側で使われたときの動作を制御します.  `comment-multi-line'が
`nil'（通常の設定）ならば, 現在行のコメントを終了し, 新たなコメントを
つぎの行から始めます.  `comment-multi-line'が`nil'以外ならば, 現在行と
同じコメントが継続されます.  つまり, 現在行のコメントを終えず, 新たな
行にも開始文字列を挿入しません.  複数行にわたるコメントを許す言語では, 
この変数に設定する値は好みの問題です.

変数`comment-indent-function'には, 新たに挿入したコメントの字下げや既
存のコメントに桁を揃えるための字下げを計算する関数を設定する必要があり
ます.  この変数には, メジャーモードごとに異なった関数が設定されます. 
この関数は引数なしで呼ばれますが, コメントがあるときにはその開始位置に
ポイントを置いて, 新規コメントの挿入時には行末にポイントを置いて呼ばれ
ます.  戻り値は, コメントを始めるべき桁位置です.  たとえば, Lispモード
では, この字下げ用フック関数は, 既存のコメントのセミコロンの個数とまえ
の行のコードに基づいて計算を行います.



File: emacs-ja, Node: Balanced Editing, Next: Symbol Completion, Prev: Comments, Up: Programs

括弧の対応を保った編集
======================

`M-('
     つぎの（1つ以上の）S式を括弧で囲む（`insert-parentheses'）.
`M-)'
     つぎの閉じ括弧のうしろへ移動してから字下げし直す
     （`move-past-close-and-reindent'）.

コマンド`M-('（`insert-parenthesis'）と`M-)'
（`move-past-close-and-reindent'）は, 括弧の対応をつねに保ったまま編集
するために設計されました.  `M-('は一対の括弧を挿入します.  引数がなけ
れば`()'を挿入しますが, 引数を指定すると, つぎのその個数分のS式を括弧
で囲みます.  ポイントは開き括弧の直後に置かれます.  コマンド`M-)'は, 
閉じ括弧のまえにある字下げを削除しながら閉じ括弧のうしろにポイントを移
動し, そのあと, `C-j'で字下げします.

たとえば, `( F O O )'と打つかわりに`M-( F O O'と打てば, カーソルが閉じ
括弧のまえにくることを除けば同じ効果を得られます.

`M-('は, 直前の文字の構文クラスによっては, 開き括弧のまえに空白を1個挿
入することがあります.  これを禁止したければ, `parens-require-spaces'に
`nil'を設定してください.



File: emacs-ja, Node: Symbol Completion, Next: Which Function, Prev: Balanced Editing, Up: Programs

シンボル名の補完
================

通常, 補完はミニバッファで行われます.  しかし, ある種の補完は任意のバッ
ファで利用できます.  それはシンボル名に対する補完です.

`M-TAB'は, ポイント直前の部分的なシンボルを, 意味のあるシンボル名の集
合から補完するコマンドを実行します.  部分的な名前から補完された追加文
字はポイント位置に挿入されます.

バッファ内の部分的な名前に対して, 複数個の補完候補があり, しかも, 追加
できる共通部分がない場合には, 補完候補一覧を別のウィンドウに表示します.

ほとんどのプログラム言語向けメジャーモードでは, `M-TAB'はコマンド
`complete-symbol'を実行します.  この関数には, 2種類の補完機能がありま
す.  通常, このコマンドはタグテーブル（*Note Tags::）に基づいて補完を
行います.  数引数（値は無関係）を指定すると, 当該言語のinfoファイルの
索引に並べられた名前を対象として補完を行います.  すなわち, プログラム
中で定義されたシンボル名を補完するには引数なしで`M-TAB'を使い, 標準ラ
イブラリ関数の名前を補完するには`C-u M-TAB'を使います.  もちろん, info
に基づいた補完は, 使用言語の標準ライブラリ関数に対するinfoファイルがあ
り, かつ, それがインストールされている場合にだけ動作します.

Emacs Lispモードでは, 補完対象の名前空間は, 関数定義, 値や属性を持つ
Emacs中の特殊なシンボルから成ります.  しかし, 部分的なシンボルの直前に
開き括弧があれば, 関数定義を持つシンボルだけを補完対象とします.  これ
を実現するコマンドは`lisp-complete-symbol'です.

テキスト（text）モードとその関連モードでは, `M-TAB'はスペルチェッカの
辞書に基づいた補完を行います.  *Note Spelling::.



File: emacs-ja, Node: Which Function, Next: Documentation, Prev: Symbol Completion, Up: Programs

関数名表示モード（which-functionモード）
========================================

関数名表示（which-function）モードは, バッファ内を動き廻るに従って現在
の関数名をモード行に表示するマイナモードです.

関数名表示（which-function）モードをオン（あるいはオフ）にするには, コ
マンド`M-x which-function-mode'を使います.  このコマンドはグローバルで
す.  つまり, 既存のバッファでもこれから作るバッファでも, すべてのバッ
ファに通用します.  しかし, `which-func-modes'の値で指定された特定のメ
ジャーモードでのみ効果があります.  （`which-func-modes'のデフォルト値
は`t'であり, 関数名表示（which-function）モードの支援方法を知っている
すべてのメジャーモードに適用されることを意味する.  具体的には, imenuを
使えるメジャーモード. ）



File: emacs-ja, Node: Documentation, Next: Change Log, Prev: Which Function, Up: Programs

説明文書用コマンド
==================

Emacsで実行するLispコードを編集するときには, 関数や変数の説明文字列を
表示するコマンド, `C-h f'（`describe-function'）や`C-h v'
（`describe-variable'）を利用できます.  これらのコマンドは, 説明文字列
を表示したい関数や変数の名前をミニバッファから読み取り, ウィンドウに説
明文字列を表示します.

たいへん便利なことに, これらのコマンドはポイント近傍のコードから, デフォ
ルトの引数を選択します.  `C-h f'は, ポイントを含むもっとも内側のリスト
で呼ばれる関数をデフォルトとします.  `C-h v'は, ポイントの周辺にあるか
隣接するシンボル名をデフォルトとします.

Emacs Lispコードに対しては, eldocモードも使えます.  このマイナモードは, 
ポイント位置で呼び出されている関数の引数リストを, たえずエコー領域に表
示します.  （いいかえれば, ポイントを含む関数呼び出しを探し, その関数
の引数リストを表示する. ）eldocマイナモードは, Emacs LispモードとLisp
対話（lisp-interaction）モードだけに適用できます.  この機能をオン／オ
フするには, コマンド`M-x eldoc-mode'を使います.

C, Lisp, その他言語のシンボルのinfo文書を見るには`C-h C-i'
（`info-lookup-symbol'）を使います.  ミニバッファでシンボルを指定しま
す.  デフォルトは, バッファ中のポイント位置にあるシンボルです.  シンボ
ルに対する説明文書を探す場所, つまり, どのinfoファイルのどの索引を探せ
ばよいかは, メジャーモードが決定します.  また, ファイル名に対する説明
文書を探すには`M-x info-lookup-file'を使います.

`M-x manual-entry'コマンドを使って, オペレーティングシステムのコマンド, 
ライブラリ関数, システムコールの『マニュアルページ』を読むことができま
す.  このコマンドは, マニュアルページを清書するために`man'プログラムを
実行します.  システムが許せば非同期に実行するので, マニュアルページが
清書されるまで, 編集を継続できます（MS-DOSやMS-Windows 3.xでは, 非同期
的なサブプロセスを実行できない.  このため, これらのシステムでは`man'の
終了をEmacsが待つあいだは編集できない）.  結果は, `*Man TOPIC*'という
名前のバッファに入ります.  これらのバッファではマン（man）モードと呼ば
れる特別なメジャーモードが使われ, スクロールや他のマニュアルページの調
査を容易に行えます.  より詳しくは, マニュアルページ用のバッファで,
`C-h m'と打ってください.

長いマニュアルページでは, 適切なフェイスを設定するにはとても時間がかか
ります.  さまざまなフォントや表示色を表示できる環境であれば, デフォル
トでマニュアルページにフェイスを用いるようになっています.  変数
`Man-fontify-manpage-flag'に`nil'を設定すれば, マニュアルページにおけ
るフェイスの使用をオフにできます.

他の方法でマニュアルページのテキストをEmacsバッファに挿入した場合,
`M-x manual-entry'と同じ変換を施すには, そこで`M-x
Man-fontify-manpage'コマンドを実行します.

GNUプロジェクトでは最終的に, ほとんどのマニュアルページをinfoで閲覧可
能なよりよく構成されたマニュアルに置き換えることを望んでいます.  *Note
Misc Help::.  この作業は, ほんの一部が完了しただけなので, まだマニュア
ルページを読めることは有益です.



File: emacs-ja, Node: Change Log, Next: Tags, Prev: Documentation, Up: Programs

変更記録
========

コマンド`C-x 4 a'は, 編集中のファイルに対する新たな項目を変更記録ファ
イルに追加します（`add-change-log-entry-other-window'）.

変更記録ファイルは, プログラムを変更した日付やその理由を時間順に記録し
たもので, 個々の変更を記述した項目の並びから成ります.  通常は, 編集し
ているファイルと同じディレクトリ, あるいは, その親ディレクトリに置いた
`ChangeLog'と呼ばれるファイルに保存されています.  1つの`ChangeLog'ファ
イルで, このファイルを置いたディレクトリやそのサブディレクトリに置いた
全ファイルの変更を記録できます.

変更記録項目は, 名前, （`user-mail-address'から得られた）電子メイルア
ドレス, 現在の日付と時刻から成るヘッダ行で始まります.  変更記録内の各
行はヘッダ行を除いて, つねに空白かタブで始まります.  1つの項目は"小項
目"から構成され, 各小項目は空白と星印で始まる行で始まります.  以下は,
1993年5月付けの2つの項目で, それぞれに2つの小項目があります.

     1993-05-25  Richard Stallman  <rms@gnu.org>

             * man.el: Rename symbols `man-*' to `Man-*'.
             (manual-entry): Make prompt string clearer.

             * simple.el (blink-matching-paren-distance):
             Change default to 12,000.

     1993-05-24  Richard Stallman  <rms@gnu.org>

             * vc.el (minor-mode-map-alist): Don't use it if it's void.
             (vc-cancel-version): Doc fix.

（Emacsの以前の版では, 日付の形式が異なる. ）

1つの項目で複数の変更を記述できます.  各変更について, それぞれの小項目
を用意しなくてはいけません.  通常, 小項目のあいだには空行がなくてはい
けません.  小項目が関連している（場所は異なるが同じ変更の一部分の）場
合には, それらのあいだには空行を入れずに一塊にしておきます.  上記の2番
目の項目には, このようにしてまとめた2つの小項目が含まれています.

`C-x 4 a'は, 変更記録ファイルを訪問して, 最新の項目が今日の日付で当人
の名前のものでなければ, 新たに項目を作成します.  また, 現在のファイル
に対する新たな小項目も作成します.  多くの言語に対して, 変更された関数
名やその他のオブジェクトを推測することもできます.

変更記録ファイルは, 変更記録（change-log）モードで訪問します.  このメ
ジャーモードでは, （空行で区切らない）ひとまとまりの小項目群を段落とし
て扱い, 各項目をページとして扱います.  これにより項目の編集が容易にな
ります.  `C-j'や自動詰め込みにより, 新たな行は直前の行と同様に字下げさ
れます.  これは項目内容を入力するのに便利です.

プログラムの変更を掌握し, 変更記録を維持する他の手段としては, 版管理
（バージョンコントロール）システムがあります.  *Note Log Buffer::.



File: emacs-ja, Node: Tags, Next: Emerge, Prev: Change Log, Up: Programs

タグテーブル
============

"タグテーブル"とは, 複数のファイルで構成されるプログラムが, どのように
各ファイルに分割されているのか記述したものです.  これは, プログラムを
構成するファイル名, そのファイルに入っている関数の名前（または, 名前の
付いた別の単位）やファイル内の位置の一覧です.  こうして関連するファイ
ルをまとめておけば, 全ファイルを対象とした探索や置換をコマンド1つで行
えます.  また, 関数名とその位置を記録してあるので, 関数がどのファイル
に入っているか調べて関数定義をみつけだす`M-.'のようなコマンドを実現で
きます.

タグテーブルは, "タグテーブルファイル"と呼ばれるファイルに格納されます. 
このファイルの慣習的な名前は`TAGS'です.

タグテーブルの各項目は, タグ名, タグが（暗黙に）定義されているファイル
の名前, そして, ファイル中でタグが定義されている位置を記録しています.

もとのプログラムファイルから, どんな名前がタグテーブルに記録されるかは, 
プログラム言語によって異なります.  一般的には, すべての関数やサブルー
チンを含み, 大域変数, データ型, あると便利なその他の情報などを含むこと
もあります.  記録された個々の名前を"タグ"と呼びます.

* Menu:

* Tag Syntax::		Tag syntax for various types of code and text files.  
* Create Tags Table::	Creating a tags table with `etags'.
* Select Tags Table::	How to visit a tags table.
* Find Tag::		Commands to find the definition of a specific tag. 
* Tags Search::		Using a tags table for searching and replacing.
* List Tags::		Listing and finding tags defined in a file.



File: emacs-ja, Node: Tag Syntax, Next: Create Tags Table, Prev: Tags, Up: Tags

ソースファイルのタグ構文
------------------------

ここでは, 広く一般に使われている言語に対するタグ構文の定義を紹介します.

   * Cのコードでは, 関数やtypedefで定義される型はタグであり, `struct',
     `union', `enum'の定義もやはりタグである.  また, タグテーブルを作
     成するときにオプション`--no-defines'を指定しなければ, `#define'に
     よるマクロ定義や`enum'の定数もタグとして扱う.  同様に, 大域変数も
     `--no-globals'を指定しない限りタグになる.  `--no-globals'と
     `--no-defines'を指定すると, タグテーブルファイルはかなり小さくな
     る.

   * C++のコードでは, Cのコードのタグ構成要素に加えて, メンバ関数もタ
     グとして認識される.  `--members'オプションを指定すれば, メンバ変
     数もタグになる.  クラス内の変数と関数に対するタグには, それぞれ,
     `CLASS::VARIABLE', `CLASS::FUNCTION'と名前が付く.

   * Javaのコードでは, C++のタグ構成要素に加えて, `extends'と
     `implements'に現れる名前もタグとして含む.  クラス内の変数と関数に
     対するタグには, それぞれ, `CLASS.VARIABLE', `CLASS.FUNCTION'と名
     前が付く.

   * LaTeXのテキストでは, `\chapter', `\section', `\subsection',
     `\subsubsection', `\eqno', `\label', `\ref', `\cite', `\bibitem',
     `\part', `\appendix', `\entry', `\index'のコマンドの引数がタグに
     なる.

     その他のLaTeXコマンドでも, `etags'を起動するまえに, 環境変数
     `TEXTAGS'にそれらのコマンドを指定しておけばタグの対象になる.  こ
     の環境変数の値は, コマンド名をコロンで区切った並び.  たとえば, 
     （bourneシェルでは）

          TEXTAGS="def:newcommand:newenvironment"
          export TEXTAGS

     とすると, `\def', `\newcommand', `\newenvironment'のコマンドの引
     数もタグの対象になる.

   * Lispコードでは, `defun'で定義した関数, `defvar'や`defconst'で定義
     した変数, および, 一般に0桁目から`(def'で始まる任意の式の最初の引
     数がタグ.

   * Schemeコードでは, `def'で定義されるものと, 名前が`def'で始まるも
     のがタグに含まれる.  また, ファイル内のトップレベルで`set!'を使っ
     て値が設定される変数もタグ.

他にも以下の言語で使えます.

   * アセンブリコードでは, 行の先頭から始まりコロンが続くラベルはタグ.

   * BisonやYaccの入力ファイルでは, 各構文規則で定義する非終端記号をタ
     グとする.  ファイル内のCコードの部分に対しては, Cのコードとしてタ
     グの解析を行う.

   * Cobolでは, 段落名, すなわち, 8桁目から始まりピリオドが続く任意の
     単語がタグ.

   * Erlangコードでは, ファイル内で定義された関数, レコード, マクロが
     タグ.

   * Fortranコードでは, 関数, サブルーチン, ブロックデータがタグ.

   * Objective-Cコードでは, クラス, クラスカテゴリ, メソッド, プロトコ
     ルの定義がタグ.

   * Pascalコードでは, 関数と手続きがタグ.

   * Perlコードでは, キーワード`sub'で定義される手続きがタグ.

   * Postscriptコードでは, 関数（演算子）がタグ.

   * Prologコードでは, 左端に現れる名前がタグ.

正規表現に基づいてタグを生成する方法（*Note Create Tags Table::）もあ
るので, 上記以外の形式や言語を扱うこともできます.



