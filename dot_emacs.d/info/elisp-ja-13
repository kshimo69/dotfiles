Info file: elisp-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp-ja: (elisp-ja).	The Emacs Lisp Reference Manual(Japanese).
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり, Emacs 20.3版に対応します.

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the section entitled "GNU General Public License" is included exactly
as in the original, and provided that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the Free
Software Foundation instead of in the original English.






File: elisp-ja, Node: Major Modes, Next: Minor Modes, Prev: Modes, Up: Modes

メジャーモード
==============

メジャーモードは, 特定種類のテキストの編集向けにEmacsを特化します.  各
バッファには, ある時点では1つのメジャーモードしかありません.

もっとも特化されていないメジャーモードは, "基本（fundamental）モード"
です.  このモードには, モードに固有な定義や変数の設定がありません.  そ
のため, Emacsの各コマンドはデフォルトのふるまいをし, 各オプションもデ
フォルトの状態です.  他のすべてのメジャーモードでは, さまざまなキーや
オプションを再定義します.  たとえば, lisp対話モードでは, `C-j'
（`eval-print-last-sexp'）やTAB（`lisp-indent-line'）など他のキーに対
しても特別なキーバインディングがあります.

読者の特別な編集作業を補佐するために一群の編集コマンドを書く必要がある
場合, 新たなメジャーモードを作ることは一般にはよいことです.  実際, メ
ジャーモードを書くことは（マイナモードを書くことはしばしば難しくなるが, 
それに対比すれば）簡単です.

新たなモードが既存のモードに類似していても, 既存のモードを2つの目的を
果たすように修正するのは賢いことではありません.  そのようにすると, 使
い難く保守し難くなるからです.  そのかわりに, 既存のメジャーモードの定
義をコピーし名前変えてから, コピーを変更します.  あるいは, "派生モード
" （derived mode）（*Note Derived Modes::）を定義します.  たとえば,
`emacs/lisp/rmailedit.el'にあるrmail編集モードは, テキスト（text）モー
ドに非常によく似たメジャーモードですが, 追加コマンドが3つあります.  そ
のような定義がテキスト（text）モードとの違いになるのですが, rmail編集
モードはテキスト（text）モードから派生したものです.

rmail編集モードは, バッファのメジャーモードを一時的に変更してバッファ
を別の方法（rmailのコマンドではなくEmacsの普通のコマンド）で編集できる
ようにする例題です.  そのような場合, 一時的なメジャーモードには, 普通, 
バッファの通常のモード（この場合にはrmailモード）に戻るコマンドがあり
ます.  読者は, 再帰編集の中で一時的に再定義し, ユーザーが再帰編集を抜
けるともとに戻す方法に魅了されるかもしれません.  しかし, これを複数の
バッファで行うと, 再帰編集はもっとも最近に入った再帰からまず抜けるので, 
ユーザーの選択に制約を課すことになり悪い方法です.  別のメジャーモード
を使えばこのような制約を回避できます.  *Note Recursive Editing::.

標準のGNU Emacs Lispのライブラリのディレクトリには, `text-mode.el',
`texinfo.el', `lisp-mode.el', `c-mode.el', `rmail.el'などのファイルに
いくつかのメジャーモードのコードが収めてあります.  モードの書き方を理
解するためにこれらのライブラリを調べられます.  テキスト（text）モード
は, 基本（fundamental）モードについで, もっとも単純なメジャーモードで
す.  rmailモードは複雑な特化されたモードです.

* Menu:

* Major Mode Conventions::  Coding conventions for keymaps, etc.
* Example Major Modes::     Text mode and Lisp modes.
* Auto Major Mode::         How Emacs chooses the major mode automatically.
* Mode Help::               Finding out how to use a mode.
* Derived Modes::           Defining a new major mode based on another major 
                              mode.



File: elisp-ja, Node: Major Mode Conventions, Next: Example Major Modes, Prev: Major Modes, Up: Major Modes

メジャーモードの慣習
--------------------

既存のメジャーモードのコードでは, ローカルキーマップや構文テーブルの初
期化, グローバルな名前, フックなどのさまざまなコーディング上の慣習を踏
襲しています.  読者が新たなメジャーモードを定義するときには, これらの
慣習に従ってください.

   * カレントバッファにおいて新しいモードに切り替える引数なしのコマン
     ドを定義し, その名前は`-mode'で終ること.  このコマンドが, キーマッ
     プ, 構文テーブル, 既存バッファにバッファローカルな変数を設定する
     が, バッファの内容は変更しないこと.

   * このモードで使える特別なコマンドに関して記述したこのコマンドに対
     する説明文字列を書く.  読者のモードで`C-h m'（`describe-mode'）を
     使うと, この説明文字列を表示する.

     説明文字列では, `\[COMMAND]', `\{KEYMAP}', `\<KEYMAP>'の特別な書
     き方を使え, これらはユーザー独自のキーバインディングに自動的に置
     き換えられる.  *Note Keys in Documentation::.

   * メジャーモードコマンドは, `kill-all-local-variables'の呼び出しか
     ら始めること.  それ以前に有効であったメジャーモードのバッファロー
     カルな変数に対処するためである.

   * メジャーモードコマンドは, 変数`major-mode'にメジャーモードコマン
     ドのシンボルを設定すること.  これにより, `describe-mode'が表示す
     べき説明文を捜し出す.

   * メジャーモードコマンドは, 変数`mode-name'にモードの『愛称』を文字
     列として設定すること.  この文字列がモード行に現れる.

   * すべてのグローバルな名前は同一の名前空間にあるので, モードの構成
     要素であるすべてのグローバル変数, 定数, 関数は, メジャーモード名
     （名前が長ければ, その省略）で始まること.  *Note Coding
     Conventions::.

   * メジャーモードには, 通常, それ独自のキーマップがあるはずで, 当該
     モードのすべてのバッファでローカルキーマップとして使われる.  メ
     ジャーモードコマンドは, `use-local-map'を呼び出して, そのローカル
     キーマップを設定すること.  詳しくは, *Note Active Keymaps::.

     このキーマップは, `MODENAME-mode-map'という名前のグローバル変数に
     恒久的に保持すること.  通常, モードを定義するライブラリでこの変数
     に設定する.

     モードのキーマップ変数に設定するコードの書き方に関する助言につい
     ては*Note Tips for Defining::.

   * メジャーモードのキーマップでバインドされたキー列は, 通常, `C-c'で
     始まり, コントロール文字, 数字文字, `{', `}', `<', `>', `:', `;'
     のいずれかが続くようにする.  その他の句読点文字はマイナモード向け
     に予約されている.  また, 通常の英文字はユーザー向けに予約されてい
     る.

     メジャーモードにおいては, そのモードによく適合した形で『同じ仕事』
     を行うコマンドであるならば, 標準的な意味を持つキー列に当該コマン
     ドを再バインドしても合理的である.  たとえば, プログラム言語編集用
     のメジャーモードでは, `C-M-a'を当該言語にうまく適合した方法で『関
     数の先頭へ移動する』コマンドに再定義する.

     テキスト挿入を許さないdiredやrmailなどのメジャーモードでは, 英文
     字や他の印字文字を編集コマンドとして再定義するのも合理的である.
     diredもrmailもこうしている.

   * モードでは, 独自の構文テーブルを用意するか, 他の関連するモードと
     構文テーブルを共有する.  独自の構文テーブルを用意する場合には,
     `MODENAME-mode-syntax-table'という名前の変数に保持すること.
     *Note Syntax Tables::.

   * コメントを書ける言語を扱うモードでは, コメントの構文を定義する変
     数に設定すること.  *Note コメントを制御するオプション:
     (emacs-ja)Options for Comments..。

   * モードでは, 独自の略語表を用意するか, 他の関連するモードと略語表
     を共有する.  独自の略語表を用意する場合には,
     `MODENAME-mode-abbrev-table'という名前の変数に保持すること.
     *Note Abbrev Tables::.

   * モードでは, バッファローカルな変数`font-lock-defaults' （*Note
     Font Lock Mode::）に設定して, フォントロック（font-lock）モードに
     対して強調表示の方法を指定すること.

   * モードでは, バッファローカルな変数`imenu-generic-expression'か
     `imenu-create-index-function'（*Note Imenu::）に設定して, iメニュー
     がどのようにバッファ内の定義や節を探すべきかを指定すること.

   * モードに関連する変数の設定には`defvar'か`defcustom'を使い, それら
     に値が設定されている場合には再初期化しないようにする.  （再初期化
     するとユーザーのカスタマイズを廃棄してしまう. ）

   * Emacsのカスタマイズ変数に対するバッファローカルな束縛は, メジャー
     モードコマンドにおいて`make-variable-buffer-local'ではなく
     `make-local-variable'で行う.  前者の関数は, すべてのバッファにお
     いてそれ以降に設定される当該変数をバッファローカルにしてしまい, 
     このモードを使わないバッファにも影響する.  モードにそのような大局
     的な効果があるのは望ましくない.  *Note Buffer-Local Variables::.

     単一のLispパッケージ内のみにおいて使われる変数に対しては, 必要な
     らば, `make-variable-buffer-local'を使ってもよい.

   * 各メジャーモードには, `MODENAME-mode-hook'という名前の"モードフッ
     ク"（mode hook）があること.  モードコマンドは, 最後に`run-hooks'
     を用いてフックを実行すること.  *Note Hooks::.

   * メジャーモードコマンドは, より基本的なモードのフックを実行しても
     よい.  たとえば, `indented-text-mode'は,
     `indented-text-mode-hook'に加えて`text-mode-hook'も実行する.  自
     前のフックを実行する直前（つまり設定が終ったあと）にこれらの他の
     フックを実行するか, より初期の段階で実行してもよい.

   * ユーザーがバッファをこのモードから別のメジャーモードに切り替えた
     ときに特別なことを行う必要がある場合, このモードでは,
     `change-major-mode-hook'（*Note Creating Buffer-Local::）のバッファ
     ローカルな値を設定しておく.

   * このモードが特別に準備したテキストに対してのみ有効な場合には, メ
     ジャーモードコマンドのシンボルには, つぎのように属性`mode-class'
     に値`special'を設定しておくこと.

          (put 'funny-mode 'mode-class 'special)

     これは, カレントバッファがfunnyモードのときに新たなバッファを作成
     しても, 新しいバッファではfunnyモードを継承しないようにEmacsに指
     示する.  dired, rmail, バッファ一覧などのモードではこの機能を使っ
     ている.

   * 新しいモードを識別可能な特定の名前のファイルに対するデフォルトに
     したい場合には, そのような名前のファイルに対して当該モードを選択
     するための要素を`auto-mode-alist'に追加する.  モードコマンドを自
     動ロードと定義する場合, `autoload'を呼び出している同じファイルに
     そのような要素を追加しておくこと.  そうでなければ, モード定義を収
     めたファイルに当該要素を入れるだけで十分である.  *Note Auto Major
     Mode::.

   * 説明文には, ユーザーが個人のファイル`.emacs'に書けるように,
     `autoload'の例, `auto-mode-alist'への追加方法の例を記載すること.

   * モードを定義するファイルのトップレベルのフォームは, それらを複数
     回評価しても不利な結果にならないように書いておくこと.  読者が当該
     ファイルを複数回ロードしなくても, 誰かがやるかもしれない.



File: elisp-ja, Node: Example Major Modes, Next: Auto Major Mode, Prev: Major Mode Conventions, Up: Major Modes

メジャーモードの例
------------------

基本（fundamental）モードを除くと, テキスト（text）モードはもっとも単
純なモードです.  上に述べた慣習の例示として, `text-mode.el'の抜粋をあ
げておきます.

     ;; モード固有の構文テーブルを作る
     (defvar text-mode-syntax-table nil 
       "Syntax table used while in text mode.")

     (if text-mode-syntax-table
         ()              ; 構文テーブルが既存ならば変更しない
       (setq text-mode-syntax-table (make-syntax-table))
       (modify-syntax-entry ?\" ".   " text-mode-syntax-table)
       (modify-syntax-entry ?\\ ".   " text-mode-syntax-table)
       (modify-syntax-entry ?' "w   " text-mode-syntax-table))

     (defvar text-mode-abbrev-table nil
       "Abbrev table used while in text mode.")
     (define-abbrev-table 'text-mode-abbrev-table ())

     (defvar text-mode-map nil)   ; モード固有のキーマップを作る

     (if text-mode-map
         ()              ; キーマップが既存ならば変更しない
       (setq text-mode-map (make-sparse-keymap))
       (define-key text-mode-map "\t" 'indent-relative)
       (define-key text-mode-map "\es" 'center-line)
       (define-key text-mode-map "\eS" 'center-paragraph))

つぎは, テキスト（text）モードのメジャーモード関数の完全な定義です.

     (defun text-mode ()
       "Major mode for editing text intended for humans to read....
      Special commands: \\{text-mode-map}
     Turning on text-mode runs the hook `text-mode-hook'."
       (interactive)
       (kill-all-local-variables)
       (use-local-map text-mode-map)
       (setq local-abbrev-table text-mode-abbrev-table)
       (set-syntax-table text-mode-syntax-table)
       (make-local-variable 'paragraph-start)
       (setq paragraph-start (concat "[ \t]*$\\|" page-delimiter))
       (make-local-variable 'paragraph-separate)
       (setq paragraph-separate paragraph-start)
       (setq mode-name "Text")
       (setq major-mode 'text-mode)
       (run-hooks 'text-mode-hook))      ; 最後に, フックによるモードの
                                         ;   カスタマイズをユーザーに許す

3つのlispモード（lispモード, emacs-lispモード, lisp対話モード）には, 
テキスト（text）モードより多くの機能があり, それに応じてコードもより複
雑です.  これらのモードの書き方を例示する`lisp-mode.el'からの抜粋をあ
げておきます.

     ;; モード固有の構文テーブルを作成する
     (defvar lisp-mode-syntax-table nil "")  
     (defvar emacs-lisp-mode-syntax-table nil "")
     (defvar lisp-mode-abbrev-table nil "")

     (if (not emacs-lisp-mode-syntax-table) ; 構文テーブルが既存ならば
                                            ;   変更しない
         (let ((i 0))
           (setq emacs-lisp-mode-syntax-table (make-syntax-table))

           ;; 0までの文字に, 単語構成文字ではないが
           ;; シンボル名構成文字であるクラスを設定する
           ;; (文字0は, ASCII文字集合では`48')
           (while (< i ?0) 
             (modify-syntax-entry i "_   " emacs-lisp-mode-syntax-table)
             (setq i (1+ i)))
           ...
           ;; 他の文字の構文を設定する
           (modify-syntax-entry ?  "    " emacs-lisp-mode-syntax-table)
           (modify-syntax-entry ?\t "    " emacs-lisp-mode-syntax-table)
           ...
           (modify-syntax-entry ?\( "()  " emacs-lisp-mode-syntax-table)
           (modify-syntax-entry ?\) ")(  " emacs-lisp-mode-syntax-table)
           ...))
     ;; lispモード向けの略語表を作る
     (define-abbrev-table 'lisp-mode-abbrev-table ())

3つのlispモードは多くのコードを共有しています.  つぎの関数はさまざまな
変数に設定します.  lispモードの各メジャーモード関数が呼び出します.

     (defun lisp-mode-variables (lisp-syntax)
       (cond (lisp-syntax
     	  (set-syntax-table lisp-mode-syntax-table)))
       (setq local-abbrev-table lisp-mode-abbrev-table)
       ...

`forward-paragraph'などの関数は, 変数`paragraph-start'の値を使います.
Lispのコードは普通のテキストとは異なるので, Lispを扱えるように変数
`paragraph-start'を特別に設定する必要があります.  また, Lispではコメン
トの字下げは特殊な形なので, 各lispモードには独自のモード固有の
`comment-indent-function'が必要です.  これらの変数に設定するコードが,
`lisp-mode-variables'の残りの部分です.

       (make-local-variable 'paragraph-start)
       (setq paragraph-start (concat page-delimiter "\\|$" ))
       (make-local-variable 'paragraph-separate)
       (setq paragraph-separate paragraph-start)
       ...
       (make-local-variable 'comment-indent-function)
       (setq comment-indent-function 'lisp-comment-indent))

各lispモードでは, キーマップが多少異なります.  たとえば, lispモードで
は`C-c C-z'を`run-lisp'にバインドしますが, 他のlispモードではそうしま
せん.  つぎのコードは, 共通するコマンドを設定します.

     (defvar shared-lisp-mode-map ()
       "Keymap for commands shared by all sorts of Lisp modes.")

     (if shared-lisp-mode-map
         ()
        (setq shared-lisp-mode-map (make-sparse-keymap))
        (define-key shared-lisp-mode-map "\e\C-q" 'indent-sexp)
        (define-key shared-lisp-mode-map "\177"
                    'backward-delete-char-untabify))

つぎはlispモード向けのキーマップを設定するコードです.

     (defvar lisp-mode-map ()
       "Keymap for ordinary Lisp mode....")

     (if lisp-mode-map
         ()
       (setq lisp-mode-map (make-sparse-keymap))
       (set-keymap-parent lisp-mode-map shared-lisp-mode-map)
       (define-key lisp-mode-map "\e\C-x" 'lisp-eval-defun)
       (define-key lisp-mode-map "\C-c\C-z" 'run-lisp))

最後に, emacs-lispモードのメジャーモード関数の完全な定義を示します.

     (defun lisp-mode ()
       "Major mode for editing Lisp code for Lisps other than GNU Emacs Lisp.
     Commands:
     Delete converts tabs to spaces as it moves back.
     Blank lines separate paragraphs.  Semicolons start comments.
     \\{lisp-mode-map}
     Note that `run-lisp' may be used either to start an inferior Lisp job
     or to switch back to an existing one.

     Entry to this mode calls the value of `lisp-mode-hook'
     if that value is non-nil."
       (interactive)
       (kill-all-local-variables)
       (use-local-map lisp-mode-map)          ; モードのキーマップを選択する
       (setq major-mode 'lisp-mode)           ; これにより`describe-mode'は
                                              ; 説明文を探し出せる
       (setq mode-name "Lisp")                ; モード行に表示される
       (lisp-mode-variables t)                ; さまざまな変数を定義する
       (setq imenu-case-fold-search t)
       (set-syntax-table lisp-mode-syntax-table)
       (run-hooks 'lisp-mode-hook))           ; フックによるモードの
                                              ; カスタマイズをユーザーに許す



File: elisp-ja, Node: Auto Major Mode, Next: Mode Help, Prev: Example Major Modes, Up: Major Modes

メジャーモードの選択方法
------------------------

Emacsは, ファイル名やファイル自体の情報をもとに, 当該ファイルを訪問す
るときの新しいバッファに対するメジャーモードを自動的に選択します.  ま
た, ファイル内のテキストで指定されたローカル変数も処理します.

 -- コマンド: fundamental-mode
     基本（fundamental）モードは, 特化してないメジャーモードである. 
     他のメジャーモードは, 実質的には, このモードとの対比で定義されて
     いる.  つまり, 基本（fundamental）モードから始めて, それらのメジャー
     モードではなにを変更するかを定義している.  関数`fundamental-mode'
     はフックを実行*しない*ため, 読者はカスタマイズできない.  （Emacs
     の基本（fundamental）モードのふるまいを変えたければ, Emacsの*大局
     的な*状態を変える必要がある. ）

 -- コマンド: normal-mode &optional FIND-FILE
     この関数は, カレントバッファに対して適切なメジャーモードとバッファ
     ローカルな変数を確立する.  この関数はまず`set-auto-mode'を呼び出
     し, 続いて, ファイルのローカル変数を必要に応じて解析, 束縛, 評価
     するために`hack-local-variables'を実行する.

     `normal-mode'に対する引数FIND-FILEが`nil'以外であると,
     `normal-mode'は`find-file'から呼び出されたと仮定する.  その場合, 
     ファイルの末尾や`-*-'の形式の行にあるローカル変数リストを処理する
     こともある.  変数`enable-local-variables'は, この処理を行うかどう
     かを制御する.  ファイル内でのローカル変数リストの構文については,
     *Note ファイルにローカルな変数: (emacs-ja)File Variables.

     読者が対話的に`normal-mode'を実行すると引数FIND-FILEは通常`nil'で
     ある.  その場合, `normal-mode'は, ローカル変数リストを無条件に処
     理する.

     `normal-mode'は, メジャーモード関数を呼び出す周りでは
     `condition-case'を使うので, エラーを補足して`File mode
     specification error'にもとのエラーメッセージを続けてエラーを報告
     する.

 -- User Option: enable-local-variables
     この変数は, 訪問したファイル内のローカル変数リストを処理するかど
     うかを制御する.  値`t'は, ローカル変数リストを無条件に処理するこ
     とを意味する.  `nil'は, それらを無視することを意味する.  それ以外
     の値であると, 各ファイルごとにユーザーに問い合わせる.  デフォルト
     値は`t'である.

 -- Variable: ignored-local-variables
     この変数は, ファイルのローカル変数リストで設定してはならない変数
     のリストを保持する.  それらの変数に対して指定した値は無視される.

このリストに加えて, 属性`risky-local-variable'が`nil'以外の値である変
数も無視されます.

 -- User Option: enable-local-eval
     この変数は, 訪問したファイル内のローカル変数リストの`Eval:'を処理
     するかどうかを制御する.  値`t'は, それらを無条件に処理することを
     意味する.  `nil'は, それらを無視することを意味する.  それ以外の値
     であると, 各ファイルごとにユーザーに問い合わせる.  デフォルト値は
     `maybe'である.

 -- Function: set-auto-mode
     この関数は, カレントバッファに対して適切なメジャーモードを選択する. 
     `-*-'行の値, 
     （`auto-mode-alist'を使って）訪問したファイルの名前, 
     （`interpreter-mode-alist'を使って）`#!'行, 
     ファイルのローカル変数リストをもとに決定する. 
     しかし, この関数はファイルの末尾付近にある
     ローカル変数`mode:'は調べないが, 
     関数`hack-local-variables'は調べる. 
     *Note メジャーモードの選択方式: (emacs-ja)Choosing Modes.。

 -- User Option: default-major-mode
     この変数は, 新たなバッファに対するデフォルトのメジャーモードを保
     持する.  標準値は`fundamental-mode'である.

     `default-major-mode'の値が`nil'であると, Emacsは（以前の）カレン
     トバッファのメジャーモードを新たなバッファのメジャーモードとする. 
     しかし, メジャーモードコマンドのシンボルの属性`mode-class'の値が
     `special'であると, 新たなバッファのメジャーモードにはせず, かわり
     に基本（fundamental）モードを使う.  この属性を持つモードは, 特別
     に準備したテキストに対してのみ有用であるdiredやrmailなどである.

 -- Function: set-buffer-major-mode BUFFER
     この関数はバッファBUFFERのメジャーモードを`default-major-mode'の
     値とする.  この変数が`nil'であると, （適切ならば）カレントバッファ
     のメジャーモードを使う.

     バッファを作成する低レベルの基本関数ではこの関数を使わないが,
     `switch-to-buffer'や`find-file-noselect'などの中レベルのコマンド
     ではバッファを作成するときにこのコマンドを使う.

 -- Variable: initial-major-mode
     この変数の値は, 最初のバッファ`*scratch*'のメジャーモードを決定す
     る.  値は, メジャーモードコマンドのシンボルであること.  デフォル
     ト値は, `lisp-interaction-mode'である.

 -- Variable: auto-mode-alist
     この変数は, ファイル名のパターン（正規表現, *Note Regular
     Expressions::）と対応するメジャーモードの連想リストを保持する. 
     通常, ファイル名パターンでは`.el'や`.c'などの接尾辞を調べるが, そ
     うでなくてもよい.  連想リストの通常の要素は`(REGEXP
     . MODE-FUNCTION)'の形である.

     たとえばつぎのとおり.

          (("\\`/tmp/fol/" . text-mode)
           ("\\.texinfo\\'" . texinfo-mode)
           ("\\.texi\\'" . texinfo-mode)
           ("\\.el\\'" . emacs-lisp-mode)
           ("\\.c\\'" . c-mode) 
           ("\\.h\\'" . c-mode)
           ...)

     展開したファイル名（*Note File Name Expansion::）がREGEXPに一致す
     るファイルを訪問すると, `set-auto-mode'は対応するMODE-FUNCTIONを
     呼び出す.  この機能により, Emacsはほとんどのファイルに対して適切
     なメジャーモードを選択する.

     `auto-mode-alist'の要素が`(REGEXP FUNCTION t)'の形であると,
     FUNCTIONを呼び出したあとで, Emacsはファイル名のそれまで一致しなかっ
     た部分について`auto-mode-alist'を再度探索する.  この機能は解凍パッ
     ケージには有用である.  `("\\.gz\\'" FUNCTION t)'の形の要素で, ファ
     イルを解凍し, `.gz'を除いたファイル名に従って解凍済みファイルを適
     切なモードにできる.

     `auto-mode-alist'にいくつかのパターン対を追加する方法を示す. 
     （この種の式を読者のファイル`.emacs'に使える. ）

          (setq auto-mode-alist
            (append 
             ;; ドットで始まる（ディレクトリ名付きの）ファイル名
             '(("/\\.[^/]*\\'" . fundamental-mode)  
               ;; ドットのないファイル名
               ("[^\\./]*\\'" . fundamental-mode)   
               ;; `.C'で終るファイル名
               ("\\.C\\'" . c++-mode))
             auto-mode-alist))

 -- Variable: interpreter-mode-alist
     この変数は, `#!'行でコマンドインタープリタを指定しているスクリプ
     トに対して用いるメジャーモードを指定する.  この値は,
     `(INTERPRETER . MODE)'の形の要素から成るリストであること.  たとえ
     ば, デフォルトには`("perl" . perl-mode)'の要素がある.  各要素は, 
     ファイルが指定するインタープリタがINTERPRETERに一致したらモード
     MODEを使うことを意味する.  INTERPRETERの値は, 実際には正規表現で
     ある.

     `auto-mode-alist'が使用すべきメジャーモードが指定しなかった場合に
     のみこの変数を使う.

 -- Function: hack-local-variables &optional FORCE
     この関数は, カレントバッファの内容に指定されたローカル変数を必要
     に応じて, 解析, 束縛, 評価する.

     `normal-mode'で述べた`enable-local-variables'の処理は, 実際にはこ
     こで行う.  引数FORCEは, 通常, `normal-mode'に与えられた引数
     FIND-FILEからくる.



File: elisp-ja, Node: Mode Help, Next: Derived Modes, Prev: Auto Major Mode, Up: Major Modes

メジャーモードに関するヘルプ
----------------------------

関数`describe-mode'は, メジャーモードに関する情報を得るために使います. 
通常, `C-h m'で呼び出されます.  関数`describe-mode'は`major-mode'の値
を使いますが, そのために各メジャーモード関数が変数`major-mode'に設定す
る必要があるのです.

 -- コマンド: describe-mode
     この関数は, 現在のメジャーモードの説明文を表示する.

     関数`describe-mode'は, `major-mode'の値を引数として関数
     `documentation'を呼び出す.  そうして, メジャーモード関数の説明文
     字列を表示する.  （*Note Accessing Documentation::. ）

 -- Variable: major-mode
     この変数は, カレントバッファのメジャーモードに対するシンボルを保
     持する.  このシンボルは, 当該メジャーモードに切り替えるためのコマ
     ンドを関数定義として持つこと.  関数`describe-mode'は, メジャーモー
     ドの説明文として当該関数の説明文字列を使う.



File: elisp-ja, Node: Derived Modes, Next: Minor Modes, Prev: Mode Help, Up: Major Modes

派生モードの定義
----------------

既存のメジャーモードを用いて新たなメジャーモードを定義できると便利です. 
これを行う簡単な方法は`define-derived-mode'を使うことです.

 -- Macro: define-derived-mode VARIANT PARENT NAME DOCSTRING BODY...
     これは, NAMEをモード名を表す文字列として使ってVARIANTをメジャーモー
     ドコマンドとして定義する.

     新たなコマンドVARIANTは, 関数PARENTを呼び出してから親モードの特定
     の機能を無効にするように定義される.

        * 新たなモードは, `VARIANT-map'という名前の独自のキーマップを
          持つ.  `define-derived-mode'は, このキーマップが定義済みでな
          ければ, `PARENT-map'から継承するようにこのキーマップを初期化
          する.

        * 新たなモードでは, 変数に`VARIANT-syntax-table'に独自の構文テー
          ブルを保持する.  この変数が定義済みでなければ,
          `PARENT-syntax-table'をコピーしてこの変数を初期化する.

        * 新たなモードでは, 変数に`VARIANT-abbrev-table'に独自の略語表
          を保持する.  この変数が定義済みでなければ,
          `PARENT-abbrev-table'をコピーしてこの変数を初期化する.

        * 新たなモードには独自のモードフック`VARIANT-hook'があり, 通常
          どおり最後にこれを実行する.  （新たなモードでは, PARENTを呼
          び出すことの一部としてPARENTのモードフックも実行する. ）

     さらに, BODYでPARENTの他の部分を無効にする方法を指定できる.  コマ
     ンドVARIANTは, `VARIANT-hook'を呼び出す直前, 通常の無効化処理を終
     えてからBODYのフォームを評価する.

     引数DOCSTRINGは, 新たなモードに対する説明文字列を指定する.
     DOCSTRINGを省略すると, `define-derived-mode'は説明文字列を生成す
     る.

     仮想的な例を示す.

          (define-derived-mode hypertext-mode
            text-mode "Hypertext"
            "Major mode for hypertext.
          \\{hypertext-mode-map}"
            (setq case-fold-search nil))

          (define-key hypertext-mode-map
            [down-mouse-3] 'do-hyper-link)



File: elisp-ja, Node: Minor Modes, Next: Mode Line Format, Prev: Major Modes, Up: Modes

マイナモード
============

"マイナモード"（minor mode）は, メジャーモードの選択とは独立にユーザー
がオン／オフできる機能を提供します.  マイナモードは, 個別にも組み合わ
せてもオンにできます.  マイナモードは, 長すぎますが『汎用的に使えるオ
プション機能のモード』と命名したようがよいかもしれません.

マイナモードは, 普通, 1つのメジャーモードを変更するだけではありません. 
たとえば, 自動詰め込みモード（auto-fillモード）は, テキスト挿入を許す
任意のメジャーモードで使えます.  汎用的であるためには, マイナモードは
メジャーモードが行うこととは実質的に独立である必要があります.

マイナモードは, メジャーモードに比べて, 実装するのがしばしば困難です.
1つの理由は, 任意の順でマイナモードをオン／オフできるようにする必要が
あるからです.  マイナモードは, メジャーモードや他のオンになっているマ
イナモードとは無関係にその望みの効果を発揮できる必要があります.

しばしば, マイナモードを実装するうえでもっとも大きな問題は, Emacsの残
りの部分に対して必要なフックを探すことです.  マイナモードキーマップに
より, 従来に比べて簡単になります.

* Menu:

* Minor Mode Conventions::      Tips for writing a minor mode.
* Keymaps and Minor Modes::     How a minor mode can have its own keymap.
* Easy-Mmode::                  A convenient facility for defining minor modes.



File: elisp-ja, Node: Minor Mode Conventions, Next: Keymaps and Minor Modes, Prev: Minor Modes, Up: Minor Modes

マイナモードを書くための慣習
----------------------------

メジャーモードに対するのと同じように, マイナモードを書くうえでの慣習が
あります.  メジャーモードの慣習には, マイナモードにも適用されるものが
あります.  つまり, モードを初期化する関数の名前, グローバルシンボルの
名前, キーマップやその他のテーブルや表の使い方です.

それらに加えて, マイナモードに固有な慣習もあります.

   * マイナモードを制御する変数の名前は`-mode'で終ること.  これを"モー
     ド変数"（mode variable）と呼ぶ.  マイナモードコマンドは, この変数
     を（オフにするには`nil', オンにするにはそれ以外に）設定すること.

     可能ならば, 変数に設定すると自動的にモードがオン／オフされるよう
     にモードを実装する.  そうすると, マイナモードコマンドは, 変数に設
     定する以外にはなにもしないでよくなる.

     この変数は, モード行にマイナモード名を表示するために
     `minor-mode-alist'でも使われる.  マイナモードキーマップを活性にし
     たり非活性にしたりもする.  各コマンドやフックもこの変数の値を検査
     する.

     各バッファごとに別々にマイナモードをオンにしたい場合には, この変
     数をバッファローカルにする.

   * モード変数と同じ名前のコマンドを定義する.  その仕事は, 当該変数に
     設定することでモードをオン／オフすることである.

     当該コマンドは, 省略可能な引数を1つ受け取ること.  引数が`nil'であ
     ればモードをトグル（オンであればオフに, オフであればオンに）する. 
     さもなければ, 引数が, 正整数, `nil'以外のシンボル, `-', あるいは,
     CARがそのような整数やシンボルであるようなリストの場合にはモードを
     オンにする.  それ以外ではモードをオフにする.

     `transient-mark-mode'の定義から引用した例を示す.  モードのふるま
     いをオン／オフする変数としての`transient-mark-mode'の使い方, およ
     び, 生の前置引数に基づいたマイナモードのオン／オフ／トグルの仕方
     を示す.

          (setq transient-mark-mode
                (if (null arg) (not transient-mark-mode)
                  (> (prefix-numeric-value arg) 0)))

   * モード行にマイナモードを表示したい場合には, 各マイナモードについ
     て要素を`minor-mode-alist'に追加する（*Note Mode Line Variables::）. 
     この要素はつぎの形のリストであること.

          (MODE-VARIABLE STRING)

     ここで, MODE-VARIABLEはマイナモードのオン／オフを制御する変数であ
     り, STRINGはモード行でモードを表す短い空白で始まる文字列である. 
     同時に複数のモードを表示できるように, これらの文字列は短いこと.

     `minor-mode-alist'に要素を追加するときには, 重複を防ぐために既存
     の要素を検査する`assq'を使うこと.  たとえばつぎのとおり.

          (or (assq 'leif-mode minor-mode-alist)
              (setq minor-mode-alist
                    (cons '(leif-mode " Leif") minor-mode-alist)))

このリストに要素を1回だけ追加するならば`add-to-list'も使えます（*Note
Setting Variables::）.



File: elisp-ja, Node: Keymaps and Minor Modes, Next: Easy-Mmode, Prev: Minor Mode Conventions, Up: Minor Modes

キーマップとマイナモード
------------------------

各マイナモードは, モードがオンのときに活性になる独自のキーマップを持て
ます.  マイナモード向けのキーマップを設定するには,
`minor-mode-map-alist'に要素を追加します.  *Note Active Keymaps::.

マイナモードキーマップの1つの用途は, ある種の自己挿入文字のふるまいを
変更して, 自己挿入に加えてなにかを行わせるようにすることです.  一般に,
`self-insert-command'をカスタマイズする機構は（略語モードや自動詰め込
みモード向けに設計された）特別な場合に限られるので, このようなことを行
う唯一の方法です.  （標準の`self-insert-command'の定義を読者独自の定義
で置き換えないこと.  エディタコマンドループはこの関数を特別扱いしてい
る. ）

マイナモードでバインドしているキー列は, `C-c'で始まり, `{', `}', `<',
`>', `:', `;'*以外*の句読点文字の1つが続くようにします.  （除外した句
読点文字はメジャーモード向けに予約されている. ）



File: elisp-ja, Node: Easy-Mmode, Next: Mode Line Format, Prev: Keymaps and Minor Modes, Up: Minor Modes

Easy-Mmode
----------

パッケージeasy-mmodeは, マイナモードを実装する便利な方法を提供します. 
これを使うと, 単純なマイナモードを1つの自己完結した定義に指定できます.

 -- Macro: easy-mmode-define-minor-mode MODE DOC &optional INIT-VALUE MODE-INDICATOR KEYMAP
     このマクロは, MODE（シンボル）という名前の新しいマイナモードを定
     義する.

     このマクロは, マイナモードをトグルするMODEという名前のコマンドを
     定義し, その説明文字列をDOCとする.

     また, MODEという名前の変数も定義する.  この変数はモードのオン／オ
     フにしたがって`t'/`nil'に設定される.  この変数はINIT-VALUEに初期
     化される.

     文字列MODE-INDICATORは, モードがオンのときにモード行に表示される
     文字列である.  それが`nil'であるとモード行にはモードを表示しない.

     省略可能な引数KEYMAPは, マイナモードのキーマップを指定する.  これ
     は, 値がキーマップであるような変数の名前か, つぎの形のバインディ
     ングを指定した連想リストであること.

          (KEY-SEQUENCE . DEFINITION)

`easy-mmode-define-minor-mode'を使った例を示します.

     (easy-mmode-define-minor-mode hungry-mode
       "Toggle Hungry mode.
     With no argument, this command toggles the mode. 
     Non-null prefix argument turns on the mode.
     Null prefix argument turns off the mode.

     When Hungry mode is enabled, the control delete key
     gobbles all preceding whitespace except the last.
     See the command \\[hungry-electric-delete]."
      ;; 初期値
      nil
      ;; モード行への表示
      " Hungry"
      ;; マイナモードのバインディング
      '(("\C-\^?" . hungry-electric-delete)
        ("\C-\M-\^?"
         . (lambda () 
             (interactive)
             (hungry-electric-delete t)))))

これは, 『hungryモード』という名前のマイナモードを定義します.  モード
をトグルするコマンドの名前は`hungry-mode', モードのオン／オフを表す変
数の名前は`hungry-mode', モードがオンのときに活性なキーマップを保持す
る変数の名前は`hungry-mode-map'です.  `C-DEL'と`C-M-DEL'に対するキーバ
インディングでキーマップを初期化します.



File: elisp-ja, Node: Mode Line Format, Next: Imenu, Prev: Minor Modes, Up: Modes

モード行の書式
==============

Emacsの（ミニバッファ専用ウィンドウを除く）各ウィンドウにはモード行が
あって, ウィンドウに表示しているバッファに関する状態情報を表示していま
す.  モード行には, バッファ名, 対応するファイル, 再帰編集の深さ, メジャー
モードとマイナモードなどのバッファに関する情報が含まれます.

本節では, モード行の内容の制御方法について述べます.  モード行に表示さ
れる情報のほとんどはオンになっているメジャーモードとマイナモードに関係
するので, 本章に含めます.

`mode-line-format'は, カレントバッファのモード行に表示する雛型を保持し
ているバッファローカルな変数です.  同一バッファに対するすべてのウィン
ドウは同じ`mode-line-format'を使い, それらのモード行は（スクロールの割
合や行やコラム位置を除いて）同じように表示されます.

ウィンドウのモード行は, 通常, ウィンドウに別のバッファを表示したときや, 
バッファの変更状態が`nil'から`t'へあるいはその逆の変化をしたときに更新
されます.  `mode-line-format'（*Note Mode Line Variables::）が参照する
変数を修正したり, テキストの表示方法に影響するその他の変数やデータ構造
（*Note Display::）を変更したときには, 新しい情報を表示したり新たな方
法で表示するためにモード行の更新を強制できます.

 -- Function: force-mode-line-update
     カレントバッファのモード行の更新を強制する.

モード行は, 通常, 反転表示されます.  *Note Inverse Video::の
`mode-line-inverse-video'を参照してください.

* Menu:

* Mode Line Data::        The data structure that controls the mode line.
* Mode Line Variables::   Variables used in that data structure.
* %-Constructs::          Putting information into a mode line.



File: elisp-ja, Node: Mode Line Data, Next: Mode Line Variables, Prev: Mode Line Format, Up: Mode Line Format

モード行のデータ構造
--------------------

モード行の内容は, バッファローカルな変数`mode-line-format'に保持された
リスト, 文字列, シンボル, 数から成るデータ構造で制御されます.  このデー
タ構造を"モード行構成"（mode line construct）と呼びます.  これは単純な
モード行構成から再帰的に構築します.  同じデータ構造はフレームタイトル
（*Note Frame Titles::）を構築するためにも使われます.

 -- Variable: mode-line-format
     この変数の値は, モード行全体の書式に責任を持つモード行構成である. 
     この変数の値は, モード行のテキストを作るためにどの変数を使うか, 
     それらはモード行のどこに現れるかを制御する.

モード行構成は, 定まったテキストの文字列のように単純でもかまいませんが, 
普通は, テキストを作るための別の変数の使い方を指定します.  それらの変
数の多くはそれ自身, それらの値としてモード行構成を持つように定義されて
います.

`mode-line-format'のデフォルト値は, `mode-name'や`minor-mode-alist'な
どの変数の値を使います.  多くの目的には, `mode-line-format'が参照する
いくつかの変数を変えるだけで十分です.

モード行構成は, リスト, シンボル, 文字列のいずれかです.  その値がリス
トであれば, その各要素はリスト, シンボル, 文字列のいずれかです.

`STRING'
     モード行構成としての文字列は, "`%'記法"を除いて, モード行にそのま
     ま表示される.  `%'のうしろの10進数は, 右側に空白を埋める（つまり
     データは左端に揃えられる）ときのフィールド幅を指定する.  *Note
     %-Constructs::.

`SYMBOL'
     モード行構成としてのシンボルは, その値を表す.  SYMBOLの値は,
     SYMBOLのかわりにモード行構成として使われる.  しかし, `t'や`nil'の
     シンボル, および, シンボルの値が空のものは無視する.

     例外が1つある：` ' SYMBOLの値が文字列であると, `%'記法を処理せず
     に文字列をそのまま表示する.

`(STRING REST...) or (LIST REST...)'
     最初の要素が文字列かリストであるリストは, すべての要素を再帰的に
     処理し, 結果を連結することを意味する.  これはもっとも多用されるモー
     ド行構成の形である.

`(SYMBOL THEN ELSE)'
     最初の要素がシンボルであるリストは条件節であり, その意味はSYMBOL
     の値に依存する.  その値が`nil'以外であると, 2番目の要素THENをモー
     ド行構成として再帰的に処理する.  SYMBOLの値が`nil'であると, 3番目
     の要素ELSEをモード行構成として再帰的に処理する.  ELSEは省略しても
     よいが, その場合, SYMBOLの値が`nil'であるところの要素はモード行に
     表示されない.

`(WIDTH REST...)'
     最初の要素が整数であるリストは, RESTの結果の切り詰めや引き伸しを
     指定する.  残りの要素RESTはモード行構成として再帰的に処理され連結
     される.  （WIDTHが正であれば）結果の右端に空白を追加したり, 
     （WIDTHが負であれば）結果を（-WIDTH幅に）右端から切り詰める.

     たとえば, ウィンドウの上端より上にバッファの何割があるかを表示す
     るには, `(-3 "%p")'のようなリストを使う.

読者が`mode-line-format'自体を変更するときには, 新しい値では, デフォル
ト値（*Note Mode Line Variables::）に現れるものと同じ変数を使い, それ
らの値をコピーして使ったり, 別の書式で情報を表示したりしないでください. 
こうしておけば, それらの変数に対する変更を介したユーザーや
（`display-time'やメジャーモードなどの）Lispプログラムが行ったカスタマ
イズが効果を発揮できます.

ホスト名やデフォルトディレクトリを含んだ`shell-mode'に有用な
`mode-line-format'の例を示します.

     (setq mode-line-format
       (list "-"
        'mode-line-mule-info
        'mode-line-modified
        'mode-line-frame-identification
        "%b--" 
        ;; リストを作るときに評価されることに注意
        ;; 単なる文字列のモード行構成を作る
        (getenv "HOST")
        ":" 
        'default-directory
        "   "
        'global-mode-string
        "   %[("
        'mode-name 
        'mode-line-process  
        'minor-mode-alist 
        "%n" 
        ")%]--"
        '(which-func-mode ("" which-func-format "--"))
        '(line-number-mode "L%l--")
        '(column-number-mode "C%c--")
        '(-3 . "%p")
        "-%-"))

（変数`line-number-mode', `column-number-mode', `which-func-mode'は特
定のマイナモードをオンにする.  通常どおり, これらの変数の名前はマイナ
モードコマンドの名前でもある. ）



File: elisp-ja, Node: Mode Line Variables, Next: %-Constructs, Prev: Mode Line Data, Up: Mode Line Format

モード行に使われる変数
----------------------

本節では, `mode-line-format'の標準値でモード行のテキストに含められる変
数について述べます.  これらの変数に関しては, 本来特別なことはありませ
ん.  別の変数を使うように`mode-line-format'を変更すれば, 別の変数でも
モード行において同じ効果を発揮します.

 -- Variable: mode-line-mule-info
     この変数は, 言語環境, バッファのコーディングシステム, 現在の入力
     方式に関する情報を表示するモード行構成の値を保持する.  *Note
     Non-ASCII Characters::.

 -- Variable: mode-line-modified
     この変数は, カレントバッファが変更されたかどうかを表示するモード
     行構成の値を保持する.

     `mode-line-modified'のデフォルト値は`("%1*%1+")'である.  これは, 
     バッファが変更されていると`**'を, 未変更ならば`--'を, 読み出し専
     用ならば`%%'を, 読み出し専用でしかも変更されていれば`%*'をモード
     行に表示することを意味する.

     この変数を変更してもモード行の更新を強制しない.

 -- Variable: mode-line-frame-identification
     この変数はカレントフレームを識別する.  複数のフレームを表示できる
     ウィンドウシステムを使用している場合にはデフォルト値は`" "'であり, 
     ある時点で1つのフレームしか表示できない普通の端末を使用している場
     合には`"-%F "'である.

 -- Variable: mode-line-buffer-identification
     この変数はウィンドウに表示しているバッファを識別する.  デフォルト
     値は`("%12b")'であり, 空白で埋めて最低12コラムでバッファ名を表示
     する.

 -- Variable: global-mode-string
     この変数は, デフォルトでモード行のバッファ名の直後に現れるモード
     行指定を保持する.  コマンド`display-time'は, `global-mode-string'
     が時刻と負荷情報を含んだ変数`display-time-string'を参照するように
     設定する.

     `%M'記法は`global-mode-string'の値を使うが, この変数は
     `mode-line-format'でモード行に含まれるため`%M'は廃れた記法である.

 -- Variable: mode-name
     このバッファローカルな変数は, カレントバッファのメジャーモードの
     『愛称』を保持する.  各メジャーモードは, モード行にモード名が現れ
     るようにこの変数に設定すること.

 -- Variable: minor-mode-alist
     この変数は, モード行にマイナモードがオンであることを表示する方法
     を指定する要素からなる連想リストを保持する.  `minor-mode-alist'の
     各要素は, 2要素リストであること.

          (MINOR-MODE-VARIABLE MODE-LINE-STRING)

     より一般的には, MODE-LINE-STRINGはどのようなモード行指定でもよい. 
     それは, MINOR-MODE-VARIABLEの値が`nil'以外のときにモード行に現れ, 
     さもなければ現れない.  これらの文字列は, 繋がらないように空白で始
     まること.  慣習的には, 特定モードに対するMINOR-MODE-VARIABLEは, 
     当該マイナモードがオンであると`nil'以外に設定される.

     `minor-mode-alist'のデフォルト値はつぎのとおり.

          minor-mode-alist
          => ((vc-mode vc-mode)
              (abbrev-mode " Abbrev") 
              (overwrite-mode overwrite-mode) 
              (auto-fill-function " Fill")         
              (defining-kbd-macro " Def")
              (isearch-mode isearch-mode))

     `minor-mode-alist'自体はバッファローカルではない.  マイナモードが
     各バッファごとにオンにできる場合には, 連想リストに指定した対応す
     る各変数はバッファローカルであること.

 -- Variable: mode-line-process
     このバッファローカルな変数は, サブプロセスとの通信用に使われてい
     るモードの処理状態に関するモード行の情報を保持する.  メジャーモー
     ド名の直後に空白で区切らずに表示される.  たとえば, バッファ
     `*shell*'におけるこの変数の値は`(":%s")'であり, シェルがその状態
     をメジャーモードとともに`(Shell: run)'のように表示できる.  通常, 
     この変数は`nil'である.

 -- Variable: default-mode-line-format
     この変数は, `mode-line-format'を変更していないバッファのデフォル
     トの`mode-line-format'の値を保持する.  これは`(default-value
     'mode-line-format)'と同じである.

     `default-mode-line-format'のデフォルト値はつぎのリストである.

          ("-"
           mode-line-mule-info
           mode-line-modified
           mode-line-frame-identification
           mode-line-buffer-identification
           "   "
           global-mode-string
           "   %[("
           mode-name 
           mode-line-process
           minor-mode-alist 
           "%n" 
           ")%]--"
           (which-func-mode ("" which-func-format "--"))
           (line-number-mode "L%l--")
           (column-number-mode "C%c--")
           (-3 . "%p")
           "-%-")

 -- Variable: vc-mode
     各バッファにおいてバッファローカルな変数`vc-mode'は, バッファで訪
     問したファイルが版管理されているか, そうならばその方式を記録して
     いる.  版管理されていない場合はその値は`nil', さもなければモード
     行に表示される文字列である.



File: elisp-ja, Node: %-Constructs, Next: Imenu, Prev: Mode Line Variables, Up: Mode Line Format

モード行の`%'記法
-----------------

以下は, 認識される`%'記法とその意味の表です.  `%%'以外の記法では, 最大
表示文字数を指定する10進数を`%'のあとに追加できます.

`%b'
     関数`buffer-name'で得られたカレントバッファ名.  *Note Buffer
     Names::.

`%f'
     関数`buffer-file-name'で得られた訪問したファイルの名前.  *Note
     Buffer File Name::.

`%F'
     選択しているフレームのタイトル（ウィンドウシステム上のみ）か名前.
     *Note Window Frame Parameters::.

`%c'
     ポイントの現在のコラム番号.

`%l'
     ポイントの現在の行番号.

`%*'
     バッファが読み出し専用であれば`%'（`buffer-read-only'を参照）, 
     バッファが変更されていれば`*'（`buffer-modified-p'を参照）, 
     さもなければ`-'. 
     *Note Buffer Modification::. 

`%+'
     バッファが変更されていれば`*'（`buffer-modified-p'を参照）, 
     バッファが読み出し専用であれば`%'（`buffer-read-only'を参照）, 
     さもなければ`-'. 
     `%*'との違いは, 変更された読み出し専用バッファに対してのみである. 
     *Note Buffer Modification::. 

`%&'
     バッファが変更されていれば`*', さもなければ`-'である.

`%s'
     `process-status'で得たカレントバッファに属するサブプロセスの状態.
     *Note Process Information::.

`%t'
     訪問したファイルがテキストファイルであるかバイナリファイルである
     かを表す.  （特定のオペレーティングシステムでのみ意味を持つ. ）

`%p'
     ウィンドウの*上端*の上にあるバッファのテキストの割合, あるいは,
     `Top', `Bottom', `All'のいずれかである.

`%P'
     ウィンドウの*下端*の上にあるバッファのテキスト（ウィンドウに見え
     てるテキストと上端の上にあるテキスト）の割合にバッファの先頭が見
     えていれば`Top'を加えたもの, あるいは, `Bottom', `All'のいずれか
     である.

`%n'
     ナロイングしていると`Narrow', さもなければなにもなし.  （*Note
     Narrowing::の`narrow-to-region'を参照）.

`%['
     （ミニバッファのレベルを除く）再帰編集レベルの深さを表す.  各編集
     レベルごとに1つの`['.  *Note Recursive Editing::.

`%]'
     （ミニバッファのレベルを除く）各再帰編集レベルごとに1つの`]'.

`%%'
     文字`%'.  `%'記法を許す文字列に`%'をそのまま含めるための方法であ
     る.

`%-'
     モード行の残り部分を埋めるに十分な個数のダッシュ.

つぎの2つの`%'記法はまだ使えますが, 変数`mode-name'や
`global-mode-string'を使って同じ効果を得られるのでこれらは廃れた記法で
す.

`%m'
     `mode-name'の値.

`%M'
     `global-mode-string'の値.  現在, `display-time'は
     `global-mode-string'の値を変更する.



File: elisp-ja, Node: Imenu, Next: Font Lock Mode, Prev: Mode Line Format, Up: Modes

iメニュー
=========

"iメニュー"（Imenu）とは, ユーザーがバッファ内の定義や節の一覧からその
1つを選ぶとバッファ内の当該箇所へ直接移動できる機能です.  iメニューは, 
バッファ内の定義や部分の名前や位置を表すバッファインデックスを構築して
おくことで動作し, 当該箇所へ移動するためにユーザーがそれらの1つを選べ
るようにします.  本節ではメジャーモードに対するiメニューをカスタマイズ
する方法を説明します.

普通のもっとも単純な方法は, 変数`imenu-generic-expression'に設定するこ
とです.

 -- Variable: imenu-generic-expression
     この変数が`nil'以外であると, iメニュー向けの定義を探すための正規
     表現を指定する.  もっとも単純な場合, 要素はつぎのような形である.

          (MENU-TITLE REGEXP SUBEXP)

     ここで, MENU-TITLEが`nil'以外であると, この要素に一致したものはバッ
     ファインデックスのサブメニューに置くことを意味する.  MENU-TITLE自
     体はサブメニューの名前を指定する.  MENU-TITLEが`nil'であると, こ
     の要素に一致したものはバッファインデックスのメニューに直接置かれ
     る.

     リストの2番目の要素REGEXPは正規表現（*Note Regular Expressions::）
     であり, これに一致した箇所がバッファインデックスに現れる定義にな
     る.  3番目の要素SUBEXPは, 定義の名前に一致するREGEXPの部分式であ
     る.

     要素はつぎの形でもよい.

          (MENU-TITLE REGEXP INDEX FUNCTION ARGUMENTS...)

     この要素に一致するものは, バッファインデックスの特別な項目になり, 
     ユーザーが当該項目を選ぶと, ITEM-NAME, バッファ位置, ARGUMENTSを
     引数としてFUNCTIONを呼び出す.

     emacs-lispモード向けには, PATTERNはつぎのようになる.

          ((nil "^\\s-*(def\\(un\\|subst\\|macro\\|advice\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2)
           ("*Vars*" "^\\s-*(def\\(var\\|const\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2)
           ("*Types*"
            "^\\s-*\
          (def\\(type\\|struct\\|class\\|ine-condition\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2))

     この変数に設定すると, カレントバッファにおいてバッファローカルな
     変数になる.

 -- Variable: imenu-case-fold-search
     この変数は, IMENU-GENERIC-EXPRESSIONとの一致に際して大文字小文字
     を区別するかどうかを制御する.  デフォルトは`t'であり, 大文字小文
     字を区別せずに一致をとる.

     この変数に設定すると, カレントバッファにおいてバッファローカルな
     変数になる.

 -- Variable: imenu-syntax-alist
     この変数は, `imenu-generic-expression'を処理中にカレントバッファ
     の構文テーブルに優先する構文テーブルの変更部分の連想リストである. 
     各要素はつぎの形であること.

          (CHARACTERS . SYNTAX-DESCRIPTION)

     CARのCHARACTERSは, 文字か文字列である.  それらの文字は, 指定した
     構文SYNTAX-DESCRIPTIONであることを意味する.  これは
     `modify-syntax-entry'（*Note Syntax Table Functions::）に渡される.

     この機能は典型的には, 通常のシンボル構成文字を単語構成文字として
     扱い, `imenu-generic-expression'を単純化し一致処理を速くする.  た
     とえば, fortranモードではつぎのように使っている.

            (setq imenu-syntax-alist '(("_$" . "w")))

     こうすると, `imenu-generic-expression'のパターンでは,
     `\\(\\sw\\|\\s_\\)+'のかわりに`\\sw+'を使える.  この技法は, 名前
     の先頭文字の集合を名前の残りの文字の集合よりも小さく制限する必要
     があるモードで使うには不便であることに注意してほしい.

     この変数に設定すると, カレントバッファにおいてバッファローカルな
     変数になる.

メジャーモードのiメニューをカスタマイズする別の方法は, 変数
`imenu-prev-index-position-function'や
`imenu-extract-index-name-function'に設定することです.

 -- Variable: imenu-prev-index-position-function
     この変数が`nil'以外であると, その値は, バッファインデックスに置く
     つぎの定義をファイルで後向きに探すための関数であること.

     その関数は, バッファインデックスの項目に対応する箇所にポイントを
     置くこと.  項目がみつからなければ`nil'を返すこと.

     この変数に設定すると, カレントバッファにおいてバッファローカルな
     変数になる.

 -- Variable: imenu-extract-index-name-function
     この関数が`nil'以外であると, その値は, ポイントが変数
     `imenu-prev-index-position-function'が返した定義の部分にあると仮
     定して, 当該定義の名前を返す関数であること.

     この変数に設定すると, カレントバッファにおいてバッファローカルな
     変数になる.

メジャーモードのiメニューをカスタマイズする最後の方法は, 変数
`imenu-create-index-function'に設定することです.

 -- Variable: imenu-create-index-function
     この関数は, バッファインデックスの作成に使う関数を指定する.  その
     関数は引数なしで, カレントバッファに対するインデックスを返すこと.
     `save-excursion'の内側から呼ばれるので, その関数がポイントをどこ
     に置こうと関係ない.

     デフォルト値は, インデックスの連想リストを生成するために
     `imenu-generic-expression'を使う関数である.  読者が別の関数を指定
     すれば, `imenu-generic-expression'は使われない.

     この変数に設定すると, カレントバッファにおいてバッファローカルな
     変数になる.

 -- Variable: imenu-index-alist
     この変数は, カレントバッファに対するインデックスの連想リストを保
     持する.  この変数に設定すると, カレントバッファにおいてバッファロー
     カルな変数になる.

     連想リストの単純な要素は`(INDEX-NAME . INDEX-POSITION)' のような
     形である.  このような単純な要素を選ぶと, バッファ内で
     INDEX-POSITIONへ移動する効果がある.

     特別な要素は`(INDEX-NAME POSITION FUNCTION ARGUMENTS...)'のような
     形である.  このような特別な要素を選ぶと, つぎのようなフォームを実
     行する.

          (funcall FUNCTION INDEX-NAME POSITION ARGUMENTS...)

     入れ子になった部分連想リストの要素は`(INDEX-NAME SUB-ALIST)'のよ
     うな形である.



File: elisp-ja, Node: Font Lock Mode, Next: Hooks, Prev: Imenu, Up: Modes

フォントロック（font-lock）モード
=================================

"フォントロック（font-lock）モード"とは, バッファ内の特定部分に対して, 
それらの構文上の役割に応じた属性`face'を自動的に付加する機能のことです. 
バッファを解析する方法はメジャーモードに依存しますが, ほとんどのメジャー
モードでは, どの文脈でどのフェイスを使うかを指示する条件を定義します. 
本節では, 特定の言語向けに, いいかえれば, 特定のメジャーモード向けにフォ
ントロックをカスタマイズする方法を説明します.

フォントロック（font-lock）モードは, 強調表示すべきテキストを2つの方法
で, つまり, 構文テーブルに基づいた構文解析, あるいは, （通常, 正規表現
による）探索で探します.  構文解析による処理を最初に行ってコメントや文
字列定数を探し, `font-lock-comment-face'や`font-lock-string-face' 
（*Note Faces for Font Lock::）を使ってそれらを強調表示します.  探索に
よる処理がこれに続きます.

* Menu:

* Font Lock Basics::
* Search-based Fontification::
* Other Font Lock Variables::
* Levels of Font Lock::
* Faces for Font Lock::
* Syntactic Font Lock::



File: elisp-ja, Node: Font Lock Basics, Next: Search-based Fontification, Prev: Font Lock Mode, Up: Font Lock Mode

フォントロック（font-lock）の基本
---------------------------------

フォントロック（font-lock）モードがテキストを強調表示する方法を制御す
る変数がいくつかあります.  しかし, メジャーモードでこれらの変数を直接
に設定するべきではありません.  そのかわりに, バッファローカルな変数
`font-lock-defaults'に設定すべきです.  フォントロック（font-lock）モー
ドがオンになると, この変数に設定された値を使って他のすべての変数に設定
します.

 -- Variable: font-lock-defaults
     この変数はメジャーモードがバッファローカルな変数として設定し, 当
     該モードにおいてテキストをどのように表示するかを指定する.  値はつ
     ぎの形であること.

          (KEYWORDS KEYWORDS-ONLY CASE-FOLD
           SYNTAX-ALIST SYNTAX-BEGIN OTHER-VARS...)

     最初の要素KEYWORDSは, 間接的に`font-lock-keywords'の値を指定する. 
     要素KEYWORDSがシンボルであると, その変数としての値が
     `font-lock-keywords'に使われる.  あるいは, 要素KEYWORDSがそのよう
     なシンボルのリストであると, 各シンボルが1つのレベルの表示方法を指
     定する.  最初のシンボルはレベル1の表示方法, 2番目のシンボルはレベ
     ル2の表示方法といった具合である.

     2番目の要素KEYWORDS-ONLYは, 変数`font-lock-keywords-only'の値を指
     定する.  これが`nil'以外であると（文字列やコメントの）構文による
     処理を行わない.

     3番目の要素CASE-FOLDは, `font-lock-case-fold-search'の値を指定す
     る.  これが`nil'以外であると, フォントロック（font-lock）モードは
     `font-lock-keywords'で指定された探索で大文字小文字を区別しない.

     4番目の要素SYNTAX-ALISTが`nil'以外である場合, それは
     `(CHAR-OR-STRING . STRING)'の形のコンスセルのリストであること. 
     これらは表示方法を選ぶための構文テーブルの設定に使われる（*Note
     Syntax Table Functions::）.  得られた構文テーブルは
     `font-lock-syntax-table'に保持される.

     5番目の要素SYNTAX-BEGINは,
     `font-lock-beginning-of-syntax-function'の値を指定する（下記参照）.

     OTHER-VARS以降の要素は, `(VARIABLE . VALUE)'という形である.  この
     種の要素は, 表示方法の選択に影響するその他の変数に設定するために
     使われる.



File: elisp-ja, Node: Search-based Fontification, Next: Other Font Lock Variables, Prev: Font Lock Basics, Up: Font Lock Mode

探索に基づくフォント選択
------------------------

フォントロック（font-lock）モードのカスタマイズにおいてもっとも重要な
変数は`font-lock-keywords'です.  探索に基づく表示方法の選択における探
索条件を指定します.

 -- Variable: font-lock-keywords
     この変数の値は, 強調表示するべきキーワードのリストである.  このリ
     ストに正規表現を書く場合には注意すること.  貧弱な書き方をしたパター
     ンであると, 動作を劇的に遅くする！

`font-lock-keywords'の各要素は, 特定のテキストの探し方と当該テキストを
どのように強調表示するか指定します.  フォントロック（font-lock）モード
は, `font-lock-keywords'の要素を1つ1つ処理し, 各要素において, それに一
致するものすべてを探して処理します.  通常, すでに表示方法を選択済みの
テキスト部分については, それ以降の要素に一致しても表示方法を変えません. 
しかし, HIGHLIGHTERの要素OVERRIDEを使って, 異なるふるまいを指定できま
す.

`font-lock-keywords'の各要素はつぎのいずれかの形です.

`REGEXP'
     正規表現REGEXPに一致したものはすべて`font-lock-keyword-face'を使っ
     て強調表示する.

          ;; 孤立した`foo'の出現は
          ;; `font-lock-keyword-face'で強調表示する. 
          "\\<foo\\>"

     関数`regexp-opt'（*Note Syntax of Regexps::）は, 異なる複数個のキー
     ワードに一致する最適な正規表現を計算するのに有用である.

`FUNCTION'
     関数FUNCTIONを呼び出してテキストを探し, それが探し出したものを
     `font-lock-keyword-face'を使って強調表示する.

     FUNCTIONは, 探索限界を引数として呼び出される.  みつかれば`nil'以
     外を返すとともにみつけた部分を表すマッチデータを設定する.

`(MATCHER . MATCH)'
     この種の要素では, MATCHERは, 上に述べた正規表現か関数を表す.  CDR
     のMATCHは, （MATCHERに一致した部分全体のかわりに）強調表示すべき
     MATCHERの部分式を指定する.

          ;; `fubar'の各出現の`bar'を
          ;; `font-lock-keyword-face'で強調表示
          ("fu\\(bar\\)" . 1)

     正規表現MATCHERを作るために`regexp-opt'を使った場合, MATCHの値を
     計算するには`regexp-opt-depth'（*Note Syntax of Regexps::）を使え
     る.

`(MATCHER . FACENAME)'
     この種の要素では, FACENAMEは, 強調表示に使うフェイス名を指定する
     値を表す式である.

          ;; `fubar'の出現は, `fubar-face'の値で
          ;; 表されたフェイスを使って強調表示
          ("fubar" . fubar-face)

`(MATCHER . HIGHLIGHTER)'
     この種の要素では, HIGHLIGHTERは, MATCHERに一致した部分の強調表示
     方法を指定するリストである.  つぎの形であること.

          (SUBEXP FACENAME OVERRIDE LAXMATCH)

     CARのSUBEXPは, 強調表示すべき一致部分の部分式を指定する整数（0は
     一致部分全体を意味する）である.  2番目の要素FACENAMEは, 上に述べ
     たようにフェイスを指定する.

     HIGHLIGHTERの最後の2つの要素, OVERRIDEとLAXMATCHはフラグである.
     OVERRIDEが`t'であると, 当該要素は, `font-lock-keywords'のまえの要
     素で決定済みの表示方法に優先することを表す.  `keep'であると, 他の
     要素では表示方法が決定していない各文字の表示方法を表す.
     `prepend'であると, 属性`face'の先頭にフェイスFACENAMEを追加する.
     `append'であると, 属性`face'の末尾にフェイスFACENAMEを追加する.

     LAXMATCHが`nil'以外であると, MATCHERで一致したものの中にSUBEXP番
     目の部分式がなくてもエラーとしないことを意味する.

     この種の要素とその動作の例を示す.

          ;; `foo'や`bar'の出現の表示方法がすでに決まっていても
          ;; `foo-bar-face'で強調表示する
          ;; `foo-bar-face'の値はフェイスであること
          ("foo\\|bar" 0 foo-bar-face t)

          ;; 関数`fubar-match'がみつけた各出現内の最初の部分式を
          ;; `fubar-face'の値が表すフェイスで強調表示する
          (fubar-match 1 fubar-face)

`(MATCHER HIGHLIGHTERS...)'
     この種の要素は, 1つのMATCHERに対して複数のリストHIGHLIGHTERを指定
     する.  これが有用であるためには, 各HIGHLIGHTERでSUBEXPの値が異な
     ること.  つまり, それぞれをMATCHERの異なる部分式に適用できること.


`(eval . FORM)'
     FORMは, バッファにおいて`font-lock-keywords'のこの値が始めて使わ
     れたときに評価すべき式である.  その値は, この表にあげた形の1つで
     あること.

*警告：*` ' `font-lock-keywords'の要素は, 行をまたがって一致するように
設計しないこと.  そのような処理は信頼性がない.
`font-lock-fontify-buffer'は, 行にまたがるパターンを正しく扱えるが, 読
者がバッファを編集したときの更新処理では, 一度に1行ずつ処理するために
正しく扱えない.



File: elisp-ja, Node: Other Font Lock Variables, Next: Levels of Font Lock, Prev: Search-based Fontification, Up: Font Lock Mode

その他のフォントロック変数
--------------------------

本節では, `font-lock-defaults'を用いてメジャーモードで設定できる他の変
数について述べます.

 -- Variable: font-lock-keywords-only
     `nil'以外であると, フォントロック（font-lock）モードは, 構文に基
     づいてコメントや文字列を強調表示すべきでないことを意味する.
     `font-lock-keywords'に基づく強調表示のみを行う.


 -- Variable: font-lock-keywords-case-fold-search
     `nil'以外であると, `font-lock-keywords'の正規表現探索では大文字小
     文字を区別しないことを意味する.

 -- Variable: font-lock-syntax-table
     この変数は, コメントや文字列の表示方法に用いる構文テーブルを指定
     する.

 -- Variable: font-lock-beginning-of-syntax-function
     この変数が`nil'以外であると, ポイントを構文上の『トップレベル』で
     文字列やコメントの外側に後方移動する関数であること.  フォントロッ
     ク（font-lock）モードは, 構文に基づく処理において正しい結果を得る
     ために必要に応じてこの関数を使う.

     関数は引数なしで呼び出される.  ポイントを構文ブロックの先頭に置く
     こと.  典型的な値は, `beginning-of-line'（行頭は構文ブロックの外
     側である）, あるいは, プログラム向けのモードでは
     `beginning-of-defun', テキスト向けのモードでは
     `backward-paragraph' （モード固有の関数は構文ブロックの外側にポイ
     ントを移動する）である.

     値が`nil'であると, バッファの先頭を構文ブロックの外側の位置として
     使う.  これは誤りではないが, 動作を遅くする.

 -- Variable: font-lock-mark-block-function
     この変数が`nil'以外であると, コマンド`M-g M-g'
     （`font-lock-fontify-block'）による再表示のためにテキストの括られ
     た範囲を選ぶために引数なしで呼ばれ関数であること.

     関数は, 選んだ範囲にリージョンを設定すること.  正しい結果を得られ
     るように大きめのテキスト範囲を選ぶのがよいが, 再表示処理が遅くな
     らないように大きすぎないこと.  典型的な値は, プログラム向けモード
     では`mark-defun', テキスト向けモードでは`mark-paragraph'である.



File: elisp-ja, Node: Levels of Font Lock, Next: Faces for Font Lock, Prev: Other Font Lock Variables, Up: Font Lock Mode

フォントロックのレベル
----------------------

多くのメジャーモードでは, 3段階の表示方法を提供します.
`font-lock-defaults'のKEYWORDSにシンボルのリストを使って複数レベルを定
義できます.  各シンボルは1つのレベルの表示方法を指定します.  どのレベ
ルを選ぶかはユーザーの責任です.  指定したレベルのシンボルの値は
`font-lock-keywords'の初期化に使われます.

表示方法のレベルを定義する際の慣習をあげておきます.

   * レベル1：` ' 関数宣言, （includeやimportなどの）ファイル指定, 文
     字列, コメントを強調表示する.  速さが肝心であり, 重要な構文やトッ
     プレベルの構成要素のみを強調表示する.

   * レベル2：` ' レベル1に加えて, キーワードのようにふるまう型名を含
     む当該言語のすべてのキーワード, 名前付き定数.  （構文的な, あるい
     は, 意味的な）すべてのキーワードを適切に強調表示するのが目的.

   * レベル3：` ' レベル2に加えて, 関数や変数宣言で定義されたシンボル, 
     適切なすべての組み込み関数の名前.



File: elisp-ja, Node: Faces for Font Lock, Next: Syntactic Font Lock, Prev: Levels of Font Lock, Up: Font Lock Mode

フォントロックのフェイス
------------------------

フォントロック（font-lock）モードでは任意のフェイスを使えますが, フォ
ントロック（font-lock）モード向けに特別に定義さたフェイスがあります. 
これらのシンボルのおのおのは, フェイス名でもあり, シンボル自身をデフォ
ルト値とする変数でもあります.  つまり, `font-lock-comment-face'のデフォ
ルト値は, `font-lock-comment-face'です.  これは, フェイス名を値に持つ
ような式を書く`font-lock-keywords'などの場面で,
`font-lock-comment-face'と書けることを意味します.

`font-lock-comment-face'
     （典型的には）コメントに使われる.

`font-lock-string-face'
     （典型的には）文字列に使われる.

`font-lock-keyword-face'
     （典型的には）キーワード, つまり, Cの`for'や`if'のように構文的に
     重要な名前に使われる.

`font-lock-builtin-face'
     （典型的には）組み込み関数の名前に使われる.

`font-lock-function-name-face'
     （典型的には）関数定義／宣言内において, 定義／宣言されている関数
     の名前に使われる.

`font-lock-variable-name-face'
     （典型的には）変数定義／宣言内において, 定義／宣言されている変数
     の名前に使われる.

`font-lock-type-face'
     （典型的には）ユーザー定義のデータ型の名前が定義／参照される場所
     において, それらの名前に使われる.

`font-lock-constant-face'
     （典型的には）定数の名前に使われる.

`font-lock-warning-face'
     （典型的には）独特な構文や別のテキストの意味を大きく変えるような
     ものに使われる.  たとえば, Emacs Lispの`;;;###autoload'やCの
     `#error'指定に使われる.



File: elisp-ja, Node: Syntactic Font Lock, Next: Hooks, Prev: Faces for Font Lock, Up: Font Lock Mode

構文的なフォントロック
----------------------

フォントロック（font-lock）モードは, 属性`syntax-table'を自動更新する
ためにも使えます.  1つの構文テーブルだけでは十分でないような言語におい
て有用です.

 -- Variable: font-lock-syntactic-keywords
     この変数は構文的なフォントロックをオンにし制御する.  その値はつぎ
     の形の要素からなるリストであること.

          (MATCHER SUBEXP SYNTAX OVERRIDE LAXMATCH)

     この要素の各部分には, つぎの`font-lock-keywords'の対応する種類の
     要素と同じ意味がある.

          (MATCHER SUBEXP FACENAME OVERRIDE LAXMATCH)

     しかし, 属性`face'に使う値FACENAMEを指定するかわりに, 属性
     `syntax-table'に使う値SYNTAXを指定する.  ここで, SYNTAXは, 構文テー
     ブルを値とする変数, `(SYNTAX-CODE . MATCHING-CHAR)'の形の構文テー
     ブルの項目, あるいは, この2種類のどちらかを値とする式である.



File: elisp-ja, Node: Hooks, Next: Documentation, Prev: Font Lock Mode, Up: Modes

フック
======

"フック"（hook）とは, 既存のプログラムから特定の場面で呼び出される（1
つか一連の）関数を収めた変数です.  Emacsは, カスタマイズのためにフック
を用意しています.  ほとんどの場合, フックはファイル`.emacs'で設定しま
すが, Lispプログラムが行ってもかまいません.  標準のフック関数一覧につ
いては, *Note Standard Hooks::.

Emacsの多くのフックは"ノーマルフック"（normal hook）です.  これらの変
数は, 引数なしで呼び出される関数のリストを保持しています.  フック名が
`-hook'で終っていると, ノーマルフックを意味します.  読者がそれらを単一
の方法で使えるように, 可能な限りノーマルフックにするように心掛けていま
す.

各メジャーモード関数は, その初期化の最終段階で"モードフック"（mode
hook）と呼ばれるノーマルフックを実行すると期待されます.  これにより, 
モードがすでに設定したバッファローカルな変数を上書きすることで, ユーザー
がモードのふるまいをカスタマイズしやすくしています.  しかし, フックは
別の場面でも使われています.  たとえば, フック`suspend-hook'は, Emacsが
自身を一時休止する直前に実行されます.  （*Note Suspending Emacs::）.

ノーマルフックにフック関数を追加する推奨方法は, `add-hook'（下記参照）
を呼ぶことです.  フック関数は, `funcall'（*Note What Is a Function::）
が受け付けるならばどんな種類の関数でもかまいません.  ほとんどのノーマ
ルフック変数は最初は空ですが, `add-hook'はその扱い方を知っています.

フック変数の名前が`-hook'で終らない場合, それが"アブノーマルフック"
（abnormal hook）であることを表します.  読者は, そのようなフックの正し
い使い方を説明書で調べるべきです.

変数名が`-functions'や`-hooks'で終っていると, その値は関数のリストです
が, それらの関数を引数ありで呼び出したり, 関数の戻り値をどこかで使うと
いう意味でアブノーマル（異常）なのです.  リストに関数を追加するには
`add-hook'を使えますが, 関数を書くときには注意する必要があります. 
（これらの変数のうち, 実際にはノーマルフックであるものもある.  ノーマ
ルフックには`-hook'を使うという慣習を確立するまえに命名したものであ
る. ）

変数名が`-function'で終っていると, その値は, 関数のリストではなく, 1つ
の関数です.

lisp対話モードで自動詰め込み（auto-fill）モードをオンにするためにモー
ドフックを使った例を示します.

     (add-hook 'lisp-interaction-mode-hook 'turn-on-auto-fill)

適当な時期に, Emacsは関数`run-hooks'を使って特定のフックを実行します. 
この関数は, `add-hook'で追加されたフック関数を呼び出します.

 -- Function: run-hooks &rest HOOKVAR
     この関数は複数個のフック変数名を引数にとり, 各フックを順に実行す
     る.  各引数HOOKVARは, フック変数のシンボルであること.  これらの引
     数は, 指定された順に処理される.

     フック変数が`nil'以外の値であると, その値は, 関数か関数のリストで
     ある.  値が関数（ラムダ式や関数定義を持つシンボル）であると, それ
     を呼び出す.  値がリストであると, 順番にその要素を呼び出す.  フッ
     ク関数は, 引数なしで呼び出される.  現在, フック変数に1つの関数を
     入れることは廃れかけている.  つねに関数のリストを使うべきである.

     例として, `emacs-lisp-mode'がそのモードフックをどのように実行する
     かを示す.

          (run-hooks 'emacs-lisp-mode-hook)

 -- Function: run-hook-with-args HOOK &rest ARGS
     この関数は, フック関数に引数を渡すアブノーマルフックを実行する方
     法である.  各フック関数に引数ARGSを渡して呼び出す.

 -- Function: run-hook-with-args-until-failure HOOK &rest ARGS
     この関数は, フック関数に引数を渡すアブノーマルフックを実行するが, 
     フック関数が失敗するとただちに止める方法である.  フック関数が
     `nil'を返すまで, 各フック関数に引数ARGSを渡して呼び出す.  `nil'が
     返ってくると`nil'で戻る.  さもなければ, `nil'以外の値を返す.

 -- Function: run-hook-with-args-until-success HOOK &rest ARGS
     この関数は, フック関数に引数を渡すアブノーマルフックを実行するが, 
     フック関数が成功するとただちに止める方法である.  フック関数が
     `nil'以外を返すまで, 各フック関数に引数ARGSを渡して呼び出す.
     `nil'以外が返ってくると最後に呼び出したフック関数の戻り値を返す.

 -- Function: add-hook HOOK FUNCTION &optional APPEND LOCAL
     この関数はフック変数HOOKに関数FUNCTIONを追加する手軽な方法である. 
     引数FUNCTIONは, 正しい個数の引数をとる任意の正しいLisp関数である
     こと.  たとえば,

          (add-hook 'text-mode-hook 'my-text-hook-function)

     は, `text-mode-hook'というフックに`my-text-hook-function'を追加す
     る.

     `add-hook'は, ノーマルフックに加えてアブノーマルフックにも使える.

     フック関数は実行順序に依存しないように設計するのが最良である.  実
     行順序に依存すると『トラブルを呼び込む』ようなものである.  しかし, 
     順序は予測できる.  通常, FUNCTIONはフックリストの先頭に置かれるの
     で, （ほかに`add-hook'の呼び出しがなければ）最初に実行される.  省
     略可能な引数APPENDが`nil'以外であると, 新たなフック関数はフックリ
     ストの末尾に置かれ, 最後に実行される.

     LOCALが`nil'以外であると, 新たなフック関数をカレントバッファにバッ
     ファローカルにすることを意味する.  これを行うまえに, 
     （`make-local-variable'*ではなく*）`make-local-hook'を呼んでフッ
     ク自身をバッファローカルにしておく必要がある.  フック自身がバッファ
     ローカルでないと, LOCALの値は意味を持たない.  フック関数はつねに
     グローバルである.

 -- Function: remove-hook HOOK FUNCTION &optional LOCAL
     この関数は, フック変数HOOKからFUNCTIONを取り除く.

     LOCALが`nil'以外であると, グローバルなフックリストではなくバッファ
     ローカルなフックリストからFUNCTIONを削除することを指定する.  フッ
     ク変数自身がバッファローカルでないと, LOCALの値は意味を持たない.

 -- Function: make-local-hook HOOK
     この関数は, フック変数`hook'をカレントバッファにバッファローカル
     にする.  フック変数がバッファローカルであると, バッファローカルな
     フック関数とグローバルなフック関数を持つことができ, `run-hooks'は
     それらすべてを実行する.

     この関数は, バッファローカルな値の要素を`t'にすることで動作する. 
     これは, バッファローカルな値に加えてフック変数のデフォルト値にあ
     るフック関数を使うことを表すフラグである.  `run-hooks'はこのフラ
     グを理解し, `make-local-hook'はすべてのノーマルフックを処理できる. 
     アブノーマルフックに関しては, `t'の意味を理解するように更新したも
     のだけが処理できる.

     フック変数に対して`make-local-variable'を直接使わないこと.  それ
     だけでは不十分である.


