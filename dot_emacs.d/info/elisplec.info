Info file: hustler.,    -*-Text-*-
produced by `texinfo-format-buffer'
from filebuffer `*--elisplec.tex--temporary-buffer*'
using `texinfmt.el' version 2.42 of  7 Jul 2006.


File: hustler., Node: Top, Next: Writing Major Modes, Prev: (dir), Up: (dir)

* Menu:

* Writing Major Modes::         メジャーモードを書こう
* Construction of Emacs-Lisp::  Emacs-Lisp の構文
* Functions You Must Know::     最低限の関数をおさえる
* Completion Input::            補完入力とその周辺
* Concept Index::
* Function Index::
* Variable Index::

 -- The Detailed Node Listing ---

メジャーモードを書こう

* What is Major Mode?::
* Requirements of a Major Mode::  メジャーモードの必須条件
* Defining Major Mode Functions::  メジャーモード関数の定義
* Exercise 1::                  章末問題 1
* Summary 1::                   まとめ 1
* By-talk 1::

メジャーモードの必須条件

* Setting Mode Names::          モード名の設定
* Setting Keymaps::             キーマップの設定
* Setting Keys::                キーの割当て
* Declaring Local Maps::        ローカルマップ使用宣言

メジャーモード関数の定義

* Interactive Functions::       インタラクティブ関数
* Binding Interactive Functions to Keys::  インタラクティブ関数をキーにバイ
                                           ンドする
* Defining Functions::          関数を実際に定義する

Emacs-Lisp の構文

* Variables::                   変数
* Control Structure::           制御構造
* Arithmetic::                  算術
* Exercise 2::                  章末問題
* By-talk 2::                   余談 2 関数・変数
* By-talk 3::                   余談 3 デバッギング
* By-talk 4::                   余談 4 プログラムの評価

変数

* Declaring Variables::         変数の宣言
* Restricting Variables::       変数の束縛

制御構造

* if::
* or::
* and::
* cond::
* while::
* catch trow::

算術

* Operators::                   演算子
* Arithmetic Functions::        算術関数

最低限の関数をおさえる

* Cursor Motion::               カーソルの移動
* Inserting and Deleting Strings::  文字列挿入/削除
* By-talk 5::                   余談 5 雑関数
* By-talk 6::                   余談 6 Emacs-Lisp のスコープ

カーソル移動

* Relative Motion::             相対移動
* Absolute Motion::             絶対移動
* Motion Boundary Check::       移動境界の検査
* Absolute Motion Summary::     絶対移動関係のまとめ
* Motion by Search::            検索移動
* Search Functions Summary::    検索関数のまとめ
* Saving point Position::       ポイント位置の保存

相対移動

* Character Motion::            char 単位移動
* Word Motion::                 word 単位移動
* Line Motion::                 line 移動

絶対移動

* point::                       ポイント
* Motion by Point::             ポイント移動
* Moving to a Line::            行移動
* Moving to a Column::          桁移動

検索移動

* Lisp Escape Characters::      Lisp エスケープキャラクタ
* String Search::               文字列検索
* Word Search::                 単語検索
* Regular Expression Search::   正規表現検索
* Major Metacharacters::        代表的なメタキャラクタ
* Skipping Characters::         文字(種)スキップ
* Accessing Search Results::    検索結果へのアクセス

検索関数のまとめ

* Exercise 3-1::                練習問題 3-1

文字列挿入/削除

* Inserting Strings::           文字列挿入
* Transforming Types::          文字列と他の型の変換
* Type Transformation::         型変換
* Deleting Strings::            文字列削除
* Replacing Strings::           文字列置換
* Buffer Editing Functions Summary::  バッファ編集関数のまとめ

文字列挿入

* insert-char::                 文字の挿入
* self-insert-command::

文字列と他の型の変換

* format::

型変換

* Getting Strings::             文字列の取込み
* Numerical Transformation::    数値変換
* Strings Transformation::      文字列変換
* String Manipulation Functions::  文字列操作関数

余談 6 Emacs-Lisp のスコープ

* Exercise 3-2::                練習問題 3-2

補完入力とその周辺

* Normal Input Functions::      一般入力関数
* Completion Input Functions::  補完入力関数
* By-talk 7::                   余談 7 マクロ

補完入力関数

* List::                        リスト
* List Structure::              リストの構造
* List Manipulation Functions::  リスト処理関数
* Association Lists::           連想リスト

リスト処理関数

* Creating lists::              リストの作成
* Accessing list Elements::     リストの要素の参照
* Adding Elements to list::     リストの要素の追加
* Appending lists::             リストどうしの結合
* List Related Predicates::     述語関数等

余談 7 マクロ

* Exercise 4-1::                余談練習小問題
* completing-read::
* Variables Controlling Completion::  補完を制御する関数
* try-completion::
* all-completion display-completion-list::




File: hustler., Node: Writing Major Modes, Next: Construction of Emacs-Lisp, Prev: Top, Up: Top

メジャーモードを書こう
**********************


  多くの `Emacs(-Lisp)' 関係の教本の常識を無視して、いきなりここから始
めます。これがもっとも早い道だと信じるからで、事実私もそうしてきました。


* Menu:

* What is Major Mode?::
* Requirements of a Major Mode::  メジャーモードの必須条件
* Defining Major Mode Functions::  メジャーモード関数の定義
* Exercise 1::                  章末問題 1
* Summary 1::                   まとめ 1
* By-talk 1::




File: hustler., Node: What is Major Mode?, Next: Requirements of a Major Mode, Prev: Writing Major Modes, Up: Writing Major Modes

メジャーモードってなに
======================

  多くの `Emacs-Lisp' プログラマがで最終的に目指す目標の一つが、「メ
ジャーモードが書けるようになる」ことでしょう。メジャーモードとは、例え
ば `c-mode' のように対象となるテキストの種別に適した、もっと言うと「専
用の」編集モードの事を指します。

  `GNU Emacs' では、編集ファイルのファイル名のパターンと、そのファイル
を編集する時に用いるメジャーモードを決定するものとして、変数
`auto-mode-alist' を使用しています。これは今まで、いろいろなパッケージ
をインストールしたことのある人なら、設定したことがあるでしょうから、詳
しい構造などについては述べません。




File: hustler., Node: Requirements of a Major Mode, Next: Defining Major Mode Functions, Prev: What is Major Mode?, Up: Writing Major Modes

メジャーモードの必須条件
========================

  では、早速メジャーモードを書いてみましょう。その前に、メジャーモード
の備えているべき最低限の条件について整理してみましょう。

   * モード名を設定する。
   * 使用するキーマップを設定する。
   * 必要な変数を設定する。

たったこれだけなのです。

* Menu:

* Setting Mode Names::          モード名の設定
* Setting Keymaps::             キーマップの設定
* Setting Keys::                キーの割当て
* Declaring Local Maps::        ローカルマップ使用宣言




File: hustler., Node: Setting Mode Names, Next: Setting Keymaps, Prev: Requirements of a Major Mode, Up: Requirements of a Major Mode

モード名の設定
--------------

  モード名は、変数 `major-mode' にシンボルとして入れます。

     (setq major-mode 'my-mode)

  ついでに、モードラインのモード名フィールドも変えましょう。これは、変数
`mode-name' に文字列で設定します。

     (setq mode-name "MY mode")

  どちらも、今から書こうとするモードの名前を設定します。好きな名前で構
いません。




File: hustler., Node: Setting Keymaps, Next: Setting Keys, Prev: Setting Mode Names, Up: Requirements of a Major Mode

キーマップの設定
----------------

  「どのキーを押した時に、どの機能を呼び出すか」という対応表のことを
`Emacs' ではキーマップと言います。`C-n', `C-p' など、どのモードでもほぼ
共通で使えるキーバインドはグローバルマップに、モードに固有のキーバイン
ドは、ローカルマップに設定します。通常グローバルマップは変数
`global-map' を*常に*使用します。(*Note setting global-map: Binding
Interactive Functions to Keys.)

  メジャーモードが固有のキーバインドを使用する場合、独自のローカルマッ
プを作成し、そのローカルマップを使用する宣言をしなければなりません。ロー
カルマップを作成するには次のようにします。この例では変数
`my-local-map' をローカルマップとしています。

     (setq my-local-map (make-keymap)) これで、`my-local-map' というロー
カルマップが作成できました。あとは、このマップに必要なキーバインドを定
義して行くだけです。




File: hustler., Node: Setting Keys, Next: Declaring Local Maps, Prev: Setting Keymaps, Up: Requirements of a Major Mode

キーの割当て
------------

  ローカルマップにキーを割当てるには、関数 `define-key' を使用します。
`define-key' は引数を三つ取り、順に、キーマップ、割当キー(文字列)、機能
(シンボル)となっています。では `vi' のように `hjkl' に左下上右を割当て
てみましょう。

     (define-key my-local-map "h" 'backward-char)
     (define-key my-local-map "j" 'previous-line)
     (define-key my-local-map "k" 'next-line)
     (define-key my-local-map "l" 'forward-char)




File: hustler., Node: Declaring Local Maps, Prev: Setting Keys, Up: Requirements of a Major Mode

ローカルマップ使用宣言
----------------------

  では、今 `my-local-map' に割当てたバインド有効となるように、ローカル
マップの使用宣言をします。

     (use-local-map my-local-map) これで、カレントバッファで `hjkl' が
有効になります。




File: hustler., Node: Defining Major Mode Functions, Next: Exercise 1, Prev: Requirements of a Major Mode, Up: Writing Major Modes

メジャーモード関数の定義
========================

* Menu:

* Interactive Functions::       インタラクティブ関数
* Binding Interactive Functions to Keys::  インタラクティブ関数をキーにバイ
                                           ンドする
* Defining Functions::          関数を実際に定義する




File: hustler., Node: Interactive Functions, Next: Binding Interactive Functions to Keys, Prev: Defining Major Mode Functions, Up: Defining Major Mode Functions

インタラクティブ関数
--------------------

  メジャーモードを起動する関数を定義する前に インタラクティブ関数につい
て知っておきましょう。`Emacs-Lisp' の関数には、インタラクティブ関数と、
そうでない関数があります。`C-n' や `M-x gnus' のようにキーボード操作で
直接呼び出すことができる関数をインタラクティブ関数と言います。それ以外
の関数は、ユーザが直接呼び出すことはできず、様々な処理の下請関数として
だけ呼ばれます。`C-f' にバインドされている `forward-char' ももちろんイ
ンタラクティブ関数となっています。

  メジャーモードの核となる関数は、当然インタラクティブ関数にしなければ
なりませんから、関数定義は次のような形になります。

     (defun my-mode ()
       (interactive)
       モード名の設定
       キーマップの設定
     )

今のところは、「関数定義の先頭におまじない `(interactive)' を入れる」と
覚えておいて下さい。(*Note defun: By-talk 2.)




File: hustler., Node: Binding Interactive Functions to Keys, Next: Defining Functions, Prev: Interactive Functions, Up: Defining Major Mode Functions

インタラクティブ関数をキーにバインドする
----------------------------------------

  簡単なインタラクティブ関数を定義して、実際にキーに割当ててみましょう。
バッファに `Hello, world!' とだけ表示する関数は次のようになります。

     (defun hello-word ()
       (interactive)
       (insert "Hello, world!\n"))

すぐに試してみたいので、グローバルマップにキー割当してしまいましょう。

     (define-key global-map "\C-ch" 'hello-world)

これで、`C-ch' を押すとバッファに `hello, world!' が挿入されます。




File: hustler., Node: Defining Functions, Prev: Binding Interactive Functions to Keys, Up: Defining Major Mode Functions

関数を実際に定義する
--------------------

  ここまでで、必要最低限の知識は全て揃いました。次のようなメジャーモー
ドが作成できるはずです。

   * `my-mode' という名前のメジャーモードである。
   * `hjkl' でカーソル移動することができる。
   * `C-ch' を押すと `Hello, world!' が入力できる。

実際の関数定義は、次のようになります。


     (defun my-mode ()
       (interactive)
       (setq major-mode 'my-mode
         mode-name "MY mode")
       (setq my-local-map (make-keymap))
       (define-key my-local-map "h" 'backward-char)
       (define-key my-local-map "j" 'previous-line)
       (define-key my-local-map "k" 'next-line)
       (define-key my-local-map "l" 'forward-char)
       (define-key my-local-map "\C-ch" 'hello-world)
       (use-local-map my-local-map))

     (defun hello-world ()
       (interactive)
       (insert "Hello, world!\n"))





File: hustler., Node: Exercise 1, Next: Summary 1, Prev: Defining Major Mode Functions, Up: Writing Major Modes

章末問題 1
==========

問 1-1 `a-z' どのキーを押しても、「僕るねえもんナリよ」が挿入され
     る「るねきちモード」を作りなさい。

答の提出をもって、参加表明とみなします。よろしゅうに


あっという間に宿題を提出した優秀な人へ追加問題。

問1-2 `a-z' を押すと、対応するアルファベットで、「僕luneえもんAな
     りよ」〜「僕luneえもんZなりよ」と、文字列の入る `luneえもんモード'
     を作成せよ。

暇な人だけ解いて下さい。




File: hustler., Node: Summary 1, Next: By-talk 1, Prev: Exercise 1, Up: Writing Major Modes

まとめ 1
========

  大事なことを書き忘れたかもしれない。面倒なので、これは junk風の書き方
で許して。

   * `Emacs-Lisp' プログラムは、`.el' という拡張子のファイルにする。
   * ファイルの先頭に `;-*- Emacs-Lisp -*-' と入れる。
   * `defun' した関数を評価するには、その関数にカーソルを合わせて `ESC
     C-x' する。すると即座に呼び出せる。
   * 括弧を一つだけ評価したい時には、閉じ括弧の右にカーソルをおいて
     `M-x eval-last-sexp'

                   --- ここまで Emacs-Lisp mode ---


   * 簡単な `Lisp' 式(S式と言う)をすぐに実行(評価と言う)するには
     `*scratch*' バッファを利用する。
   * `*scratch*' バッファで何かS式を書いたら閉じ括弧の右で `C-j' を押す
     とすぐに評価されて結果が `*scratch*' バッファに入る。

  これだけ知ってれば、あなたも今日から `Emacs-Lisp' プログラマ。では
good luck!




File: hustler., Node: By-talk 1, Prev: Summary 1, Up: Writing Major Modes

余談 1 「〜関係の関数はないかな?」を探す。
==========================================

  関数を探す時に使うと便利なのが、`apropos' です。`M-x apropos' で出て
来るプロンプトで、関数名の正規表現を入力します。何か文字列操作のための
関数を探したかったら、

     M-x apr
     Apropos: string

などと問い合わせると良いでしょう。正規表現での指定なので、`string' で始
まる関数を調べたかったら、`^string'という検索していも可能です。

ですから、今回の場合は、

     M-x apr
     Apropos: ^....-.......-....$

で、検索すれば良かったということになります。





File: hustler., Node: Construction of Emacs-Lisp, Next: Functions You Must Know, Prev: Writing Major Modes, Up: Top

Emacs-Lisp の構文
*****************


  本章では、`Lisp' 言語とみた場合の変数の扱いや、制御構造の表現の仕方に
ついて簡単に触れます。

* Menu:

* Variables::                   変数
* Control Structure::           制御構造
* Arithmetic::                  算術
* Exercise 2::                  章末問題
* By-talk 2::                   余談 2 関数・変数
* By-talk 3::                   余談 3 デバッギング
* By-talk 4::                   余談 4 プログラムの評価




File: hustler., Node: Variables, Next: Control Structure, Prev: Construction of Emacs-Lisp, Up: Construction of Emacs-Lisp

変数
====

  `Lisp' では変数は一つのシンボルとして存在しています。シンボルへの値の
代入は `set' によって行います。シンボル `foo' へ、値5を代入するには、

     (set 'foo 5)

としますが、一般的にはこれと等価な、

     (setq foo 5)

という書式を用います。`setq' は値の代入なので、常に変数の値は更新されま
す。

* Menu:

* Declaring Variables::         変数の宣言
* Restricting Variables::       変数の束縛



File: hustler., Node: Declaring Variables, Next: Restricting Variables, Prev: Variables, Up: Variables

変数の宣言
----------

  `defvar' は `setq' とは異なり変数の宣言のみを行います。書式は

     (defvar   シンボル 初期値 ドキュメンテーション文字列)

となっています。もし第一引数のシンボルが既に存在していた場合はその値は
変更しません。このため、`Emacs-Lisp' プログラムで使用するカスタマイズ可
能な変数のデフォルト値の設定をするためによく使われます。



File: hustler., Node: Restricting Variables, Prev: Declaring Variables, Up: Variables

変数の束縛
----------

  `Emacs' では多くの `Emacs-Lisp' プログラムが動作するため、シンボル名
の衝突は確実に回避しなければなりません。関数の内外にかかわらず単純に
`setq' や `defvar' されたシンボルはすべてグローバル変数になってしまうの
で他のプログラムの存在を考えると好ましくありません。そこで変数の有効範
囲(スコープ)を制限するために `let' を用います。

     (let (変数リスト) 実行部...)

「変数リスト」の部分は「変数名」または「(変数名 初期値)」の任意の個数の
並びです。変数名だけ指定するとその変数の値は `nil' にセットされます。次
の例は変数 `case-fold-search' を `t' にセットしてインクリメンタルサーチ
を呼び出します。

     (let ((case-fold-search t))
       (isearch-forward))

`case-fold-search' は検索の時に大文字小文字を区別しないというフラグで、
グローバル変数となっています。`let' はグローバル変数の値を一時的に変更
するためにも利用できます。

しかしカスタマイズ変数などはグローバルに値を保持する必要があるので、グ
ローバル変数はやはり必要です。さらに、関数名はすべてグローバルシンボル
として扱われます。そこで、グローバルシンボルを使用する時には、「すべて
のグローバルシンボルには作成パッケージ固有の接頭辞をつける」ことが強く
勧められています。例えば `supercite' パッケージで用いるシンボルには全て
`sc-' という接頭辞がついています。




File: hustler., Node: Control Structure, Next: Arithmetic, Prev: Variables, Up: Construction of Emacs-Lisp

制御構造
========

`Emacs-Lisp' で主に用いる制御構造を説明します。

* Menu:

* if::
* or::
* and::
* cond::
* while::
* catch trow::



File: hustler., Node: if, Next: or, Prev: Control Structure, Up: Control Structure

if
--

  `if' は第一引数を評価し、それが `nil' でない値(今後 `non-nil')を返し
た場合第二引数を評価しその値を返し、`nil' だった場合第三引数以降を (も
しあれば)評価し、最後の値を返します。

     (if CONDITION T-body Else-body...)

もし、条件が `non-nil' の時に評価したい関数が複数ある場合は、
`progn' を用いて次のようにします。

     (if CONDITION (progn T-body...) Else-body...)

`progn' は任意個の引数を取り、最後の引数の値を `progn' の値として返しま
す。




File: hustler., Node: or, Next: and, Prev: if, Up: Control Structure

or
--

  `or' は与えられた引数全てを順に評価し、`non-nil' を返すものがあった場
合、それを `or' の返す値とします。もしすべての引数を評価したものが
`nil' だった場合、`or' は `nil' を返します。

  ある変数の値が `t' の時に動作が禁止される関数などは次のように表現しま
す。

     (or foo-key-map (setq foo-key-map (make-key-map)))

また、`or' のもつ「または」という意味で、次のように使うこともできます。

     (if (or A B) 処理)




File: hustler., Node: and, Next: cond, Prev: or, Up: Control Structure

and
---

  `and' は与えられた引数を順に評価し、`nil' を返すものが見つかったら直
ちに `nil' を返します。最後の引数まで `non-nil' を返した場合、`and' は
最後の引数の値を返します。




File: hustler., Node: cond, Next: while, Prev: and, Up: Control Structure

cond
----

  `cond' は次の書式によります。

     (cond
      (式1  式1がnon-nilの時に返す式...)
      (式2  式2がnon-nilの時に返す式...)
         :
      (式n  式nがnon-nilの時に返す式...))


  次の例は、変数 `var-a', 変数 `var-b', 関数 `func-c' の値を順次調べて、
どれかが `non-nil' の時に後続する関数群を評価します。もし、`var-a',
`var-b', `func-c' のどれも `nil' を返す時は、最後の条件ブロックの式が
`t' なので最後のブロックを評価します。

     (cond
      (var-a     (message "A!"))
      (var-b     (insert  "B!"))
      ((func-c)  (insert  "C"))
      (t     (message "NO!") (ding)))

なお、`cond' は途中の条件式が `non-nil' を返し後続するブロックを評価し
たら、残りの条件ブロックは評価せずに抜けてしまいます。 `cond' の返す値
は、(`non-nil' を返した)条件ブロックの最後の式が返す値です。




File: hustler., Node: while, Next: catch trow, Prev: cond, Up: Control Structure

while
-----

  最初の条件式が `non-nil' である間、二番目以降の引数をくり返し評価しま
す。

     (while 条件式 実行部...)

  これはループを形成する時に用いることができます。C の `for' または
`while' のような繰り返しを行う時は、通常 `let' と組み合わせて次のように
用います。

     (let ((i ?a))
       (while (<= i ?z)
         (insert i)
         (setq i (1+ i))))

上の例は、`a〜z' をバッファ中に挿入します。この例から想像が付くように、
`Emacs-Lisp' では文字コードを `?文字' で表現します。`?a' は
`a' の文字コードを示すので、97 と等価です。

  `while' は常に `nil' を返します(最後は条件式が `nil' となって終了する
から)。




File: hustler., Node: catch trow, Prev: while, Up: Control Structure

catch, throw
------------

  `catch' と `throw' は対にして使います。`catch' の書式を見ると、

     (catch タグ 実行部...)

となっていて、「実行部...」のいずれかで「タグ」が `throw' されると直ち
に `catch' を抜けます。`throw' は

     (throw タグ 値)

のように使用し、この時の `catch' の返す値は第二引数の「値」となります。
もし「実行部...」で「タグ」が `throw' されなかった時は「実行部
...」の最後の値が `catch' の返す値となります。

  この関数のペアは、終了のタイミングの予測できないループを表現する時に
使うと便利です。例えば、バッファ末までに判定関数 `foo' を満足する行があ
るか調べる場合を考えます。`catch', `throw' を使わずに書く場合は次のよう
になるでしょう。

     (let (found)        ;局所フラグ nil 初期値
       (while (and (not found)(not eobp))
         (if (foo) (setq found t)
           (forward-line 1)))
       (if found
           見つかった場合の処理
         見つからなかった場合の処理))

ループが回る毎にフラグ `found' が `t' でないことを調べているので、少々
無駄な気がします。これを `catch', `throw' を使って書き直すと、

     (if (catch 'found
           (while (not eobp)
         (if (foo) (throw 'found t)
           (forward-line 1))))
         見つかった場合の処理
       見つからなかった場合の処理)

となります。もし `(foo)' が `non-nil' を返す行があった場合はループ内部
で `'found' が `throw' されるので、`catch' 関数の値は `'found' となり最
も外側の `if' は見つかった場合の処理を評価します。逆に、 `foo' を満たす
行が見つからなかった場合、内部の `while' が `nil' を返して終了するため、
外側の `if' も、見つからなかった場合の処理を評価します。




File: hustler., Node: Arithmetic, Next: Exercise 2, Prev: Control Structure, Up: Construction of Emacs-Lisp

算術
====

* Menu:

* Operators::                   演算子
* Arithmetic Functions::        算術関数



File: hustler., Node: Operators, Next: Arithmetic Functions, Prev: Arithmetic, Up: Arithmetic

演算子
------

  `Emacs-Lisp' で使える演算子には以下のものがあります。

`%, *, +, -, /'
     剰余, 乗算, 加算, 減算, 除算
`1+, 1-'
     1加算, 1減算
`<, <=, =, /=, >, >='
     比較演算子(/=は≠)

`Lisp' では `*', `+', `-' は複数のオペランドを取ることができます。`-'
は引数が一つの時はその符号を反転し、二つ以上の時は一つ目の引数から残り
の引数全てを引きます。

また次の述語関数も必要でしょう。

`numberp(integerp)'
     数値なら `t' を返す

独自に定義した関数で受け取った引数が数値かどうか判定する時などに利用し
ます。




File: hustler., Node: Arithmetic Functions, Prev: Operators, Up: Arithmetic

算術関数
--------

  利用頻度が高いと思われるものだけ紹介します。

`max, min'
     引数のうち(最大,最小)のものを返す
`random'
     24bits長の擬似乱数を返す引数として`t' を与えると乱数の種を変えて値
     を返す




File: hustler., Node: Exercise 2, Next: By-talk 2, Prev: Arithmetic, Up: Construction of Emacs-Lisp

章末問題 2
==========

問

     前問「るねきちモード」の `a-z' のキーバインドのうち、どれか一つの
     キーを押すと「自爆」と言ってバッファを消去する機能を付け加えよ。

     ヒント: char-to-string, ding, message, erase-buffer




File: hustler., Node: By-talk 2, Next: By-talk 3, Prev: Exercise 2, Up: Construction of Emacs-Lisp

余談 2 関数・変数
=================

基本的なことですが、変数は

     var

と、単体で参照し、関数は

     (func args...)

と括弧つきの形で参照します。

  `defun' の形は次のようになっています。

     (defun 関数名 (引数リスト) 関数定義)

引数に何もとらない時は空リストにして

     (defun 関数名 () 関数定義)

とします。

  さて、`Emacs-Lisp' の場合関数は必ず値を返します。関数の値は、その関数
中で最後に評価されたものの値となります。例えば次の関数の返り値は5となり
ます。

     (defun foo () 5)

したがって次の例では、変数 `bar' に値5が返ることとなります。

     (setq bar (foo))

関数の返す値は、「最後に評価されたもの」であり「最後に書いてある式の値」
ではないので注意して下さい。

     (defun baz (arg)
       (if (< arg 0) (- arg) arg))

という例では、引数 `arg' が負の場合 `(- arg)' が、正の場合
`arg' が `baz' の返り値となります。




File: hustler., Node: By-talk 3, Next: By-talk 4, Prev: By-talk 2, Up: Construction of Emacs-Lisp

余談 3 デバッギング
===================

  変数の値を途中で表示させたい時には `message' 関数を使うと便利です。
`message' 関数は C の `printf' のようなフォーマットが使えます。例えば、
途中で変数 `foo' の値を見たい時は

     (message "foo = %d" foo)

とします。もし、次の `message' などがすぐに出てしまい読み取れない時など
は、`sit-for' 関数を使ってn秒間止まらせると良いでしょう。

     (message "foo = %d" foo)
     (sit-for 2)     ;2秒間停止
         :
     (message "bar = %d" bar)



File: hustler., Node: By-talk 4, Prev: By-talk 3, Up: Construction of Emacs-Lisp

余談 4 プログラムの評価
=======================

  `defun' した関数を評価する時は、`ESC C-x' を使うのが良いでしょう。こ
の時関数を定義したらその場で `ESC C-x' をしてしまいましょう。するとその
間数名は以後どの場所でも、`ESC TAB' によって補完することが可能になりま
す(変数名も同様)。

     (defun lune-random ()
       なんちゃらかんちゃら)
     (defun lune-mode ()
       (interactive)
       (setq key lun

というところで、`ESC TAB' を押すと、`lune-random' が補完されます。

  さて出来上がった関数を評価する時は主に二つの方法が考えられます。

  1. `ESC ESC' で関数を評価するS式を入れる。
  2. `*scratch*' バッファに移ってS式を入れて `C-j' する。

上の `lune-random' 関数を試したい時は、

  1. ESC ESC
         `Eval: (lune-random) RET'
  2. `*scratch*'バッファに移動
         `(lune-random) C-j'

(2)の場合、`C-j' を押す直前のS式が評価されます。したがって、

     (setq random (lune-random))
                              ~~

の、最後の括弧の上で `C-j' を押すと `(lune-random)' だけが評価され
`setq' されず、行末で `C-j' を押すと `setq' 全体が評価されます。




File: hustler., Node: Functions You Must Know, Next: Completion Input, Prev: Construction of Emacs-Lisp, Up: Top

最低限の関数をおさえる
**********************

  どんなメジャーモードでも書けるようになるために、必要最低限の関数を一
気に覚えてしまいましょう。ここでとり上げる必要最低限のコマンドは以下の
ものです。

   * カーソル移動(検索)
   * 文字列挿入/削除

* Menu:

* Cursor Motion::               カーソルの移動
* Inserting and Deleting Strings::  文字列挿入/削除
* By-talk 5::                   余談 5 雑関数
* By-talk 6::                   余談 6 Emacs-Lisp のスコープ



File: hustler., Node: Cursor Motion, Next: Inserting and Deleting Strings, Prev: Functions You Must Know, Up: Functions You Must Know

カーソル移動
============

  カーソルの移動コマンドには、相対移動、絶対移動、検索移動があります。
いずれもキーに割当てられている機能なので、関数名を知っているものもある
でしょう。

* Menu:

* Relative Motion::             相対移動
* Absolute Motion::             絶対移動
* Motion Boundary Check::       移動境界の検査
* Absolute Motion Summary::     絶対移動関係のまとめ
* Motion by Search::            検索移動
* Search Functions Summary::    検索関数のまとめ
* Saving point Position::       ポイント位置の保存



File: hustler., Node: Relative Motion, Next: Absolute Motion, Prev: Cursor Motion, Up: Cursor Motion

相対移動
--------

  `Emacs-Lisp' プログラムではあまり用いることのない関数ですが、各関数と
引数について説明します。

* Menu:

* Character Motion::            char 単位移動
* Word Motion::                 word 単位移動
* Line Motion::                 line 移動



File: hustler., Node: Character Motion, Next: Word Motion, Prev: Relative Motion, Up: Relative Motion

char 単位移動
.............

  `forward-char', `backward-char' どちらも引数を一つ取り、移動桁数を決
定します。前に3つ進みたい時は、`(forward-char 3)' のように呼び出します。
もちろんこれらの関数は、`C-f', `C-b' にバインドされています。




File: hustler., Node: Word Motion, Next: Line Motion, Prev: Character Motion, Up: Relative Motion

word 単位移動
.............

  `forward-word', `backward-word' も移動単語数を指定する引数を一つ取り
ます。`M-f', `M-b' にバインドされています。




File: hustler., Node: Line Motion, Prev: Word Motion, Up: Relative Motion

line 移動
.........

  行移動というと、`C-n', `C-p' にバインドされている `next-line',
`previous-line' を想像すると思いますが、これらの関数は `Emacs-Lisp' プ
ログラム中で用いません。これらの関数には `goal-column' の制御などの機能
が含まれるため、プログラム中からはより単純で信頼性の高い
`forward-line' を使用します。なお、 `backward-line' という関数はないの
で、上に移動するには負の引数を渡します。




File: hustler., Node: Absolute Motion, Next: Motion Boundary Check, Prev: Relative Motion, Up: Cursor Motion

絶対移動
--------

* Menu:

* point::                       ポイント
* Motion by Point::             ポイント移動
* Moving to a Line::            行移動
* Moving to a Column::          桁移動



File: hustler., Node: point, Next: Motion by Point, Prev: Absolute Motion, Up: Absolute Motion

ポイント
........

  カーソルの絶対移動の基準となる「ポイント」について知っておく必要があ
ります。`Emacs' ではカーソルの位置をバッファの先頭からのオフセットで管
理しています。このオフセット値を返す関数が `(point)' です。これに関連し
て、バッファの先頭は `(point-min)'、末尾は `(point-max)' で得ることがで
きます。




File: hustler., Node: Motion by Point, Next: Moving to a Line, Prev: point, Up: Absolute Motion

ポイント移動
............

  指定するポイント位置に移動する関数が `goto-char' です。引数を一つ取り、
移動先のポイントを受け取ります。バッファの先頭に移動するには次のように
します。

     (goto-char (point-min))

  なお、バッファの先頭にジャンプする `M-<' の関数名を知っている人は
「`(beginning-of-buffer)' でもいいんでしょ?」と思われるかもしれませんが、
これと `(end-of-buffer)' は特別な理由のない限り、 `Emacs-Lisp' プログラ
ム中から利用してはいけません。これは、マーク位置を変更してしまうため、
ユーザに思わぬ動作を起こさせる可能性があるからです。




File: hustler., Node: Moving to a Line, Next: Moving to a Column, Prev: Motion by Point, Up: Absolute Motion

行移動
......

  n行目に移動する関数として、`goto-line' があります。行番号引数として渡
します。なお、バッファの先頭は1行目と数えます。逆に、現在の行番号を得る
には次のようにします。

     (count-lines (point-min) (point))




File: hustler., Node: Moving to a Column, Prev: Moving to a Line, Up: Absolute Motion

桁移動
......

  n桁目に移動する関数は `move-to-column' で、0から始まる桁数を引数とし
て渡します。現在の桁数は `(current-column)' で得ることができます。

  また、行頭/行末への移動関数は、`beginning-of-line',
`end-of-line' です。この二つは比較的よく使われます。




File: hustler., Node: Motion Boundary Check, Next: Absolute Motion Summary, Prev: Absolute Motion, Up: Cursor Motion

移動境界の検査
--------------

  相対移動絶対移動共に現在のポイント位置が移動できる終端まで来たかどう
かのチェックをする必要がある場合があります。ポイント位置がバッファ中の
特定の位置にあるかどうかを検査する関数には以下のものがあります。

`(bobp) / (eobp)'
     バッファ先頭/末尾
`(bolp) / (eolp)'
     行頭/行末

関数 `bobp/eobp' は現在のポイント位置がバッファ先頭/末尾なら真(t) を、
そうでなければ偽(nil)を返します。バッファ末に達するまでなにかの処理を繰
り返すというケースはしばしば必要になります。次のような形で書けるでしょ
う。

     (while (not (eobp)) ;(while 条件式 処理1...処理n)
       処理
       (forward-line 1))




File: hustler., Node: Absolute Motion Summary, Next: Motion by Search, Prev: Motion Boundary Check, Up: Cursor Motion

絶対移動関係のまとめ
--------------------

ここまでに出てきた関数をまとめましょう。

         ・ポイント値を返す関数  point, point-min, point-max
         ・移動関数              forward-char, backward-char
                                 forward-word, backward-word
                                 forward-line
                                 goto-char, goto-line
                                 move-to-column
                                 beginning-of-line, end-of-line
         ・位置に関する述語関数  bobp, eobp, bolp, eolp




File: hustler., Node: Motion by Search, Next: Search Functions Summary, Prev: Absolute Motion Summary, Up: Cursor Motion

検索移動
--------

  プログラム中でカーソル位置を決定するのに最も頻繁に使用するのが検索で
す。ここは必ず押さえましょう。

  検索は大別して、

   * 増分検索(インクリメンタルサーチ)
   * 文字列検索
   * 単語検索
   * 正規表現検索
   * 文字(種)スキップ

に分けられます(分けます)。これらのうち、インクリメンタルサーチは対話的
に用いることを前提としているため、`Emacs-Lisp' プログラム中からは滅多に
利用することはないでしょう。これ以外のものの利用の仕方を説明します。

* Menu:

* Lisp Escape Characters::      Lisp エスケープキャラクタ
* String Search::               文字列検索
* Word Search::                 単語検索
* Regular Expression Search::   正規表現検索
* Major Metacharacters::        代表的なメタキャラクタ
* Skipping Characters::         文字(種)スキップ
* Accessing Search Results::    検索結果へのアクセス



File: hustler., Node: Lisp Escape Characters, Next: String Search, Prev: Motion by Search, Up: Motion by Search

Lisp エスケープキャラクタ
.........................

  検索関数には検索したいパターンを文字列として渡すわけですが、その文字
列中に `\' を含む場合は注意が必要です。`\' は `Emacs-Lisp' で扱う文字列
中で特別な意味を持つエスケープキャラクタとなっています。 C言語の文字列
中で使う `\n' のような働きを持っています。主なシーケンスには次のものが
あります。

`\\'
     \自身
`\C-英字'
     コントロールコード(`\^英字' も可)
`\e'
     ESC(1Bh)
`\"'
     "
`\n'
     改行文字(LF)
`\r'
     復帰文字(CR)
`\a'
     ベル(C-g)
`\b'
     バックスペース(C-h)
`\f'
     改頁文字(C-l)
`\t'
     タブコード(C-i)

  Cを扱ったことのある人は「`\\' とかなら慣れてるから平気」と思われるか
もしれません。しかし、正規表現の検索パターンを指定する場合には、正規表
現での `\' エスケープと、`Lisp' の `\' エスケープが重なってしまうので非
常に繁雑です。正規表現検索で、`\' 自身を探すにはパターン文字列として、
`\\\\'を指定することになります。

  このような注意点があることだけを念頭において検索関数の理解に進みましょ
う。




File: hustler., Node: String Search, Next: Word Search, Prev: Lisp Escape Characters, Up: Motion by Search

文字列検索
..........

  探したい文字列がはっきりとわかっている場合には普通の文字列検索である
`search-forward', `search-backward' を利用します。これらの関数は引数を
一つから四つ取ります(二つ目以降は省略可)。

     (search-forward 文字列 範囲 エラー処理 繰り返し回数)

各引数について説明します。

`1.文字列'
     検索したい文字列.
`2.範囲'
     どこまで検索するかをポイント位置で指定する. バッファ末までの時は
     nil を指定する.
`3.エラー処理'
     見つからなかった場合の処理を指定.  エラーを発生して欲しい時は
     `nil' を、単に `nil' を返して欲しい時は `t' を、検索範囲末まで移動
     して欲しい時は `nil', `t' 以外を渡す.
`4.繰り返し回数'
     この引数で指定した回数だけ検索を繰り返す.

後述する正規表現検索も同数の引数を取りますが引数の意味として違うのは、
第一引数だけです。もちろん正規表現検索関数の第一引数は正規表現のパター
ン文字列を指定します。

  `search-forward/backward' を用いた典型的な処理形態は次のようになりま
す。

     (if (search-forward "文字列" nil t)
         (progn 見つかった場合の処理)
       見つからなった場合の処理)




File: hustler., Node: Word Search, Next: Regular Expression Search, Prev: String Search, Up: Motion by Search

単語検索
........

  `TeX' を検索する時に `LaTeX' にはマッチして欲しくない時のように、単語
単位での検索に有効なのが `word-search-forward(backward)' です。引数は
`search-forward' の第一引数を単語に置き換えたものです。



File: hustler., Node: Regular Expression Search, Next: Major Metacharacters, Prev: Word Search, Up: Motion by Search

正規表現検索
............

  `re-search-forward', `re-search-backward' がおそらく最もよく用いる検
索関数となるでしょう。第一引数に検索したい正規表現パターンを指定します。
`Emacs-Lisp' で扱える正規表現全てについてはほかの解説書に譲ります。ここ
では必要最低限のものに絞ってメタキャラクタの説明をします。




File: hustler., Node: Major Metacharacters, Next: Skipping Characters, Prev: Regular Expression Search, Up: Motion by Search

代表的なメタキャラクタ
......................

`.'
     任意の一文字にマッチ
`*'
     直前の正規表現の0回以上の繰り返し
`+'
     直前の正規表現の1回以上の繰り返し
`?'
     直前の正規表現の0回か1回の繰り返し
`^'
     行頭にマッチ
`$'
     行末にマッチ
`[文字リスト]'
     「文字リスト」のうち一文字にマッチ
`[^文字リスト]'
     「文字リスト」にないものにマッチ
`[X-Y]'
     ASCIIコードが「X」のものから「Y」のものどれかにマッチ
`[-^A-Z]'
     「-」か「^」か「A〜Zのうちどれか」

これだけ覚えておけば、ほとんどの検索が可能です。なお、正規表現の検索と
組み合わせた処理は極めて重要なので、別に節を設けて解説します。




File: hustler., Node: Skipping Characters, Next: Accessing Search Results, Prev: Major Metacharacters, Up: Motion by Search

文字(種)スキップ
................

  単語の先頭にポイントが位置する時に、単語末までポイントを移動したい、
あるいはその逆のことをしたい時などに `skip-chars-forward',
`skip-chars-backward' が利用できます。これらの関数は一つまたは二つの引
数を取ります。

     (skip-chars-forward スキップ文字リスト スキップ境界)

             1.スキップ文字リスト    正規表現の[]の中味と同様に指定し
                                     ます。
             2.スキップ境界          文字スキップを行う境界をポイント
                                     値で指定します。これを越えてポイ
                                     ントが進むことはありません。

  英単語の先頭にポイントがある時に、単語末までポイントを移動するには次
のようにします。

     (skip-chars-forward "A-Za-z")




File: hustler., Node: Accessing Search Results, Prev: Skipping Characters, Up: Motion by Search

検索結果へのアクセス
....................

  次の例で `def' を検索した場合の検索後のポイント位置は

     abc def ghi
         ~  ~

前方向検索の時は `def' の次の位置、後ろ方向検索の時は `d' の位置になり
ます。これはインクリメンタルサーチなどを前後方向で行った場合のカーソル
位置と同じなので、容易に想像がつくことでしょう。

  しかし、検索がマッチした部分をアクセスする時に、検索後のポイント位置
を当てにしていたのでは、検索方向によって場合分けしなければならないので
通常はこれを利用しません。検索のマッチ部分を取得する関数が
`match-beginning', `match-end' です。上記の例の、マッチ部分の始まり(dの
位置)と、終わり(f の次の位置)はそれぞれ、

     (match-beginning 0)
     (match-end 0)

で得ることができます。どちらも引数として数値である0を渡しています。実は
この部分は、正規表現にグループを用いた場合のグループ番号を意味していて、
0 は「マッチした部分全体」という特殊な意味を持っています。例えば上記の
例を次の正規表現で検索した場合を考えてみましょう。

     (re-search-forward
       "\\(a.*\\) *\\(d.*\\) *\\(g.*\\)" nil t)

`Emacs' の正規表現のグルーピングは `\(グループ\)' で行いますが、
`Emacs-Lisp' で `\' を正規表現関数に渡すためには `\\' と表記しなければ
ならないことに注意して下さい。さて、この正規表現の意味は、

     ・`a'で始まる任意の文字列(これをグループ1とする)のあとに
       `d'で始まる任意の文字列(これをグループ2とする)と
       `g'で始まる任意の文字列(これをグループ3とする)が続く

となります。




File: hustler., Node: Search Functions Summary, Next: Saving point Position, Prev: Motion by Search, Up: Cursor Motion

検索関数のまとめ
----------------

     ・検索関数          search-forward, search-backward
                         word-search-forward, word-search-backward
                         re-search-forward, re-search-backward
     ・文字スキップ      skip-chars-forward, skip-chars-backward
     ・検索結果位置取得  match-beginning, match-end

* Menu:

* Exercise 3-1::                練習問題 3-1




File: hustler., Node: Exercise 3-1, Prev: Search Functions Summary, Up: Search Functions Summary

練習問題 3-1
............

問
       先のるねきちモードにおいて、`a' を押した時に既にバッファ中に存在す
     る「僕るねえもん `A_n' なりよ」を数え、その数に応じて「僕るねえもん
     `A_(n+1)' なりよ」を挿入する用に書き換えよ。

       すなわち、`b' を押した時にバッファ中に「僕るねえもん `B' なりよ」
     がいた場合は「僕るねえもん `B2' なりよ」を、`c' を押した時にバッファ
     中に「僕るねえもん `C' なりよ」、「僕るねえもん `C2' なりよ」、…、
     「僕るねえもん `C10' なりよ」がいた場合は「僕るねえもん `C11' なり
     よ」を挿入する。

     ヒント:
             point, re-search-*ward, \\(\\), buffer-substring
             match-beginning, match-end, string-to-int

         ・全てのマッチする文字列に対して処理

             現在位置を保存
             先頭へ
             (while (re-search-forward パターン nil t)
               処理)
             処理
             位置を復帰

     ポイント:
             ・グローバル変数は避けましょう。
             ・A1, A2, A5 なんて時はどうしましょうかね?
               適当に仕様を決めて下さい(A3とかA6とか)。

     ただ、これによってアルゴリズムがかなり変わる↑




File: hustler., Node: Saving point Position, Prev: Search Functions Summary, Up: Cursor Motion

ポイント位置の保存
------------------

  カーソル移動のための関数を書く場合を除き、`Emacs-Lisp' 中でポイント移
動を行った場合には、ユーザのその後の編集の事を考慮し、ポイント位置を復
帰しておく必要があります。そのための関数が `save-excursion' です。

     (save-excursion 実行部...)

のようにポイント移動を伴う部分を `save-excursion' の中に閉じこめること
により、「実行部...」でいかなる場所にポイントを移動しようと、
`save-excursion' を抜けると同時に、ポイントは元の位置に復帰します。さら
に、マーク位置も保存されるので、「実行部...」でマーク位置にアクセスする
関数を書いた場合も、ユーザのその後の編集操作に支障を来しません。

  次の例は、ポイントのある行を `kill-ring' に入れつつ二重化します。

     (defun duplicate-line ()
       (interactive)
       (save-excursion
         (beginning-of-line)
         (copy-region-as-kill (point)
                  (progn (end-of-line) (point)))
         (forward-line 1)
         (yank)))

関数中でポイントを移動していますが、実行が終わると関数起動時のポイント
位置に復帰します。




File: hustler., Node: Inserting and Deleting Strings, Next: By-talk 5, Prev: Cursor Motion, Up: Functions You Must Know

文字列挿入/削除
===============


* Menu:

* Inserting Strings::           文字列挿入
* Transforming Types::          文字列と他の型の変換
* Type Transformation::         型変換
* Deleting Strings::            文字列削除
* Replacing Strings::           文字列置換
* Buffer Editing Functions Summary::  バッファ編集関数のまとめ




File: hustler., Node: Inserting Strings, Next: Transforming Types, Prev: Inserting and Deleting Strings, Up: Inserting and Deleting Strings

文字列挿入
----------

  既にメジャーモードの練習関数で、文字列を挿入する関数 `insert' は使用
済みです。ほとんどの文字列操作は `insert' 関数で用が足りますが、次のも
のを知っておくと便利な場合が有ります。

* Menu:

* insert-char::                 文字の挿入
* self-insert-command::



File: hustler., Node: insert-char, Next: self-insert-command, Prev: Inserting Strings, Up: Inserting Strings

insert-char
...........

  同じ文字をたくさん入れたい時に使用できます。引数を二つ取り、最初の引
数は文字コード、二つ目の引数は個数です。文字 `a' を100個入れたい時は次
のようにします。

     (insert-char ?a 100)




File: hustler., Node: self-insert-command, Prev: insert-char, Up: Inserting Strings

self-insert-command
...................

  `A-Z', `a-z', `0-9', など一般のキーに割当てられている関数がこれです。
`define-key' などでキーに結び付けられた関数中で、押したキーそのものを挿
入したいときにこの関数を利用します。この関数も、繰り返し挿入回数を指定
する引数を取るので通常は`(self-insert-command 1)' のように呼び出します。
(*Note define-code: Setting Keys.)

  ちなみに、キーバインドされた関数から、その関数が起動されたキーを知る
ためには、関数`(this-command-keys)'を参照します。次のような関数をいろい
ろなキーに割当てて実行してみるとおもしろいでしょう。

     (defun show-my-key ()
       (interactive)
       (insert (this-command-keys)))




File: hustler., Node: Transforming Types, Next: Type Transformation, Prev: Inserting Strings, Up: Inserting and Deleting Strings

文字列と他の型の変換
--------------------

* Menu:

* format::



File: hustler., Node: format, Prev: Transforming Types, Up: Transforming Types

format
......

  バッファ中に挿入したいのは文字列だけとは限りません。なにかの計算によっ
て選られた数値を文字列化して挿入したいことがあります。このような時に用
いるのが `format' 関数で、Cの `printf' でのフォーマットとほぼ同じものが
利用できます。ここで `Emacs-Lisp' で扱うことのできる型には、以下のもの
があります。

`シンボル'
     'foo, 'bar
`数値(整数)'
     1, 2, 3, -50, 65537 (24bits)
`char型'
     0 〜 127
`文字列'
     "foo", "こんにちは"

これらの型のものが単体で用いられる場合、それを「アトム `atom' 」と言い
ます。逆に様々な型のアトムが集合したものに、「リスト `list' 」と「配列
`array' 」があります。これらの概念については、一般の `Lisp' の参考書な
どを見ると説明が載っています。それを理解していると複雑な処理が効率的に
書けるようになることがあるかもしれませんが、とくに理解していなくてもメ
ジャーモードの作成には支障ありません。余裕ができたら覚えましょう。
(*Note atom list array: List.)


  さて、関数 `format' には、すべての型の値を文字列に変換するためのキー
ワードが三種類有ります。

`%s'
     シンボル、または文字列
`%d,%o,%x'
     数値(10,8,16進数表示)
`%c'
     char型数値を文字コードとみなし文字を表示

`format' 関数は第一引数に上記の `%' を含むフォーマット文字列を、第二引
数以降に文字列中の `%?' に対応する変数/定数を受け取ります。そして、それ
らの引数を文字列化したもので元の `%?' を置き換え、すべて置き換えること
で出来上がった文字列を返します。

  これを用いて各種の値を表示させてみます。

     (setq   foo 50
         bar ?x
         baz "hoge")
     (insert (format "%d, %o, %x  %s   %c  %s\n"
              foo foo foo 'foo bar baz ))

`format' 関数の第一引数中、`%?' が文字列に変換される様子は次のようにな
ります。

     %d  →  "50"
     %o  →  "62"
     %x  →  "32"
     %s  →  "foo"
     %c  →  "x"
     %s  →  "hoge"

従って format 関数が返す文字列は

     "50, 62, 32  foo   x  hero"

となります。




File: hustler., Node: Type Transformation, Next: Deleting Strings, Prev: Transforming Types, Up: Inserting and Deleting Strings

型変換
------

  バッファ中に存在する数値文字列を読み込みその値をもとになにかを計算し
結果を返すという処理を想定してみましょう。必要な処理内容は以下のものと
なります。

   * バッファ中の文字列の取り込み (バッファ→変数変換)
   * 文字列から数値への変換
   * 数値の計算
   * 数値から文字列への変換

ここでは、これらの処理に必要な関数をすべて覚えてしまいましょう。

* Menu:

* Getting Strings::             文字列の取込み
* Numerical Transformation::    数値変換
* Strings Transformation::      文字列変換
* String Manipulation Functions::  文字列操作関数



File: hustler., Node: Getting Strings, Next: Numerical Transformation, Prev: Type Transformation, Up: Type Transformation

文字列の取り込み
................

  バッファの内容を文字列として返す関数は `buffer-substring' です。この
関数は非常によく使うので、いやでも覚えてしまうでしょう。

     (buffer-substring ポイント値1 ポイント値2)

第一引数と第二引数の間の内容を文字列として返します。通常この関数は、検
索結果を保持している関数 `match-beginning', `match-end' と共に用いられ
ます。(*Note match-beginning: Accessing Search Results.)

  例として

     Bytes: 67 Date : 10:23pm  6/28/93 Author:net66331 (luneえもん)

という行から時刻を抽出する関数を定義してみましょう。そのためには、この
フォーマットで書かれている行を表現する正規表現を考える必要があります。
簡単のため、ここでは「行頭が `Bytes:' で始まり、時刻文字列があり、(ハン
ドル)で終わる行」というものにします。これをそのまま正規表現にすると、

     ^Bytes:.*[0-9 ][0-9]:[0-9][0-9][ap]m.*(.*)$
              ~~~~~~~~~~~|~~~~~~~~~~|~~~~

となるでしょう。しかし今回の場合時刻を取り出したいので、この部分をグルー
プ化して、

     ^Bytes:.*\([0-9 ][0-9]\):\([0-9][0-9]\)\([ap]m\).*(.*)$

とします。検索が成功した場合、`(match-beginning 1)'と `(match-end 1)'
に `時' の部分の先頭と末尾のポイント値が入るはずです(以下も同様)。これ
を Lisp 中に書くときは `\' を `\\' でエスケープすることを忘れないように
しましょう。

     (defun access-time ()
       (interactive)
       (re-search-forward
        "^Bytes:.*\\([0-9 ][0-9]\\):\\([0-9][0-9]\\)\\([ap]m\\).*(.*)$"
        nil t)
       (message
        (concat
         (if (string= (buffer-substring (match-beginning 3) (match-end 3))
              "am")
         "午前" "午後")
         (buffer-substring (match-beginning 1) (match-end 1)) "時"
         (buffer-substring (match-beginning 2) (match-end 2)) "分")))

関数 `string=' は文字列どうしが等しいかどうかを比較します。この例では、
グルーピングした3番目の部分、つまり `am' か `pm' の部分が、
`am' だったら `午前' を返し、そうでなかったら `午後' を返し
ています。さらに、グルーピングの1番目と2番目、つまり「時」と「分」の部分に
それぞれ `時' 、`分' を添えています。そしてそれらを
`concat' で全て結合したものを `message' 関数に渡しています。

  次の節に進む前に、もう少し分かり易く書き直しておきましょう。全く同じ
動作をします。

     (defun access-time ()
       (interactive)
       (re-search-forward
        "^Bytes:.*\\([0-9 ][0-9]\\):\\([0-9][0-9]\\)\\([ap]m\\).*(.*)$"
        nil t)
       (let((h  (buffer-substring (match-beginning 1) (match-end 1)))
            (m  (buffer-substring (match-beginning 2) (match-end 2)))
            (ap (buffer-substring (match-beginning 3) (match-end 3))))
         (message
          "%s%s時%s分" (if (string= ap "am") "午前" "午後") h m)))




File: hustler., Node: Numerical Transformation, Next: Strings Transformation, Prev: Getting Strings, Up: Type Transformation

数値変換
........

  数値を表わす文字列を実際の数値に変換するための関数は、
`string-to-int' です。

     (string-to-int "数値文字列")

もし、文字列が数値として意味のない文字列である場合は0を返します。では、
早速この関数を使って先程の例を24時間制で表示するように書き換えてみましょ
う(展開が予想できましたね?)。先の例では、`h' と `m' に時刻を表わす数値
文字列が入っているので、これを `string-to-int' で数値に変換し、もじ
`pm' だったら「時」に12を足しましょう。

     (defun access-time ()
       (interactive)
       (re-search-forward
        "^Bytes:.*\\([0-9 ][0-9]\\):\\([0-9][0-9]\\)\\([ap]m\\).*(.*)$"
        nil t)
       (let*((h  (buffer-substring (match-beginning 1) (match-end 1)))
             (m  (buffer-substring (match-beginning 2) (match-end 2)))
         (ap (buffer-substring (match-beginning 3) (match-end 3)))
         (hour (string-to-int h))
         (min  (string-to-int m)))
         (if (string= ap "pm") (setq hour (+ 12 hour)))
         (message "%d時%d分" hour min)))

新しい形 `let*' が出てきました。`let' との違いは、変数の初期化にそれ以
前のローカル変数の値を利用できる点です。上の例では、変数 `hour' の初期
化に `h' の値を利用しているので、`let*' を使う必要があります。

  余談となりますが、文字コードを返す関数として、`string-to-char' があり
ます。これは、引数として与えた文字列の先頭の一文字の文字コードを返しま
す。




File: hustler., Node: Strings Transformation, Next: String Manipulation Functions, Prev: Numerical Transformation, Up: Type Transformation

文字列変換
..........

  今回の例では `%s' による(出力時の)文字列への変換を用いたので、数値→
文字列(変数間)の型変換は用いませんでしたが、`string-to-int' の逆の仕事
をする `int-to-string' という関数があります。必要に応じて利用すると良い
でしょう。




File: hustler., Node: String Manipulation Functions, Prev: Strings Transformation, Up: Type Transformation

文字列操作関数
..............

  ついでに文字列に対する種々の操作関数を覚えておきましょう。 `M-x
apropos' で `string' をキーに探せばいろいろ出てきますが、ここでは主なも
のを取り上げます。

     (string-equal "文字列1" "文字列2")  ;string= と同じ
     (string< 文字列1 文字列2)
     (string> 文字列1 文字列2)           ;文字列の大小比較
     (string-match 正規表現 文字列)      ;第一引数の正規表現が第二引数の文
                                         ;字列中の何文字目にマッチするか。
                                         ;マッチしなければ nil
     (stringp 変数)                      ;変数の値が文字列かどうか
     (substring 文字列 開始 終了)        ;文字列の「開始」〜「終了」の部分
                                         ;文字列。第三引数を省略すると開始
                                         ;位置から文字列末尾まで。位置を負
                                         ;で与えると文字列の後ろから数える。




File: hustler., Node: Deleting Strings, Next: Replacing Strings, Prev: Type Transformation, Up: Inserting and Deleting Strings

文字列削除
----------

  バッファの一部を削除する関数で `Emacs-Lisp' 中から主に用いるのは以下
のものでしょう。

   * delete-char, delete-backward-char
   * delete-region
   * erase-buffer

`delete-char' と `delete-backward-char' は引数として削除する文字数を指
定します。しかし複数文字を削除する時は通常 `delete-region' を用います。

     (delete-region 削除開始ポイント値 削除終了ポイント値)

手で編集する時の関数 `kill-region' は、`kill-ring' を変えてしまうので、
*`Emacs-Lisp' 中から利用してはいけません* (1) (*Note Deleting
Strings-Footnotes::)。

  なにかのパターンを検索して該当部分を削除するということが多いので、
`delete-region' も `match-beginning', `match-end' と共に用いられること
がほとんどです。

  バッファ中に出現する特定のパターンを削除するというケースは非常に多く
あります。たとえば、

     [Continued]

というパターンを全て削除するコードは以下のようになります。

     (defun kill-more ()
       (interactive)
       (goto-char (point-min))
       (while (re-search-forward
         (delete-region (match-beginning 0) (match-end 0))))

このような、

     (while (検索関数 パターン nil t)
       (delete-region (match-beginning ??) (match-end ??)))

という関数の組み合わせは特定のパターンを全て削除する時の定石として覚え
ておきましょう。


File: hustler.  Node: Deleting Strings-Footnotes, Up: Deleting Strings

(1) kill-ring を変えることが目的のプログラムはこの限りでない。



File: hustler., Node: Replacing Strings, Next: Buffer Editing Functions Summary, Prev: Deleting Strings, Up: Inserting and Deleting Strings

文字列置換
----------

  単純な文字列の置換は、対話的に済ませることが多いのであまりプログラム
では必要とはなりません。やはり、正規表現検索と組み合わせる ことが多くな
ります。特定のパターンを一括置換する場合は次のように なります。次の例は、
コントロールコードの `^L' を `山記号' と `L' に置換します。

     (defun replace-C-l ()
       (interactive)
       (goto-char (point-min))
       (while (search-forward "\C-l" nil t)
         (replace-match "^L")))

この例の場合は、マッチした部分全体を置換していますがそのような時に使う
関数が `replace-match' で、`sed' の `s/old/new/' の後半にあたります。

     (replace-match  置換文字列
             大小文字を保存するかのフラグ
             \を特別扱いしないかのフラグ)

第二引数以降は省略可能です。また `\' を特別扱いしないフラグをセットしな
い場合は「置換文字列」の部分に次の表記が利用できます。

`\&'
     直前の検索でマッチした部分全体
`\n'
     `\(\)' で指定したグループの内容(nは1-9)
`\\'
     `\' 自身

既にお気付きでしょうが、前節の一括削除は `replace-match' を使うと

     (while (検索関数 パターン nil t)
       (replace-match ""))

と簡単に書くことができます。




File: hustler., Node: Buffer Editing Functions Summary, Prev: Replacing Strings, Up: Inserting and Deleting Strings

バッファ編集関数のまとめ
------------------------

     ・文字列挿入        insert, insert-char, self-insert-command
                         this-command-keys(関連)
     ・文字列の取り込み  buffer-substring
     ・型変換            format, string-to-int, int-to-string
                         string-to-char, char-to-string
     ・文字列比較等      string=, string<, string>, string-match
                         stringp, substring
     ・削除              delete-char, delete-backward-char
                         delete-region, erase-buffer
     ・置換              replace-match




File: hustler., Node: By-talk 5, Next: By-talk 6, Prev: Inserting and Deleting Strings, Up: Functions You Must Know

余談 5 雑関数
=============

  既に多くの人が利用しているので、次の関数は既習としましょう。

`(sleep-for 秒数)'
     「秒数」だけ休止する。
`(sit-for 秒数)'
     「秒数」だけ休止する。
     ただし、既にキー入力が行われていた場合は先に進む。
`(ding)'
     beep音を鳴らす。




File: hustler., Node: By-talk 6, Prev: By-talk 5, Up: Functions You Must Know

余談 6 Emacs-Lisp のスコープ
============================

  `Emacs-Lisp' ではダイナミックスコープ(動的スコープ)を採用しています。
これは、C言語などのスタティックスコープとは異なり、実行時に参照する変数
の実体が決定するものです。具体例を見てみましょう。次のプログラムの実行
結果を予想し、実際に確かめて見て下さい。

     /*---- C言語 ----*/
     char *s = "外側のs";
     sub()
     {
         printf("sub: s = %s\n", s);
     }
     main()
     {
         printf("main(外): s = %s\n", s);
         {
         char *s = "mainの中のs";
         printf("main(中): s = %s\n", s);
         sub();
         }
         sub();
     }

     ;;; -*- Emacs-Lisp -*-
     (defvar s "外側のs")
     (defun sub ()
       (insert (format "sub: s = %s\n" s)))
     (defun main ()
       (insert (format "main(外): s = %s\n" s))
       (let ((s "mainの中のs"))
         (insert (format "main(中): s = %s\n" s))
         (sub))
       (sub))

C言語では、あらゆるシンボルのスコープ(通用範囲)は、コンパイル時に決定さ
れます。先程のCのプログラムでは、次の図のような入れ子構造のスコープが形
成されています。

     +-----------------globalな箱----------------------+
     |    char *s = "外側のs";                         |
     |+---------------- subの箱 ----------------------+|
     ||   sub()                                       ||
     ||   {                                           ||
     ||       printf("sub: s = %s\n", s);             ||
     ||   }                                           ||
     |+-----------------------------------------------+|
     |+---------------- mainの箱 ---------------------+|
     ||   main()                                      ||
     ||   {                                           ||
     ||      printf("main(外): s = %s\n", s);         ||
     ||+----------- local-blockの箱 -----------------+||
     |||      {                                      |||
     |||          char *s = "mainの中のs";           |||
     |||          printf("main(中): s = %s\n", s);   |||
     |||          sub();                             |||
     |||      }                                      |||
     ||+---------------------------------------------+||
     ||       sub();                                  ||
     ||   }                                           ||
     |+-----------------------------------------------+|
     +-------------------------------------------------+

  それぞれの箱の壁は、内側から外側しか見ることのできないマジックミラー
になっていると考えると分かり易いかもしれません。なにかのシンボルが参照
されている場合、もしその箱の内部でそのシンボルが宣言されていた場合(例え
ば `local-block' の箱の中の`s')、そのシンボルが最優先で結合されます。逆
に箱の内部でシンボルが宣言されていない場合 (例えば `sub'の箱の `s')、コ
ンパイラは箱をどんどん外側に見ていき、見つかった場合そのシンボル(ここで
は `global' な箱に存在する `s')と結合します。

  つまり `sub()' では、変数 `s' は `global' な箱で宣言されている `s' と
結合され、これは `sub()' がいつ何時どこから呼ばれようと変わることはあり
ません。常に `外側のs' の格納されているアドレスを差しています。

  スタティックスコープでは、シンボルとその実体との結合は、シンボルの参
照が行われている箇所の、ソースプログラムでの位置によって決定されます。

  ところが、ダイナミックスコープでは、変数とその実体との結合は実行時に
行われます。先程の `Emacs-Lisp' プログラムの例を評価順に追って考える必
要があります。

     (defvar s "外側のs")                            ;これはロード時に評価される
     →main
       (insert (format "main(外): s = %s\n" s))      ;外側のsが有効
       (let ((s "mainの中のs"))                      ;ここでローカルなsが発生
         (insert (format "main(中): s = %s\n" s))    ;let中のsは"mainの中のs"
         (sub)                                       ;letを抜けると同時に
       )                                             ;ローカルなsは消滅
       (sub)                                         ;外側のsが再び有効
     →main 終わり

極端な例として、次のものの評価を追ってみると良いでしょう。

     (defun hoge ()
       (message "x = %d" x))
     (defun foo ()
       (let ((x 1)) (hoge)))
     (defun bar ()
       (let ((x 2)) (hoge)))
     (defun baz ()
       (hoge))

`(foo)', `(bar)', `(baz)' と順に評価してみて下さい。

  ダイナミックスコープの性質を利用すると、ある関数から下請関数を呼ぶす
る場合、引数の受け渡しを省略することができます。

     (defun natural-rand (n)
       (let ((r (random t)))
         (abs-r)
         (% r n)))
     (defun abs-r ()
       (if (< r 0) (setq r (- r))))

  しかし、このような利用法は関数の汎用性を損なうだけでなく、どの変数を
参照しているのかが分かりにくく、可読性を落とすことになるので、特殊な処
理でスピードを重視するようなもの以外では、利用しない方が良いでしょう。

* Menu:

* Exercise 3-2::                練習問題 3-2



File: hustler., Node: Exercise 3-2, Prev: By-talk 6, Up: By-talk 6

練習問題 3-2
------------

(1),(2)の好きな方を作成せよ。

選択問題(1) ASCII-NET のログを解析し、直前の書き込みとの時間的間隔
     が一番大きい書き込みを発見せよ。

       つまり、以下のような書き込みがあった場合、
     |Bytes: 3001 Date :  6:46am  7/12/93 Author:net92851 (ほんまたける)
     |   やっと出来ました。いまから学校か。結構辛い！
     |
     |Bytes: 36 Date : 12:14pm  7/12/93 Author:pcs39334 (はすらあ)
     |   おおついに!
     |
     |Bytes: 33 Date :  3:19pm  7/12/93 Author:net66331 (luneきち)
     |   バイトはどうなさったのでしょう

           の場合、6:46am→12:14pm→3:19pm
                        5h28m    3h05m
         なので、二番目の書き込みが該当する。

     ヒント:
             match-beginning, match-end, buffer-substring, string-to-int



選択問題(2) 先のるねきちモードのメッセージ「僕るねえもんXyyなりよ」
     はちょっと長いので、「るねXyyなりよ」に変更し、次の機能を付加せよ。

     「るねXyyなりよ」をたくさん表示させた状態で、
  1. `2',`4',`6',`8を押すと'、それぞれ 下/左/右/上 の
     `[A-Z][0-9]*' (以後これを「るね番号」と呼ぶ)に移動。
  2. スペースキーを押すと、1. 行末かバッファ末なら
     `(self-insert-command)' 2. るね番号 の上なら、1. 直前に押したキー
     が `26' なら、行末までのすべてのるね番号を「自爆」に置換する2. 直
     前に押したキーが `24' なら、行頭までのすべてのるね番号を「自爆」に
     置換するそれ以外なら `(call-interactively 'fill-paragraph)'
     ヒント:
             cond, looking-at, (substring (recent-keys) 負の数),
             string=
             「delete-region & insert」または「replace-match」
             (註: 関数 recent-keys は最近押されたキーを文字列として返す)

       余裕があれば、

     (1')2,4,6,8 のキーは一回押しただけでは動かず、二
     回目以降から動く。
        (つまり `(recent-keys)' の末尾二文字が同じ時に動く)

           かなり暇なら、

     るね番号を縦に結んだ線がなんとなく揃うように `fill-column' を調整する。

     (b3)直前キーが 626 なら、一つ右のるね番号に移動してからその真上にある
         (8で移動できる)るね番号全てを「自爆」に置換

     (b4)直前キーが 424 なら、一つ左のるね番号に移動してからその真上にある
         (8 で移動できる)るね番号全てを「自爆」に置換

     なお、以後これを「るねきちモードII」と呼ぶ。





File: hustler., Node: Completion Input, Next: Concept Index, Prev: Functions You Must Know, Up: Top

補完入力とその周辺
******************

  `Emacs' の持っている機能のうち最も強力なものの一つが文字列やファイル
名の補完入力で、入力支援のためのメジャーモードには必須の機能と言っても
過言ではないでしょう。本章では、補完入力機能を実装するために必要な知識
とその方法について説明します。

* Menu:

* Normal Input Functions::      一般入力関数
* Completion Input Functions::  補完入力関数
* By-talk 7::                   余談 7 マクロ



File: hustler., Node: Normal Input Functions, Next: Completion Input Functions, Prev: Completion Input, Up: Completion Input

一般入力関数
============

  補完入力関数の前に、通常の入力関数について説明します。文字列入力は、
`read-string' という関数によって行います。

     (read-string プロンプト文字列 [初期入力])

第一引数の文字列をプロンプトとして出し、ミニバッファから文字列を読み込
んでその結果を返します。この時に第二引数を与えると、それを読み込み時に
既に入力されていた文字列であるかのようにミニバッファに挿入します。

  日本語文字列やスペースを含む文字列を読み込む場合などは補完が有効に働
かないので、`read-string' 関数が役に立ちます。次の例は、天候を読み込み
日付と共にバッファ中に挿入します。

     (defun insert-date-weather ()
       (interactive)
       (insert
        (substring (current-time-string) 0 10)
        "\t"
        (read-string "Weather: ")
        "\n"))

  もうひとつ、ファイル名を読み込む `read-file-name' を紹介します。第二
引数以降は省略可能です。

     (read-file-name プロンプト文字列
             [ディレクトリ [デフォルト名 [要マッチ]]])

「ディレクトリ」はファイル名を入力するデフォルトのディレクトリ名を指定
しますが、これを省略するとカレントバッファの属するディレクトリとなりま
す。「デフォルト名」を指定すると、ユーザ自身が何も入力せずにリターンキー
を押した場合に、この値が `read-file-name' の結果として返されます。「要
マッチ」に `t' を指定した場合は実際に存在するファイル名以外の入力を認め
ません。`t' でも `nil' でもない値を指定した場合は、補完入力の途中でリター
ンキーを押した場合に本当にそのファイルでよいかどうかの確認をします。




File: hustler., Node: Completion Input Functions, Next: By-talk 7, Prev: Normal Input Functions, Up: Completion Input

補完入力関数
============

  ミニバッファで補完入力を行う関数が `completing-read' です。

     (completing-read プロンプト 補完テーブル 選択(述語)関数
              要マッチ 初期入力)

第一引数の「プロンプト」はミニバッファに出すプロンプト文字列、第四引数
の「要マッチ」は `read-file-name' のものと同様補完候補と必ず一致すべき
かどうかを指定するフラグ、第五引数はミニバッファに最初から入力されてい
る文字列で、それぞれ特に説明の必要はないでしょう。

  第二引数の「補完テーブル」はスペースキーやタブキーを押した時に補完さ
れる単語を格納した変数です。このテーブルの構造は連想リスト
`(association list)'(通称 `alist')と呼ばれるもので、`Lisp' 言語では非常
に良く使われます。`alist' に限らず「リスト」は、`Lisp' の機能を最大限に
活かした `Emacs-Lisp' プログラムを書くためには必須の概念ですから、この
機会に覚えておきましょう。

* Menu:

* List::                        リスト
* List Structure::              リストの構造
* List Manipulation Functions::  リスト処理関数
* Association Lists::           連想リスト




File: hustler., Node: List, Next: List Structure, Prev: Completion Input Functions, Up: Completion Input Functions

リスト
------

  `Lisp' で扱う対象の最小単位は「アトム」といい、今までに出てきた関数や
変数などの名前を表わす「シンボル」や、数値、文字列、`t'、`nil' などは全
てこれに属します。

  「リスト」とは、「アトムまたはリスト、の集合体」です。`Lisp' ではアト
ム、リストを括弧で括って並べることで集合体を表現します。つまり、それぞ
れのアトム `foo', `t', `"bar"' `5' を

     (foo t "bar" 5)

のように並べたものがリストとなります。ではこれを変数 `x' にセットしてみ
ましょう。

     (setq x (foo t "bar" 5))        ;×間違い

これでは期待通りになりません。`(foo ...)' という形は、「関数`foo の' 評
価」という意味なので、`Lisp' インタプリタは関数 `foo' に幾つかの引数を
渡した結果を `x' に代入しようとします(たいていは未定義エラーとなるでしょ
う)。リストの形で渡したい時は、次のように ' をつけてクォートする必要が
あります。

     (setq x '(foo t "bar" 5))

  ' は、次のオブジェクトを評価しない、つまり「後続するものを変数や関数
の参照だと思わずにそのまま渡してくれ」と `Lisp' インタプリタに指示する
働きを持っています。

  なお、本稿ではリストを表記する時は、関数評価との混乱を避けるため、'
でクォートして表わすことにします。




File: hustler., Node: List Structure, Next: List Manipulation Functions, Prev: List, Up: Completion Input Functions

リストの構造
------------

  `car', `cdr', `cons', `list', `append' などのリスト処理関数を覚える時
には、リストがどういう構造で格納されているかについて理解しておくと非常
にスムーズに関数の働きが理解できます。(*Note list: Creating
lists.)(*Note car cdr: Accessing list Elements.)(*Note cons: Adding
Elements to list.)(*Note append: Appending lists.)

  リスト中の各要素は「コンスセル」と呼ばれる記憶領域に格納されます。た
とえば前述のリストの例 `'(foo t "bar" 5)' はみかけから分かるように四つ
の要素から成っていますが、これらの各要素はそれぞれコンスセルに格納され
ています。コンスセルは次のような構造をとっています。

             +--------------+--------------+
             |              |     次の     |
             |     要素     | コンスセルの |
             |              |   アドレス   |
             +--------------+--------------+

これにしたがって `'(foo t "bar" 5)' の格納されている様子を図にしてみま
しょう。記号Λは、それが最後のコンスセルであることを意味します。通常は
Λを表わす `Lisp' シンボルとしては `nil' が入っています。

             +---------+---------+      +---------+---------+
             |         |         |      |         |         |
             |   foo   |    *----+----→|    t    |    *    |
             |         |         |      |         |    |    |
             +---------+---------+      +---------+----+----+
             +---------+---------+  +-----------------/
             |         |         |  |   +---------+---------+
             |    5    |   Λ    |  |   |         |         |
             |         |         |  +-→|  "bar"  |    *    |
             +---------+---------+      |         |    |    |
                  ↑                    +---------+----+----+
                   ＼----------------------------------/

`(setq x '(foo t "bar" 5))' はシンボル `x' にこれらのリスト(コンスセル
の連結)の先頭のアドレスを代入します。

             +--x--+
             |  *  |
             +-----+
                ↓
             +-----+-----+  +-----+-----+  +-----+-----+  +-----+-----+
             | foo |  *--+→|  t  |  *--+→|"bar"|  *--+→|  5  | Λ  |
             +-----+-----+  +-----+-----+  +-----+-----+  +-----+-----+

また、概念的に、`'(foo t "bar" 5)' の各要素を次のように把握しておくのも
良いでしょう。

             '(foo              t          "bar"           5)
               ↓              ↓           ↓            ↓
              fooと            tと         "bar"と         5と
             '(t "bar" 5)      '("bar" 5)      '(5)            Λ
               へのポインタ    へのポインタ   へのポインタ    のペア
                 のペア          のペア         のペア

  次に、リストの要素にリストがある場合について考えてみましょう。
`nil' と、これまで例として用いた `'(foo t "bar" 5)' と
`hoge' からなるリストは次のように表現できます。

     '(nil (foo t "bar" 5) hoge)

リストの要素として、リストをそのままの形で書くだけで良いのです。

  もう一つ、要素が一つもないリスト「空リスト」の存在も知っておく必要が
あります。空リストはリストの要素に何もないので、リストを括る括弧の中に
何も書かずに `'()' と表現します。空リストは常に `nil' を値として持って
います。`Emacs-Lisp' では空リストと `nil' は全く同じ意味を持ちます。

  さて `(setq x '(foo t "bar" 5))' について理解しておくべき重要な事項は
次のものです。

   * `x' はコンスセルの鎖の先頭(ここでは `foo' )のアドレスを指す
   * 第二要素以降はポインタを辿って行くことで順次得られる
   * あるリストの先頭のコンスセルへのポインタはリストそのものを指してい
     ることにほかならない




File: hustler., Node: List Manipulation Functions, Next: Association Lists, Prev: List Structure, Up: Completion Input Functions

リスト処理関数
--------------

* Menu:

* Creating lists::              リストの作成
* Accessing list Elements::     リストの要素の参照
* Adding Elements to list::     リストの要素の追加
* Appending lists::             リストどうしの結合
* List Related Predicates::     述語関数等



File: hustler., Node: Creating lists, Next: Accessing list Elements, Prev: List Manipulation Functions, Up: List Manipulation Functions

リスト作成
..........

  これまでは、リストの内容そのものを `'' でクォートして並べましたが、
各要素を列挙してそれらから構成されるリストを作成することができます。関数
`list' がそれです。引数は任意の個数だけ書けます。

     (list 'foo t "bar" baz)

のように書くことで、`foo t "bar" [bazの値]' からなるリストを作成し、こ
のリストへのポインタを返します。引数を全て評価したものを連結するので、
`baz' は `シンボル baz' ではなく `baz の値' になることに注意して下さい。
例えばこの場合、`(setq baz 5)' としていた場合、

     '(foo t "bar" 5)

というリストが生成されます。

  リストの中にリストがある場合も、要素の部分に `list' 関数で内側のリス
トを書けば良く、前述の

     '(nil (foo t "bar" 5) hoge)

は
     (list nil (list 'foo t "bar" baz) 'hoge)

で作成することができます。




File: hustler., Node: Accessing list Elements, Next: Adding Elements to list, Prev: Creating lists, Up: List Manipulation Functions

リストの要素の参照
..................

  要素の連結した形であるリストから、要素そのものを取り出す時に利用する
関数に `car'(かあ), `cdr'(くだー), `nth'(えぬす) があります。

  リストは複数のコンスセルから成っていますが、`car' と `cdr' は引数とし
て与えられたリストの先頭のコンスセルの、要素部分(`car部')とポインタ部分
(`cdr部')をそれぞれ返します。つまり、`'(foo t "bar" 5)'の先頭のコンスセ
ル(`foo' が入っているもの)は

             +--------------+--------------+
             |              | tの入っている|
             |     foo      | コンスセル   |
             |              | へのポインタ |
             +--------------+--------------+

となっているので、`(car '(foo t "bar" 5))' は `foo' を返し、 `(cdr
'(foo t "bar" 5))' は次のコンスセルへのポインタ、すなわち `t' を先頭と
するリスト `'(t "bar" 5)' を返します。 (*Note pointer cons: List
Structure.)

  では、`'(foo t "bar" 5)' の `cdr' をどんどん辿って行くとどうなるでしょ
う。次の例では、変数 `x' に `cdr' の結果を入れて行きます。

     (setq x '(foo t "bar" 5));x は '(foo t "bar" 5) ---(A)
     (setq x (cdr x))         ;x は '(t "bar" 5)     ---(B)
     (setq x (cdr x))         ;x は '("bar" 5)       ---(C)
     (setq x (cdr x))         ;x は '(5)             ---(D)
     (setq x (cdr x))         ;x は 'nil             ---(E)

(A)〜(E)の代入により変数 `x' の指し示すものは次のように変動します。

           (A)            (B)            (C)            (D)      (E)
         +--x--+        +--x--+        +--x--+        +--x--+  +--x--+
         |  *  |        |  *  |        |  *  |        |  *  |  |  *  |
         +-----+        +-----+        +-----+        +-----+  +-----+
            ↓             ↓             ↓             ↓       +→ nil
         +-----+-----+  +-----+-----+  +-----+-----+  +-----+-----+
         | foo |  *--+→|  t  |  *--+→|"bar"|  *--+→|  5  | Λ  |
         |     | (B) |  |     | (C) |  |     | (D) |  |     | (E) |
         +-----+-----+  +-----+-----+  +-----+-----+  +-----+-----+

  `car' と `cdr' を組み合わせると、リストの二番目三番目……の要素を取り
出すことができます。

     (car (cdr '(foo t "bar" 5)))            ;t
     (car (cdr (cdr '(foo t "bar" 5))))      ;"bar"
     (car (cdr (cdr (cdr '(foo t "bar" 5)))))    ;5

しかしこの方法ではもっと後ろの要素を取り出すのが大変なので、そのような時は
`nth' を使います。`nth' は

     (nth n番目 リスト)      ;「n番目」は0から始まる

のように用いることで、リストの「n番目」の要素を返します。




File: hustler., Node: Adding Elements to list, Next: Appending lists, Prev: Accessing list Elements, Up: List Manipulation Functions

リストの要素の追加
..................

  `(setq x (cdr x))' のようにすることで、リストの先頭を順次切り捨てて行
くことができます。これとは逆にリストに要素を追加する関数が、 `cons' で
す。

     (cons 要素 リスト)

は、「リスト」に「要素」を追加したリストを返します。`list' 関数もリスト
を生成して返しますが、`list' は引数全てを要素とするリストを新規に作成し
て返すのに対し、`cons' は既存のリストの先頭に新たな一つの要素を追加した
リストを返します。それではリストの逆の手順をとりつつ `'(foo t "bar"
5)' を構築して行きましょう。(*Note following cdr: Accessing list
Elements.)

     (setq x (cons 5 '()))       ;(setq x (cons 5 nil))と同じ (5)
     (setq x (cons "bar" x))     ;x は ("bar" 5)
     (setq x (cons t x))         ;x は (t "bar" 5)
     (setq x (cons 'foo x))      ;x は (foo "bar" 5)

最後の行を評価する前の `x' は次のようになっています。

                            +--x--+
                            |  *  |
                            +-----+
                              ↓
                            +-----+-----+  +-----+-----+  +-----+-----+
                            |  t  |  *--+→|"bar"|  *--+→|  5  | Λ  |
                            +-----+-----+  +-----+-----+  +-----+-----+

`(cons 'foo x)' により、`cons' はまず、`'foo' を `car' 部とするコンスセ
ルを新たに作成します。そして、その `cdr' 部にそれまで `x' が指していた
リストへのポインタを格納します。上の図は次のように変化します。

                            +--x--+
                            |  *  |
                            +-----+
                              ↓
             +-----+-----+  +-----+-----+  +-----+-----+  +-----+-----+
             | foo |  *--+→|  t  |  *--+→|"bar"|  *--+→|  5  | Λ  |
             +-----+-----+  +-----+-----+  +-----+-----+  +-----+-----+
             \________________これ全体が(cons 'foo x)________________/

そして最後に `(setq x (cons 'foo x))' により `x' が `(cons 'foo x)' で
生成されたリストを指し示すこととなります。

             +--x--+
             |  *  |
             +-----+
                ↓
             +-----+-----+  +-----+-----+  +-----+-----+  +-----+-----+
             | foo |  *--+→|  t  |  *--+→|"bar"|  *--+→|  5  | Λ  |
             +-----+-----+  +-----+-----+  +-----+-----+  +-----+-----+




File: hustler., Node: Appending lists, Next: List Related Predicates, Prev: Adding Elements to list, Up: List Manipulation Functions

リストどうしの結合
..................

  たくさんの要素を一つのリストに組み上げる `list'、一つのリストに一つの
要素を追加する `cons' は既に覚えました。つまり、「要素だけ」と「リスト
対要素」のリスト合成関数は覚えたので、「リスト対リスト」の結合関数
`append' を覚えましょう。`append' は引数として与えられたリストを全て結
合します。

     (append リスト1 リスト2 リスト3 ... リストn)

のようにした場合、「リスト1」から「リストn」のコンスセルを順次コピーし
それらの全てをつなげます。つまり、「リスト1」の最後のコンスセルのコピー
の`cdr部'(`nil'が入っている)に「リスト2」の最初のコンスセルのコピーへの
ポインタを格納し、「リスト2」の最後のコンスセルのコピーの`cdr部' に「リ
スト3」の最初のコンスセルへのポインタを格納し、...という手順を繰り返す
ことで、「リスト1」から「リストn」までのすべての要素(コンスセル)が一つ
の鎖に連結されます。そして `append' は連結されたリストを返します。

  この `append' の動作が、`cons' のものとは少し違うことに気付いたでしょ
うか。`cons' では第二引数として与えられたリストを構成するコンスセルのい
ずれも変化していません。`cons' の第一引数の要素を`car 部'とするコンスセ
ルを生成し、その`cdr部' が第二引数のリストを指し示すようにしただけにす
ぎません。これに対し `append' は第一引数から第 (n-1)引数までのリストの
コンスセルをすべてコピーし直します。 `append' によって返されたリストは、
どの部分も新たな領域に確保されたものです。




File: hustler., Node: List Related Predicates, Prev: Appending lists, Up: List Manipulation Functions

述語関数等
..........

  ある対象物がリストなのか、あるいはアトムなのかを判定するための関数は
それぞれ `listp', `atom' です。

     (listp 引数)
     (atom 引数)

は「引数」が リスト/アトム である場合に `t' を返し、そうでない場合に
`nil' を返します。

  また、リストに要素がいくつ含まれるかを返す関数に `length' があります。
`length' はリストの要素としてリストがあった場合はそれを一つと数えます。
つまり、

     '(a b c)
     '(1 '(a (b c) x) 4)

は、どちらも長さ3と数えます。`length' は、リストの他に、文字列や (ここ
では述べませんが)配列の長さを数える時にも利用できます。




File: hustler., Node: Association Lists, Prev: List Manipulation Functions, Up: Completion Input Functions

連想リスト
----------

`association list' は

     '(連想キー  値1  値2  ...  値n)

というリストが、一個以上集まってさらにリストになったもので、

     '((連想キー1  値1..値n) (連想キー2 ..) ...)

という形式をとっているもののことです。このリストを利用して検索キーが一
つだけの簡単なデータベースを作ることができます。たとえば、

     隆          波動拳、昇龍拳、竜巻旋風脚
     拳          昇龍拳、波動拳、竜巻旋風脚
     春麗        スピニングバードキック、百烈キック
     E.本田      スーパー頭付き、百烈張り手


という必殺技データベースを作りたい時に、

     (setq winning-shot-alist
           '(("隆"   "波動拳" "昇龍拳" "竜巻旋風脚")
             ("拳"   "昇龍拳" "波動拳" "竜巻旋風脚")
             ("春麗" "スピニングバードキック" "百烈キック")
             ("E.本田" "スーパー頭付き" "百烈張り手")))

などとして `alist' を作っておきます。この `alist' から連想キーを持って
いる `list' を取り出す関数が `assoc' で、

     (assoc  連想キー  連想リスト)

とすることで、「連想リスト」の中から「連想キー」を持っているリスト一つ
を見つけだしそのリストを返します。もし該当するキーを持つリストが見つか
らなかった場合は `nil' を返します。今回の `winning-shot-alist' に対して、
キーボードから読み込んだものをキーとして該当するものを探す場合は次のよ
うにします。

     (let ((key (read-string "誰のわざ? ")) list)
       (setq list (assoc key winning-shot-alist))
       (if list
           (message "%sの必殺技は%sです。" key (cdr list))
         (message "%sって誰?" key)))

`assoc' で得られるリストは、連想キーを含めたリストですから、値だけを取
り出したい時は、その `cdr' 部を取る必要があります。




File: hustler., Node: By-talk 7, Prev: Completion Input Functions, Up: Completion Input

余談 7 マクロ
=============

  検索後に、グルーピングしておいた文字列を取得するために、
`(buffer-substring (match-beginning 1) (match-end 1))' などとすること
はほとんど定石と言ってよいでしょう。にもかかわらず、これを一気に行う関数が
ありません(よね?)。そこで、`(buffer-substring (match-beginning n)
(match-end n))' という機能の関数を定義したいのですが、この程度で関数にする
のはちょっと抵抗を感ずるかもしれません。このような場合に、C言語の引数付き
`define' のような役割をする「マクロ」を利用すると良いでしょう。

  Cのマクロ定義と違って `Lisp' のマクロの展開のされ方は少し特殊です。次
のCのマクロの例

     #define inc(x)  ((x)++)

は、定義の引数以外は文字どおりに展開されます。しかし、`Lisp' のマクロは
事情が違います。`(setq i (1+ i))' のような動作を行うマクロ定義は次のよ
うになります。

     (defmacro inc(x)
       (list 'setq x (list '1+ x)))

このような定義を行った場合、`Lisp' プログラム中に `(inc i)' が出現した
場合 `Lisp' インタプリタはマクロ定義の仮引数 `x' に `i' を代入した上で
マクロ定義を `Lisp' そのものとして評価します。つまり、上の定義のうち
(クォートなしの) `x' を `i' とみなし `(list 'setq x (list '1+ x))' を評
価します(実際に `(setq x 'i)' してからこの式を評価してみると良いでしょ
う)。そして、得られた結果が期待したS式と同じになっているか確かめます。


* Menu:

* Exercise 4-1::                余談練習小問題
* completing-read::
* Variables Controlling Completion::  補完を制御する関数
* try-completion::
* all-completion display-completion-list::



File: hustler., Node: Exercise 4-1, Next: completing-read, Prev: By-talk 7, Up: By-talk 7

余談練習小問題
--------------

         (buffer-substring (match-beginning 番号) (match-end 番号))

を表わすマクロを定義してみましょう。




File: hustler., Node: completing-read, Next: Variables Controlling Completion, Prev: Exercise 4-1, Up: By-talk 7

completing-read
---------------

  さて、これまで連想リストの説明をしてきたので、`completing-read' に渡
す補完テーブルの説明に移ります。`completing-read' の引数を復習しておき
ましょう。

     (completing-read プロンプト 補完テーブル 選択(述語)関数
              要マッチ 初期入力)

`completing-read' の第二引数に補完テーブルを `alist' の形で渡します。例
えば曜日を読み込む時の補完テーブルは次のような形です。

     '(("Sun.") ("Mon.") ("Tue.") ("Wed.")
       ("Thu.") ("Fri.") ("Sat."))

今まで説明した `alist' とは少し形が違い、それぞれの(内側の)リストが連想
キーだけで構成されていて、それに対応する値が存在していません。補完入力
をしたいだけであれば、このような形で構いません。これを用いた曜日入力モ
ジュールは次のようになります。

     (defvar day-alist '(("Sun.") ("Mon.") ("Tue.") ("Wed.")
                 ("Thu.") ("Fri.") ("Sat.")))
     (defun read-day-of-the-week ()
       (interactive)
       (completing-read "Day of the week?: "
                day-alist nil t))

  `day-alist' に連想キーとして入っている文字列を補完候補として入力を促
し、スペースやタブで補完しながら文字を読み込みます。この例では第四引数
の「要マッチ」が `t' なので候補以外の文字列は入力することができません。

  さて、ここでは第三引数の「選択関数」のところには `nil' を指定しました
が、ここには補完テーブル中の要素のうち、特定の条件を満たすもの`(選択関
数の返す値が t)'を候補にしたい場合に利用します。「選択関数」には
`alist' の各要素が`(リストのまま)'渡されます。次の例では、月の名前を読
み込む時に、大の月だけを選んで補完候補とします。

     (defvar month-alist
       '(("Jan." 31) ("Feb." 28) ("Mar." 31) ("Apr." 30)
         ("May." 31) ("Jun." 30) ("Jul." 31) ("Aug." 31)
         ("Sep." 30) ("Oct." 31) ("Nov." 30) ("Dec." 31)))
     (defun read-odd-month ()
       (interactive)
       (completing-read "Odd month: " month-alist
                'check-odd-month t))
     (defun check-odd-month (list)
       (eq 31 (car (cdr list))))

関数 `check-odd-month' には `month-alist' の各要素、すなわち
`'("Jan." 31)', `'("Feb." 28)', ..., `''("Dec." 31) が渡さ
れるので、これらの第二要素を `(car (cdr list))' によって取り出し、
`31' かどうかを判定した結果を返しています。




File: hustler., Node: Variables Controlling Completion, Next: try-completion, Prev: completing-read, Up: By-talk 7

補完を制御する変数
------------------

  変数 `completion-ignore-case' を `t' にすると、補完文字列の大文字小文
字を無視します。例えば、月名を読む時に小文字で入力したイニシャルを元に
補完して欲しい時は、

     (let ((completion-ignore-case t))
       :
       (completing-read ...)...)

のように `completion-ignore-case' に局所的に `t' をセットして補完入力関
数を呼びます。




File: hustler., Node: try-completion, Next: all-completion display-completion-list, Prev: Variables Controlling Completion, Up: By-talk 7

try-completion
--------------

  前出の `completing-read' はミニバッファで補完候補を読むものでしたが、
バッファ中にある文字列を元に補完したものを得たい場合などに用いるのが
`try-completion' です。`Emacs-lisp' の関数を随時補完してくれる
`M-TAB' がその代表的なものです。

     (try-completion 文字列 補完テーブル [選択関数])

  第一引数の「文字列」を「補完テーブル」中のすべての候補と比較し、マッ
チしたものがあった場合、マッチしたもの共通部分の先頭からの文字列を返し
ます。もしマッチするものがなかった場合は `nil' を返し、「文字列」が「補
完テーブル」の中のただ一つの候補と完全一致した場合には、`t' を返します。
少々分かりにくいので例を挙げて説明します。

  例えば補完候補に `foo', `bar', `baz', `bazz',
`hoge', `hore' があった場合、次のような補完結果が得られます。

     「文字列(第一引数)」    try-completion の結果
             "f"                 "foo"
             "b"                 "ba"
             "ba"                "ba"
             "bar"               t
             "baz"               "baz"
             "h"                 "ho"
             "ho"                "ho"
             "hog"               "hoge"
             "x"                 nil

  これらの結果を考察すると `try-completion' の返り値を次のように判断す
ると良いことがわかります。

   * 結果が t である→補完の必要はなかった
   * 結果が nil である→一致するものがなかった。
   * 第一引数とは違う文字列→元の文字列を結果の文字列で置き換えるべき
     (結果の文字列が唯一の補完結果かどうかは分からないもう一度結果の文
     字列を第一引数として渡して t が返れば唯一の補完結果である)
   * 第一引数と同じ文字列→複数候補があるはずなのでそれらを表示する必要
     がある

  これより `try-completion' を用いてバッファ中の文字列の随時補完をする
手順は次のようになります。

     (defun complete-something ()
       (interactive)
       (補完文字列の先頭を探す)                      ;;(*1)
       (先頭からポイントまでの文字列を取得)
       (setq 結果 (try-completion 文字列 テーブル))
       (cond
        ((eq 結果 t) (これ以上補完の必要ないと表示))
        ((eq 結果 nil) (一致するものがないと表示))
        ((string= 文字列 結果)
         (先頭からポイントまでを切り取り、結果で置き換える))
        (t (候補一覧を表示))))                       ;;(*2)

  (*1)は一般的に、文字列の要素となり得ないものを後方に探します。例えば改行
文字や、空白文字は補完文字列とならないことがほとんどなので、
`(skip-chars-backward "^ \t\n")' とすれば十分でしょう。

  続いて(*2)のための関数を紹介します。




File: hustler., Node: all-completion display-completion-list, Prev: try-completion, Up: By-talk 7

all-completions display-completion-list
---------------------------------------

  関数 `all-completions' は `try-completion' と同じ引数を取り(第
二引数まで)、一致する文字列候補の全てをリストにして返します。例えば先の例
で、文字列 `ba' で補完させる場合に一致する候補は、`bar',
`baz', `bazz' ですから、これらをリストにした、`'("bar"
"baz" "bazz")' が `all-completions' の結果となります。これをバッファ
に表示したい時に利用するのが `display-completion-list' で、
`all-completions' で得られた結果をカレントバッファに表示します。

  実際にはカレントバッファに候補一覧を表示しては困るので、隣に新たなバッ
ファを開いて表示します。この方法に関しては、ウィンドウとバッファの取り
扱いを覚えてから説明します。




File: hustler., Node: Concept Index, Next: Function Index, Prev: Completion Input, Up: Top

Concept Index
*************


* Menu:

* absolute motion:              Absolute Motion Summary.  (line   5)
* arithmetic:                   Arithmetic.             (line   5)
* atom:                         List.                   (line   5)
* char 単位移動[ちやあたんいいとう]: Character Motion.  (line   5)
* characters, skipping:         Skipping Characters.    (line   5)
* completion, controlling variables: Variables Controlling Completion.  (line   5)
* completion, input:            Completion Input.       (line   5)
* control structure:            Control Structure.      (line   5)
* cursor motion:                Cursor Motion.          (line   5)
* debugging:                    By-talk 3.              (line   5)
* declaring, local maps:        Declaring Local Maps.   (line   5)
* defining, functions:          Defining Functions.     (line   5)
* defining, major mode functions: Defining Major Mode Functions.  (line   5)
* Emacs-Lisp, construction:     Construction of Emacs-Lisp.  (line   5)
* Emacs-Lisp, scope:            By-talk 6.              (line   5)
* Emacs-Lisp の構文[いいまくすりすふのこうふん]: Construction of Emacs-Lisp.  (line   5)
* Emacs-Lisp スコープ[いいまくすりすふすこうふ]: By-talk 6.  (line   5)
* escape characters:            Lisp Escape Characters.  (line   5)
* evaluating programs:          By-talk 4.              (line   5)
* Exercise 1:                   Exercise 1.             (line   5)
* Exercise 2:                   Exercise 2.             (line   5)
* Exercise 3-1:                 Exercise 3-1.           (line   5)
* Exercise 3-2:                 Exercise 3-2.           (line   5)
* Exercise 4-1:                 Exercise 4-1.           (line   5)
* Functions and Variables:      By-talk 2.              (line   5)
* functions, defining:          Defining Functions.     (line   5)
* functions, finding:           By-talk 1.              (line   5)
* functions, must know:         Functions You Must Know.  (line   5)
* Input Functions:              Completion Input Functions.  (line   5)
* Input Functions:              Normal Input Functions.  (line   5)
* interactive functions:        Interactive Functions.  (line   5)
* interactive functions, binding to keys: Binding Interactive Functions to Keys.  (line   5)
* keymaps, setting:             Setting Keymaps.        (line   5)
* keys, binding to interactive functions: Binding Interactive Functions to Keys.  (line   5)
* keys, setting:                Setting Keys.           (line   5)
* line 移動[らいんいとう]:      Line Motion.            (line   5)
* list:                         List.                   (line   5)
* list, accessing elements:     Accessing list Elements.  (line   5)
* list, adding elements:        Adding Elements to list.  (line   5)
* list, appending:              Appending lists.        (line   5)
* list, association:            Association Lists.      (line   5)
* list, creating:               Creating lists.         (line   5)
* list related predicates:      List Related Predicates.  (line   5)
* list, structure:              List Structure.         (line   5)
* local maps, declaring:        Declaring Local Maps.   (line   5)
* macros:                       By-talk 7.              (line   5)
* major mode, defining functions: Defining Major Mode Functions.  (line   5)
* major mode, requirements:     Requirements of a Major Mode.  (line   5)
* major mode, what:             What is Major Mode?.    (line   5)
* major mode, writing:          Writing Major Modes.    (line   5)
* Metachars:                    Major Metacharacters.   (line   5)
* mode name, setting:           Setting Mode Names.     (line   5)
* motion, absolute:             Absolute Motion.        (line   5)
* motion, boundary check:       Motion Boundary Check.  (line   5)
* motion, by char:              Character Motion.       (line   5)
* motion, by line:              Line Motion.            (line   5)
* motion, by search:            Motion by Search.       (line   5)
* motion, by word:              Word Motion.            (line   5)
* motion, cursor:               Cursor Motion.          (line   5)
* motion, point:                Motion by Point.        (line   5)
* motion, relative:             Relative Motion.        (line   5)
* motion, to a column:          Moving to a Column.     (line   5)
* motion, to a line:            Moving to a Line.       (line   5)
* numerical transformation:     Numerical Transformation.  (line   5)
* operators:                    Operators.              (line   5)
* point, saving position:       Saving point Position.  (line   5)
* relative motion:              Relative Motion.        (line   5)
* replacement, strings:         Replacing Strings.      (line   5)
* restricting variables:        Restricting Variables.  (line   5)
* scope, of Emacs-lisp:         By-talk 6.              (line   5)
* search, accessing results:    Accessing Search Results.  (line   5)
* search and move:              Motion by Search.       (line   5)
* search, regexp:               Regular Expression Search.  (line   5)
* search, strings:              String Search.          (line   5)
* search, word:                 Word Search.            (line   5)
* setting, keymaps:             Setting Keymaps.        (line   5)
* setting, keys:                Setting Keys.           (line   5)
* setting, mode names:          Setting Mode Names.     (line   5)
* skipping characters:          Skipping Characters.    (line   5)
* strings, deleting:            Deleting Strings.       (line   5)
* strings, getting:             Getting Strings.        (line   5)
* strings, insert:              Inserting Strings.      (line   5)
* strings, insert/delete:       Inserting and Deleting Strings.  (line   5)
* strings, manipulation functions: String Manipulation Functions.  (line   5)
* strings, replacement:         Replacing Strings.      (line   5)
* strings, transformation:      Strings Transformation.  (line   5)
* strings, transforming to other types: Transforming Types.  (line   5)
* symbol:                       List.                   (line   5)
* transformation, numerical:    Numerical Transformation.  (line   5)
* transformation, strings:      Strings Transformation.  (line   5)
* transformation, type:         Type Transformation.    (line   5)
* transforming, strings to other types: Transforming Types.  (line   5)
* try-completion:               try-completion.         (line   5)
* type transformation:          Type Transformation.    (line   5)
* Variables:                    Variables.              (line   5)
* Variables, declaring:         Declaring Variables.    (line   5)
* word 単位移動[わあとたんいいとう]: Word Motion.       (line   5)
* まとめ 1[まとめ1]:            Summary 1.              (line   5)
* アトム[あとむ]:               List.                   (line   5)
* インタラクティブ関数 キーにバインド[いんたらくてふかんすうきい]: Binding Interactive Functions to Keys.  (line   5)
* インタラクティブ関数[いんたらくていふかんすう]: Interactive Functions.  (line   5)
* エスケープキャラクタ[えすけえふきやらくた]: Lisp Escape Characters.  (line   5)
* カーソル移動[かあそるいとう]: Cursor Motion.          (line   5)
* キー 割当て[きいわりあて]:    Setting Keys.           (line   5)
* キーマップ 設定[きいまつふせつてい]: Setting Keymaps.  (line   5)
* コンスセル[こんすせる]:       Accessing list Elements.  (line  13)
* コンセル[こんせる]:           List Structure.         (line  16)
* シンボル[しんほる]:           List.                   (line   5)
* デバッギング[てはつきんく]:   By-talk 3.              (line   5)
* バッファ編集関数[はつふあへんしゆうかんすう]: Buffer Editing Functions Summary.  (line   5)
* プログラムの評価[ふろくらむのひようか]: By-talk 4.    (line   5)
* ポインタ[ほいんた]:           Accessing list Elements.  (line  13)
* ポインタ[ほいんた]:           List Structure.         (line  60)
* ポイント 位置の保存[ほいんといちのほそん]: Saving point Position.  (line   5)
* ポイント[ほいんと]:           point.                  (line   5)
* ポイント移動[ほいんといとう]: Motion by Point.        (line   5)
* マクロ[まくろ]:               By-talk 7.              (line   5)
* メジャーモード ってなに[めしやもおとつてなに]: What is Major Mode?.  (line   5)
* メジャーモード を書こう[めしやもおとをかこう]: Writing Major Modes.  (line   5)
* メジャーモード 必須条件[めしやもおとひすうしおうけん]: Requirements of a Major Mode.  (line   5)
* メジャーモード関数 定義[めしやもおとかんすうていき]: Defining Major Mode Functions.  (line   5)
* メタキャラクタ[めたきやらくた]: Major Metacharacters.  (line   5)
* モード名 設定[もおとめいせつてい]: Setting Mode Names.  (line   5)
* リスト 結合[りすとけつこう]:  Appending lists.        (line   5)
* リスト 構造[りすとこうそう]:  List Structure.         (line   5)
* リスト 作成[りすとさくせい]:  Creating lists.         (line   5)
* リスト 処理関数[りすとしよりかんすう]: List Manipulation Functions.  (line   5)
* リスト 要素の参照[りすとようそのさんしよう]: Accessing list Elements.  (line   5)
* リスト 要素の追加[りすとようそのついか]: Adding Elements to list.  (line   5)
* リスト 連想[りすとれんそう]:  Association Lists.      (line   5)
* リスト[りすと]:               List.                   (line   5)
* ローカルマップ 使用宣言[ろおかるまふしようせんけん]: Declaring Local Maps.  (line   5)
* 移動 char 単位[いとうちやあたんい]: Character Motion.  (line   5)
* 移動 line[いとうらいん]:      Line Motion.            (line   5)
* 移動 word 単位[いとうわあとたんい]: Word Motion.      (line   5)
* 移動 カーソル[いとうかあそる]: Cursor Motion.         (line   5)
* 移動 ポイント[いとうほいんと]: Motion by Point.       (line   5)
* 移動 境界の検査[いとうきようかいのけんさ]: Motion Boundary Check.  (line   5)
* 移動 桁[いとうけた]:          Moving to a Column.     (line   5)
* 移動 検索[いとうけんさく]:    Motion by Search.       (line   5)
* 移動 行[いとうきよう]:        Moving to a Line.       (line   5)
* 移動 絶対[いとうせつたい]:    Absolute Motion.        (line   5)
* 移動 相対[いとうそうたい]:    Relative Motion.        (line   5)
* 演算子[えんさんし]:           Operators.              (line   5)
* 関数 バッファ編集[かんすうはつふあへんしゆう]: Buffer Editing Functions Summary.  (line   5)
* 関数 リスト処理[かんすうりすとしより]: List Manipulation Functions.  (line   5)
* 関数 一般入力[かんすういつはんにゆうりよく]: Normal Input Functions.  (line   5)
* 関数 最低限[かんすうさいていけん]: Functions You Must Know.  (line   5)
* 関数 雑[かんすうさつ]:        By-talk 5.              (line   5)
* 関数 算術[かんすうさんしゆつ]: Arithmetic Functions.  (line   5)
* 関数 探す[かんすうさかす]:    By-talk 1.              (line   5)
* 関数 定義する[かんすうていきする]: Defining Functions.  (line   5)
* 関数 文字列操作[かんすうもしれつそうさ]: String Manipulation Functions.  (line   5)
* 関数 補完入力[かんすうほかんにゆうりよく]: Completion Input Functions.  (line   5)
* 関数・変数[かんすうとへんすう]: By-talk 2.            (line   5)
* 型変換[かたへんかん]:         Type Transformation.    (line   5)
* 桁移動[けたいとう]:           Moving to a Column.     (line   5)
* 検索 関数[けんさくけつか]:    Search Functions Summary.  (line   5)
* 検索 結果へのアクセス[けんさくけつかへのあくせす]: Accessing Search Results.  (line   5)
* 検索 正規表現[けんさくせいきひょうけん]: Regular Expression Search.  (line   5)
* 検索 単語[けんさくたんこ]:    Word Search.            (line   5)
* 検索, 文字列[けんさくもしれつ]: String Search.        (line   5)
* 検索移動[けんさくいとう]:     Motion by Search.       (line   5)
* 行移動[きよういとう]:         Moving to a Line.       (line   5)
* 削除 文字列[さくしょもしれつ]: Deleting Strings.      (line   5)
* 算術[さんしゆつ]:             Arithmetic.             (line   5)
* 算術関数[さんしゆつかんすう]: Arithmetic Functions.   (line   5)
* 述語関数[しゆつこかんすう]:   List Related Predicates.  (line   5)
* 章末問題 1[しようまつもんたい1]: Exercise 1.          (line   5)
* 章末問題 2[しようまつもんたい2]: Exercise 2.          (line   5)
* 数値変換[すうちへんかん]:     Numerical Transformation.  (line   5)
* 制御構造[せいきよこうそう]:   Control Structure.      (line   5)
* 正規表現検索[せいきひようけんけんさく]: Regular Expression Search.  (line   5)
* 絶対移動[せつたいいとう]:     Absolute Motion.        (line   5)
* 絶対移動[せつたいいとう]:     Absolute Motion Summary.  (line   5)
* 挿入 文字列[そうにゆうもしれつ]: Inserting Strings.   (line   5)
* 相対移動[そうたいいとう]:     Relative Motion.        (line   5)
* 単語検索[たんこけんさく]:     Word Search.            (line   5)
* 置換 文字列[ちかんもしれつ]:  Replacing Strings.      (line   5)
* 文字(種)スキップ[もしすきふ]: Skipping Characters.    (line   5)
* 文字列 検索[もしれつけんさく]: String Search.         (line   5)
* 文字列 削除[もしれつさくしよ]: Deleting Strings.      (line   5)
* 文字列 取り込み[もしれつとりこみ]: Getting Strings.   (line   5)
* 文字列 挿入[もしれつそうにゅう]: Inserting Strings.   (line   5)
* 文字列 挿入/削除[もしれつそうにゆうさくしよ]: Inserting and Deleting Strings.  (line   5)
* 文字列 他の型の変換[もしれつほかのかたのへんかん]: Transforming Types.  (line   5)
* 文字列 置換[もしれつちかん]:  Replacing Strings.      (line   5)
* 文字列 変換[もしれつへんかん]: Strings Transformation.  (line   5)
* 変換 型[へんかんかた]:        Type Transformation.    (line   5)
* 変換 数値[へんかんすうち]:    Numerical Transformation.  (line   5)
* 変換 文字列と他の型[へんかんもしれつとほかのかた]: Transforming Types.  (line   5)
* 変換 文字列[へんかんもしれつ]: Strings Transformation.  (line   5)
* 変数 宣言[へんすうせんけん]:  Declaring Variables.    (line   5)
* 変数 束縛[へんすうそくはく]:  Restricting Variables.  (line   5)
* 変数 補完を制御する[へんすうほかんをせいきよする]: Variables Controlling Completion.  (line   5)
* 変数[へんすう]:               Variables.              (line   5)
* 補完 制御する変数[ほかんせいきよするへんすう]: Variables Controlling Completion.  (line   5)
* 補完入力[ほかんにゆうりよく]: Completion Input.       (line   5)
* 余談 1 「〜関係の関数はないかな?」を探す[よたん1]: By-talk 1.  (line   5)
* 余談 2 関数・変数[よたん2]:   By-talk 2.              (line   5)
* 余談 3 デバッギング[よたん3]: By-talk 3.              (line   5)
* 余談 4 プログラムの評価[よたん4]: By-talk 4.          (line   5)
* 余談 5 雑関数[よたん5]:       By-talk 5.              (line   5)
* 余談 6 Emacs-Lisp のスコープ[よたん6]: By-talk 6.     (line   5)
* 余談 7 マクロ[よたん7]:       By-talk 7.              (line   5)
* 練習問題 3-1[れんしゆうもんたい31]: Exercise 3-1.     (line   5)
* 練習問題 3-2[れんしゆうもんたい32]: Exercise 3-2.     (line   5)
* 練習問題 4-1[れんしゆうもんたい41]: Exercise 4-1.     (line   5)



File: hustler., Node: Function Index, Next: Variable Index, Prev: Concept Index, Up: Top

Function Index
**************


* Menu:

* ':                            List.                   (line  26)
* $:                            Major Metacharacters.
* *:                            Major Metacharacters.
* +:                            Major Metacharacters.
* .:                            Major Metacharacters.
* ?:                            Major Metacharacters.
* ^:                            Major Metacharacters.
* \":                           Lisp Escape Characters.
* \\:                           Lisp Escape Characters.
* \&:                           Replacing Strings.
* \\:                           Replacing Strings.
* %, *, +, -, /:                Operators.
* <, <=, =, /=, >, >=:          Operators.
* 1+, 1-:                       Operators.
* \a:                           Lisp Escape Characters.
* alist:                        Association Lists.      (line  33)
* all-completion:               all-completion display-completion-list.  (line   5)
* and:                          and.                    (line   5)
* append:                       Appending lists.        (line   5)
* append:                       List Structure.         (line   5)
* apropos:                      By-talk 1.              (line   5)
* Arithmetic Functions:         Arithmetic Functions.   (line   5)
* assoc:                        Association Lists.      (line  33)
* atom:                         List Related Predicates.  (line   5)
* [-^A-Z]:                      Major Metacharacters.
* \b:                           Lisp Escape Characters.
* backward-char:                Character Motion.       (line   5)
* backward-word:                Word Motion.            (line   5)
* beginning-of-buffer:          Motion by Point.        (line  17)
* beginning-of-line:            Moving to a Column.     (line   5)
* (bobp) / (eobp):              Motion Boundary Check.
* (bolp) / (eolp):              Motion Boundary Check.
* Buffer Editing Functions:     Buffer Editing Functions Summary.  (line   5)
* buffer-substring:             Getting Strings.        (line   5)
* car:                          Accessing list Elements.  (line   5)
* car:                          List Structure.         (line   5)
* catch:                        catch trow.             (line   5)
* cdr:                          Accessing list Elements.  (line   5)
* cdr:                          List Structure.         (line   5)
* completing-read:              completing-read.        (line   5)
* completing-read:              Completion Input Functions.  (line   5)
* concat:                       Getting Strings.        (line  56)
* cond:                         cond.                   (line   5)
* cons:                         Adding Elements to list.  (line   5)
* cons:                         List Structure.         (line   5)
* count-lines:                  Moving to a Line.       (line   5)
* \C-英字:                      Lisp Escape Characters.
* Declaring Variables:          Declaring Variables.    (line   5)
* define-key:                   Setting Keys.           (line  10)
* Defining Functions:           Defining Functions.     (line   5)
* defmacro:                     By-talk 7.              (line   5)
* defun:                        By-talk 2.              (line  25)
* defvar:                       Declaring Variables.    (line   5)
* delete-backward-char:         Deleting Strings.       (line  12)
* delete-char:                  Deleting Strings.       (line  12)
* delete-region:                Deleting Strings.       (line  12)
* ding:                         By-talk 5.              (line  15)
* display-completion-list:      all-completion display-completion-list.  (line   5)
* \e:                           Lisp Escape Characters.
* end-of-buffer:                Motion by Point.        (line  17)
* end-of-line:                  Moving to a Column.     (line   5)
* erase-buffer:                 Deleting Strings.       (line  12)
* \f:                           Lisp Escape Characters.
* Finding Functions:            By-talk 1.              (line   5)
* format:                       format.                 (line   5)
* forward-char:                 Character Motion.       (line   5)
* forward-line:                 Line Motion.            (line   5)
* forward-word:                 Word Motion.            (line   5)
* goto-char:                    Motion by Point.        (line   5)
* goto-line:                    Moving to a Line.       (line   5)
* if:                           if.                     (line   5)
* input, completion:            Completion Input Functions.  (line   5)
* input, normal:                Normal Input Functions.  (line   5)
* insert:                       Inserting Strings.      (line   5)
* insert-char:                  insert-char.            (line   5)
* interactive:                  Binding Interactive Functions to Keys.  (line   5)
* Interactive Functions:        Interactive Functions.  (line   5)
* int-to-string:                Strings Transformation.  (line   5)
* kill-region:                  Deleting Strings.       (line  21)
* length:                       List Related Predicates.  (line  24)
* let:                          Restricting Variables.  (line  11)
* let*:                         Numerical Transformation.  (line  33)
* list:                         Creating lists.         (line   5)
* list:                         List Structure.         (line   5)
* List Manipulation:            List Manipulation Functions.  (line   5)
* list related predicates:      List Related Predicates.  (line   5)
* listp:                        List Related Predicates.  (line   5)
* make-keymap:                  Defining Functions.     (line  32)
* make-keymap:                  Setting Keymaps.        (line  21)
* match-beginning:              Accessing Search Results.  (line  20)
* match-end:                    Accessing Search Results.  (line  20)
* max, min:                     Arithmetic Functions.
* message:                      By-talk 3.              (line   9)
* Misc Functions:               By-talk 5.              (line   5)
* move-to-column:               Moving to a Column.     (line   5)
* \n:                           Lisp Escape Characters.
* \n:                           Replacing Strings.
* next-line:                    Line Motion.            (line   5)
* nth:                          Accessing list Elements.  (line   5)
* numberp(integerp):            Operators.
* or:                           or.                     (line   5)
* point:                        point.                  (line   5)
* point-max:                    point.                  (line   5)
* point-min:                    point.                  (line   5)
* predicates, list related:     List Related Predicates.  (line   5)
* previous-line:                Line Motion.            (line   5)
* progn:                        if.                     (line  19)
* \r:                           Lisp Escape Characters.
* random:                       Arithmetic Functions.
* read-file-name:               Normal Input Functions.  (line  29)
* read-string:                  Normal Input Functions.  (line   5)
* replace-match:                Replacing Strings.      (line  19)
* re-search-backward:           Regular Expression Search.  (line   5)
* re-search-forward:            Regular Expression Search.  (line   5)
* Restricting Variables:        Restricting Variables.  (line   5)
* save-excursion:               Saving point Position.  (line   5)
* Search Functions:             Search Functions Summary.  (line   5)
* search-backward:              String Search.          (line   5)
* search-forward:               String Search.          (line   5)
* self-insert-command:          self-insert-command.    (line   5)
* set:                          Variables.              (line   5)
* setq:                         Variables.              (line   5)
* sit-for:                      By-talk 3.              (line  14)
* sit-for:                      By-talk 5.              (line  15)
* skip-chars-backward:          Skipping Characters.    (line   5)
* skip-chars-forward:           Skipping Characters.    (line   5)
* sleep-for:                    By-talk 5.              (line  15)
* string=:                      Getting Strings.        (line  56)
* string<:                      String Manipulation Functions.  (line  21)
* string>:                      String Manipulation Functions.  (line  21)
* string-equal:                 String Manipulation Functions.  (line  21)
* string-match:                 String Manipulation Functions.  (line  21)
* stringp:                      String Manipulation Functions.  (line  21)
* Strings manipulation:         String Manipulation Functions.  (line   5)
* string-to-char:               Numerical Transformation.  (line  37)
* string-to-int:                Numerical Transformation.  (line   5)
* substring:                    String Manipulation Functions.  (line  21)
* \t:                           Lisp Escape Characters.
* this-command-keys:            self-insert-command.    (line  15)
* throw:                        catch trow.             (line   5)
* try-completion:               try-completion.         (line   5)
* use-local-map:                Declaring Local Maps.   (line   8)
* while:                        while.                  (line   5)
* word-search-backward:         Word Search.            (line   5)
* word-search-forward:          Word Search.            (line   5)
* [X-Y]:                        Major Metacharacters.
* [文字リスト]:                 Major Metacharacters.
* [^文字リスト]:                Major Metacharacters.
* 文字列操作[もしれつそうさ]:   String Manipulation Functions.  (line   5)



File: hustler., Node: Variable Index, Prev: Function Index, Up: Top

Variable Index
**************


* Menu:

* alist:                        completing-read.        (line  15)
* auto-mode-alist:              What is Major Mode?.    (line  16)
* case-fold-search:             Restricting Variables.  (line  18)
* Completion Controlling Variables: Variables Controlling Completion.  (line   5)
* completion-ignore-case:       Variables Controlling Completion.  (line   5)
* current-column:               Moving to a Column.     (line   5)
* global-map:                   Setting Keymaps.        (line  12)
* kill-ring:                    Saving point Position.  (line  31)
* mode-name:                    Setting Mode Names.     (line   5)


* Menu:

* C-j:                          By-talk 4.              (line  30)
* ESC C-x:                      By-talk 4.              (line  10)
* ESC ESC:                      By-talk 4.              (line  23)
* ESC TAB:                      By-talk 4.              (line  10)
* M-TAB:                        try-completion.         (line   5)

Tag table:
Node: Top177
Node: Writing Major Modes4047
Node: What is Major Mode?4489
Node: Requirements of a Major Mode4972
Node: Setting Mode Names5466
Node: Setting Keymaps5841
Node: Setting Keys6480
Node: Declaring Local Maps6963
Node: Defining Major Mode Functions7228
Node: Interactive Functions7607
Node: Binding Interactive Functions to Keys8299
Node: Defining Functions8817
Node: Exercise 19681
Node: Summary 110048
Node: By-talk 110696
Node: Construction of Emacs-Lisp11142
Node: Variables11639
Node: Declaring Variables12048
Node: Restricting Variables12365
Node: Control Structure13201
Node: if13425
Node: or13832
Node: and14192
Node: cond14383
Node: while15055
Node: catch trow15571
Node: Arithmetic16754
Node: Operators16958
Node: Arithmetic Functions17404
Node: Exercise 217624
Node: By-talk 217887
Node: By-talk 318552
Node: By-talk 419008
Node: Functions You Must Know19871
Node: Cursor Motion20325
Node: Relative Motion20851
Node: Character Motion21163
Node: Word Motion21434
Node: Line Motion21645
Node: Absolute Motion21988
Node: point22274
Node: Motion by Point22565
Node: Moving to a Line23010
Node: Moving to a Column23270
Node: Motion Boundary Check23539
Node: Absolute Motion Summary24063
Node: Motion by Search24666
Node: Lisp Escape Characters25361
Node: String Search26111
Node: Word Search26892
Node: Regular Expression Search27156
Node: Major Metacharacters27468
Node: Skipping Characters27983
Node: Accessing Search Results28643
Node: Search Functions Summary29622
Node: Exercise 3-130108
Node: Saving point Position31004
Node: Inserting and Deleting Strings31808
Node: Inserting Strings32214
Node: insert-char32552
Node: self-insert-command32805
Node: Transforming Types33346
Node: format33533
Node: Type Transformation34856
Node: Getting Strings35360
Node: Numerical Transformation37511
Node: Strings Transformation38665
Node: String Manipulation Functions38965
Node: Deleting Strings39763
Node: Replacing Strings40943
Node: Buffer Editing Functions Summary41855
Node: By-talk 542517
Node: By-talk 642819
Node: Exercise 3-246736
Node: Completion Input48406
Node: Normal Input Functions48799
Node: Completion Input Functions49842
Node: List50631
Node: List Structure51430
Node: List Manipulation Functions54320
Node: Creating lists54690
Node: Accessing list Elements55339
Node: Adding Elements to list57502
Node: Appending lists59533
Node: List Related Predicates60457
Node: Association Lists60932
Node: By-talk 762137
Node: Exercise 4-163246
Node: completing-read63450
Node: Variables Controlling Completion65181
Node: try-completion65575
Node: all-completion display-completion-list67439
Node: Concept Index68017
Node: Function Index81304
Node: Variable Index91153

End tag table
